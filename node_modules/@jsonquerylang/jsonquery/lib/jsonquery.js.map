{"version":3,"file":"jsonquery.js","sources":["../src/is.ts","../src/functions.ts","../src/compile.ts","../src/constants.ts","../src/parse.ts","../src/stringify.ts","../src/jsonquery.ts"],"sourcesContent":["export const isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const isObject = (value: unknown): value is object =>\n  value && typeof value === 'object' && !isArray(value)\n\nexport const isString = (value: unknown): value is string => typeof value === 'string'\n","import { compile } from './compile'\nimport { isArray } from './is'\nimport type {\n  Entry,\n  FunctionBuilder,\n  FunctionBuildersMap,\n  Getter,\n  JSONPath,\n  JSONQuery,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryProperty\n} from './types'\n\nexport function buildFunction(fn: (...args: unknown[]) => unknown): FunctionBuilder {\n  return (...args: JSONQuery[]) => {\n    const compiledArgs = args.map((arg) => compile(arg))\n\n    const arg0 = compiledArgs[0]\n    const arg1 = compiledArgs[1]\n\n    return compiledArgs.length === 1\n      ? (data: unknown) => fn(arg0(data))\n      : compiledArgs.length === 2\n        ? (data: unknown) => fn(arg0(data), arg1(data))\n        : (data: unknown) => fn(...compiledArgs.map((arg) => arg(data)))\n  }\n}\n\nexport const functions: FunctionBuildersMap = {\n  pipe: (...entries: JSONQuery[]) => {\n    const _entries = entries.map((entry) => compile(entry))\n\n    return (data: unknown) => _entries.reduce((data, evaluator) => evaluator(data), data)\n  },\n\n  object: (query: JSONQueryObject) => {\n    const getters: Getter[] = Object.keys(query).map((key) => [key, compile(query[key])])\n\n    return (data: unknown) => {\n      const obj = {}\n      for (const [key, getter] of getters) {\n        obj[key] = getter(data)\n      }\n      return obj\n    }\n  },\n\n  array: (...items: JSONQuery[]) => {\n    const _items = items.map((entry: JSONQuery) => compile(entry))\n\n    return (data: unknown) => _items.map((item) => item(data))\n  },\n\n  get: (...path: JSONPath) => {\n    if (path.length === 0) {\n      return (data: unknown) => data ?? null\n    }\n\n    if (path.length === 1) {\n      const prop = path[0]\n      return (data: unknown) => data?.[prop] ?? null\n    }\n\n    return (data: unknown) => {\n      let value = data\n\n      for (const prop of path) {\n        value = value?.[prop]\n      }\n\n      return value ?? null\n    }\n  },\n\n  map: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: T[]) => data.map(_callback)\n  },\n\n  mapObject: <T, U>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        const updated = _callback({ key, value: data[key] }) as Entry<U>\n        output[updated.key] = updated.value\n      }\n      return output\n    }\n  },\n\n  mapKeys: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        const updatedKey = _callback(key) as string\n        output[updatedKey] = data[key]\n      }\n      return output\n    }\n  },\n\n  mapValues: <T>(callback: JSONQuery) => {\n    const _callback = compile(callback)\n\n    return (data: Record<string, T>) => {\n      const output = {}\n      for (const key of Object.keys(data)) {\n        output[key] = _callback(data[key])\n      }\n      return output\n    }\n  },\n\n  filter: <T>(predicate: JSONQuery[]) => {\n    const _predicate = compile(predicate)\n\n    return (data: T[]) => data.filter((item) => truthy(_predicate(item)))\n  },\n\n  sort: <T>(path: JSONQueryProperty = ['get'], direction?: 'asc' | 'desc') => {\n    const getter = compile(path)\n    const sign = direction === 'desc' ? -1 : 1\n\n    function compare(itemA: unknown, itemB: unknown) {\n      const a = getter(itemA)\n      const b = getter(itemB)\n      return a > b ? sign : a < b ? -sign : 0\n    }\n\n    return (data: T[]) => data.slice().sort(compare)\n  },\n\n  reverse:\n    <T>() =>\n    (data: T[]) =>\n      data.toReversed(),\n\n  pick: (...properties: JSONQueryProperty[]) => {\n    const getters = properties.map(\n      ([_get, ...path]) => [path[path.length - 1], functions.get(...path)] as Getter\n    )\n\n    const _pick = (object: Record<string, unknown>, getters: Getter[]): unknown => {\n      const out = {}\n      for (const [key, getter] of getters) {\n        out[key] = getter(object)\n      }\n      return out\n    }\n\n    return (data: Record<string, unknown>): unknown => {\n      if (isArray(data)) {\n        return data.map((item: Record<string, unknown>) => _pick(item, getters))\n      }\n\n      return _pick(data, getters)\n    }\n  },\n\n  groupBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        if (res[value]) {\n          res[value].push(item)\n        } else {\n          res[value] = [item]\n        }\n      }\n\n      return res\n    }\n  },\n\n  keyBy: <T>(path: JSONQueryProperty) => {\n    const getter = compile(path)\n\n    return (data: T[]) => {\n      const res = {}\n\n      for (const item of data) {\n        const value = getter(item) as string\n        if (!(value in res)) {\n          res[value] = item\n        }\n      }\n\n      return res\n    }\n  },\n\n  flatten: () => (data: unknown[]) => data.flat(),\n\n  join:\n    <T>(separator = '') =>\n    (data: T[]) =>\n      data.join(separator),\n\n  split: buildFunction((text: string, separator?: string) =>\n    separator !== undefined ? text.split(separator) : text.trim().split(/\\s+/)\n  ),\n\n  substring: buildFunction((text: string, start: number, end?: number) =>\n    text.slice(Math.max(start, 0), end)\n  ),\n\n  uniq:\n    () =>\n    <T>(data: T[]) => [...new Set(data)],\n\n  uniqBy:\n    <T>(path: JSONQueryProperty) =>\n    (data: T[]): T[] =>\n      Object.values(functions.keyBy(path)(data)),\n\n  limit:\n    (count: number) =>\n    <T>(data: T[]) =>\n      data.slice(0, Math.max(count, 0)),\n\n  size:\n    () =>\n    <T>(data: T[]) =>\n      data.length,\n\n  keys: () => Object.keys,\n\n  values: () => Object.values,\n\n  prod: () => (data: number[]) => data.reduce((a, b) => a * b),\n\n  sum: () => (data: number[]) => data.reduce((a, b) => a + b),\n\n  average: () => (data: number[]) => (functions.sum()(data) as number) / data.length,\n\n  min: () => (data: number[]) => Math.min(...data),\n\n  max: () => (data: number[]) => Math.max(...data),\n\n  and: buildFunction((a, b) => !!(a && b)),\n  or: buildFunction((a, b) => !!(a || b)),\n  not: buildFunction((a: unknown) => !a),\n\n  exists: (queryGet: JSONQueryFunction) => {\n    const parentPath = queryGet.slice(1)\n    const key = parentPath.pop()\n    const getter = functions.get(...parentPath)\n\n    return (data: unknown) => {\n      const parent = getter(data)\n      return !!parent && Object.hasOwnProperty.call(parent, key)\n    }\n  },\n  if: (condition: JSONQuery, valueIfTrue: JSONQuery, valueIfFalse: JSONQuery) => {\n    const _condition = compile(condition)\n    const _valueIfTrue = compile(valueIfTrue)\n    const _valueIfFalse = compile(valueIfFalse)\n\n    return (data: unknown) => (truthy(_condition(data)) ? _valueIfTrue(data) : _valueIfFalse(data))\n  },\n  in: (path: string, values: JSONQuery) => {\n    const getter = compile(path)\n    const _values = compile(values)\n\n    return (data: unknown) => (_values(data) as string[]).includes(getter(data) as string)\n  },\n  'not in': (path: string, values: JSONQuery) => {\n    const _in = functions.in(path, values)\n\n    return (data: unknown) => !_in(data)\n  },\n  regex: (path: JSONQuery, expression: string, options?: string) => {\n    const regex = new RegExp(expression, options)\n    const getter = compile(path)\n\n    return (data: unknown) => regex.test(getter(data) as string)\n  },\n\n  eq: buildFunction((a, b) => a === b),\n  gt: buildFunction((a, b) => a > b),\n  gte: buildFunction((a, b) => a >= b),\n  lt: buildFunction((a, b) => a < b),\n  lte: buildFunction((a, b) => a <= b),\n  ne: buildFunction((a, b) => a !== b),\n\n  add: buildFunction((a: number, b: number) => a + b),\n  subtract: buildFunction((a: number, b: number) => a - b),\n  multiply: buildFunction((a: number, b: number) => a * b),\n  divide: buildFunction((a: number, b: number) => a / b),\n  pow: buildFunction((a: number, b: number) => a ** b),\n  mod: buildFunction((a: number, b: number) => a % b),\n  abs: buildFunction(Math.abs),\n  round: buildFunction((value: number, digits = 0) => {\n    const num = Math.round(Number(`${value}e${digits}`))\n    return Number(`${num}e${-digits}`)\n  }),\n\n  number: buildFunction((text: string) => {\n    const num = Number(text)\n    return Number.isNaN(Number(text)) ? null : num\n  }),\n  string: buildFunction(String)\n}\n\nconst truthy = (x: unknown) => x !== null && x !== 0 && x !== false\n","import { functions } from './functions'\nimport { isArray, isObject } from './is'\nimport type {\n  Fun,\n  FunctionBuildersMap,\n  JSONQuery,\n  JSONQueryCompileOptions,\n  JSONQueryFunction\n} from './types'\n\nconst functionsStack: FunctionBuildersMap[] = []\n\nexport function compile(query: JSONQuery, options?: JSONQueryCompileOptions): Fun {\n  functionsStack.unshift({ ...functions, ...functionsStack[0], ...options?.functions })\n\n  try {\n    const exec = isArray(query)\n      ? compileFunction(query as JSONQueryFunction, functionsStack[0]) // function\n      : isObject(query)\n        ? throwTypeError(\n            `Function notation [\"object\", {...}] expected but got ${JSON.stringify(query)}`\n          )\n        : () => query // primitive value (string, number, boolean, null)\n\n    // create a wrapper function which can attach a stack to the error\n    return (data) => {\n      try {\n        return exec(data)\n      } catch (err) {\n        // attach a stack to the error\n        err.jsonquery = [{ data, query }, ...(err.jsonquery ?? [])]\n\n        throw err\n      }\n    }\n  } finally {\n    functionsStack.shift()\n  }\n}\n\nfunction compileFunction(query: JSONQueryFunction, functions: FunctionBuildersMap) {\n  const [fnName, ...args] = query\n\n  const fnBuilder = functions[fnName]\n  if (!fnBuilder) {\n    throwTypeError(`Unknown function '${fnName}'`)\n  }\n\n  return fnBuilder(...args)\n}\n\nfunction throwTypeError(message: string): () => void {\n  throw new Error(message)\n}\n","export const operators = {\n  and: 'and',\n  or: 'or',\n\n  eq: '==',\n  gt: '>',\n  gte: '>=',\n  lt: '<',\n  lte: '<=',\n  ne: '!=',\n\n  add: '+',\n  subtract: '-',\n  multiply: '*',\n  divide: '/',\n  pow: '^',\n  mod: '%',\n\n  in: 'in',\n  'not in': 'not in'\n}\n\nexport const unquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nexport const startsWithUnquotedPropertyRegex = /^[a-zA-Z_$][a-zA-Z\\d_$]*/\nexport const startsWithStringRegex = /^\"(?:[^\"\\\\]|\\\\.)*\"/ // https://stackoverflow.com/a/249937/1262753\nexport const startsWithNumberRegex = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/ // https://stackoverflow.com/a/13340826/1262753\nexport const startsWithIntRegex = /^(0|[1-9][0-9]*)/\nexport const startsWithKeywordRegex = /^(true|false|null)/\nexport const startsWithWhitespaceRegex = /^[ \\n\\t\\r]+/\n","import {\n  operators,\n  startsWithIntRegex,\n  startsWithKeywordRegex,\n  startsWithNumberRegex,\n  startsWithStringRegex,\n  startsWithUnquotedPropertyRegex,\n  startsWithWhitespaceRegex\n} from './constants'\nimport { functions } from './functions'\nimport type { JSONQuery, JSONQueryParseOptions } from './types'\n\n/**\n * Parse a string containing a JSON Query into JSON.\n *\n * Example:\n *\n *     const textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *     const jsonQuery = parse(textQuery)\n *     // jsonQuery = [\n *     //    'pipe',\n *     //    ['get', 'friends'],\n *     //    ['filter', ['eq', ['get', 'city'], 'New York']],\n *     //    ['sort', ['get', 'age']],\n *     //    ['pick', ['get', 'name'], ['get', 'age']]\n *     //  ]\n */\nexport function parse(query: string, options?: JSONQueryParseOptions): JSONQuery {\n  const allOperators = { ...operators, ...options?.operators }\n  const sortedOperatorNames = Object.keys(allOperators).sort((a, b) => b.length - a.length)\n\n  const parsePipe = () => {\n    skipWhitespace()\n    const first = parseOperator()\n    skipWhitespace()\n\n    if (query[i] === '|') {\n      const pipe = [first]\n\n      while (query[i] === '|') {\n        i++\n        skipWhitespace()\n\n        pipe.push(parseOperator())\n      }\n\n      return ['pipe', ...pipe]\n    }\n\n    return first\n  }\n\n  const parseOperator = () => {\n    const left = parseParenthesis()\n\n    skipWhitespace()\n\n    // we sort the operators from longest to shortest, so we first handle \"<=\" and next \"<\"\n    for (const name of sortedOperatorNames) {\n      const op = allOperators[name]\n      if (query.substring(i, i + op.length) === op) {\n        i += op.length\n        skipWhitespace()\n        const right = parseParenthesis()\n\n        return [name, left, right]\n      }\n    }\n\n    return left\n  }\n\n  const parseParenthesis = () => {\n    if (query[i] === '(') {\n      i++\n      const inner = parsePipe()\n      eatChar(')')\n      return inner\n    }\n\n    return parseProperty()\n  }\n\n  const parseProperty = () => {\n    if (query[i] === '.') {\n      const props = []\n\n      while (query[i] === '.') {\n        i++\n\n        props.push(\n          parseString() ??\n            parseUnquotedString() ??\n            parseInteger() ??\n            throwError('Property expected')\n        )\n      }\n\n      return ['get', ...props]\n    }\n\n    return parseFunction()\n  }\n\n  const parseFunction = () => {\n    const start = i\n    const name = parseUnquotedString()\n    skipWhitespace()\n    if (!name || query[i] !== '(') {\n      i = start\n      return parseObject()\n    }\n    i++\n\n    if (!options?.functions[name] && !functions[name]) {\n      throwError(`Unknown function '${name}'`)\n    }\n\n    skipWhitespace()\n\n    const args = query[i] !== ')' ? [parsePipe()] : []\n    while (i < query.length && query[i] !== ')') {\n      skipWhitespace()\n      eatChar(',')\n      args.push(parsePipe())\n    }\n\n    eatChar(')')\n\n    return [name, ...args]\n  }\n\n  const parseObject = () => {\n    if (query[i] === '{') {\n      i++\n      skipWhitespace()\n\n      const object = {}\n      let first = true\n      while (i < query.length && query[i] !== '}') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        const key =\n          parseString() ?? parseUnquotedString() ?? parseInteger() ?? throwError('Key expected')\n\n        skipWhitespace()\n        eatChar(':')\n\n        object[key] = parsePipe()\n      }\n\n      eatChar('}')\n\n      return ['object', object]\n    }\n\n    return parseArray()\n  }\n\n  const parseArray = () => {\n    if (query[i] === '[') {\n      i++\n      skipWhitespace()\n\n      const array = []\n\n      let first = true\n      while (i < query.length && query[i] !== ']') {\n        if (first) {\n          first = false\n        } else {\n          eatChar(',')\n          skipWhitespace()\n        }\n\n        array.push(parsePipe())\n      }\n\n      eatChar(']')\n\n      return ['array', ...array]\n    }\n\n    return parseString() ?? parseNumber() ?? parseKeyword()\n  }\n\n  const parseString = () => parseRegex(startsWithStringRegex, JSON.parse)\n\n  const parseUnquotedString = () => parseRegex(startsWithUnquotedPropertyRegex, (text) => text)\n\n  const parseNumber = () => parseRegex(startsWithNumberRegex, JSON.parse)\n\n  const parseInteger = () => parseRegex(startsWithIntRegex, JSON.parse)\n\n  const parseKeyword = () => {\n    const keyword = parseRegex(startsWithKeywordRegex, JSON.parse)\n    if (keyword !== undefined) {\n      return keyword\n    }\n\n    // end of the parsing chain\n    throwError('Value expected')\n  }\n\n  const parseEnd = () => {\n    skipWhitespace()\n\n    if (i < query.length) {\n      throwError(`Unexpected part '${query.substring(i)}'`)\n    }\n  }\n\n  const parseRegex = <T = string>(regex: RegExp, callback: (match: string) => T): T | undefined => {\n    const match = query.substring(i).match(regex)\n    if (match) {\n      i += match[0].length\n      return callback(match[0])\n    }\n  }\n\n  const skipWhitespace = () => parseRegex(startsWithWhitespaceRegex, (text) => text)\n\n  const eatChar = (char: string) => {\n    if (query[i] !== char) {\n      throwError(`Character '${char}' expected`)\n    }\n    i++\n  }\n\n  const throwError = (message: string, pos = i) => {\n    throw new SyntaxError(`${message} (pos: ${pos})`)\n  }\n\n  let i = 0\n  const output = parsePipe()\n  parseEnd()\n\n  return output\n}\n","import { operators, unquotedPropertyRegex } from './constants'\nimport { isArray } from './is'\nimport type {\n  JSONPath,\n  JSONQuery,\n  JSONQueryFunction,\n  JSONQueryObject,\n  JSONQueryStringifyOptions\n} from './types'\n\nconst DEFAULT_MAX_LINE_LENGTH = 40\nconst DEFAULT_INDENTATION = '  '\n\n/**\n * Stringify a JSON Query into a readable, human friendly text syntax.\n *\n * Example:\n *\n *     const jsonQuery = [\n *         ['get', 'friends'],\n *         ['filter', ['eq', ['get', 'city'], 'New York']],\n *         ['sort', ['get', 'age']],\n *         ['pick', ['get', 'name'], ['get', 'age']]\n *       ]\n *     const textQuery = stringify(jsonQuery)\n *     // textQuery = '.friends | filter(.city == \"new York\") | sort(.age) | pick(.name, .age)'\n *\n * @param query The JSON Query to be stringified\n * @param {Object} [options] An object which can have the following options:\n *                 `maxLineLength` Optional maximum line length. When the query exceeds this maximum,\n *                                 It will be formatted over multiple lines. Default value: 40.\n *                 `indentation`   Optional indentation. Defaults to a string with two spaces: '  '.\n */\nexport const stringify = (query: JSONQuery, options?: JSONQueryStringifyOptions) => {\n  const space = options?.indentation ?? DEFAULT_INDENTATION\n\n  const _stringify = (query: JSONQuery, indent: string) =>\n    isArray(query) ? stringifyFunction(query as JSONQueryFunction, indent) : JSON.stringify(query) // value (string, number, boolean, null)\n\n  const stringifyFunction = (query: JSONQueryFunction, indent: string) => {\n    const [name, ...args] = query\n\n    if (name === 'get' && args.length > 0) {\n      return stringifyPath(args as JSONPath)\n    }\n\n    if (name === 'pipe') {\n      const argsStr = args.map((arg) => _stringify(arg, indent + space))\n\n      return join(argsStr, ['', ' | ', ''], ['', `\\n${indent + space}| `, ''])\n    }\n\n    if (name === 'object') {\n      return stringifyObject(args[0] as JSONQueryObject, indent)\n    }\n\n    if (name === 'array') {\n      const argsStr = args.map((arg) => _stringify(arg, indent))\n      return join(\n        argsStr,\n        ['[', ', ', ']'],\n        [`[\\n${indent + space}`, `,\\n${indent + space}`, `\\n${indent}]`]\n      )\n    }\n\n    // operator like \".age >= 18\"\n    const op = options?.operators?.[name] ?? operators[name]\n    if (op && args.length === 2) {\n      const [left, right] = args\n      const leftStr = _stringify(left, indent)\n      const rightStr = _stringify(right, indent)\n      return `(${leftStr} ${op} ${rightStr})`\n    }\n\n    // regular function like sort(.age)\n    const childIndent = args.length === 1 ? indent : indent + space\n    const argsStr = args.map((arg) => _stringify(arg, childIndent))\n    return args.length === 1 && argsStr[0][0] === '('\n      ? `${name}${argsStr[0]}`\n      : join(\n          argsStr,\n          [`${name}(`, ', ', ')'],\n          args.length === 1\n            ? [`${name}(`, `,\\n${indent}`, ')']\n            : [`${name}(\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent})`]\n        )\n  }\n\n  const stringifyObject = (query: JSONQueryObject, indent: string) => {\n    const childIndent = indent + space\n    const entries = Object.entries(query).map(([key, value]) => {\n      return `${stringifyProperty(key)}: ${_stringify(value, childIndent)}`\n    })\n\n    return join(\n      entries,\n      ['{ ', ', ', ' }'],\n      [`{\\n${childIndent}`, `,\\n${childIndent}`, `\\n${indent}}`]\n    )\n  }\n\n  const stringifyPath = (path: JSONPath): string =>\n    path.map((prop) => `.${stringifyProperty(prop)}`).join('')\n\n  const stringifyProperty = (prop: string): string =>\n    unquotedPropertyRegex.test(prop) ? prop : JSON.stringify(prop)\n\n  type JoinDefinition = [start: string, separator: string, end: string]\n\n  const join = (\n    items: string[],\n    [compactStart, compactSeparator, compactEnd]: JoinDefinition,\n    [formatStart, formatSeparator, formatEnd]: JoinDefinition\n  ): string => {\n    const compactLength =\n      compactStart.length +\n      items.reduce((sum: number, item: string) => sum + item.length + compactSeparator.length, 0) -\n      compactSeparator.length +\n      compactEnd.length\n\n    return compactLength <= (options?.maxLineLength ?? DEFAULT_MAX_LINE_LENGTH)\n      ? compactStart + items.join(compactSeparator) + compactEnd\n      : formatStart + items.join(formatSeparator) + formatEnd\n  }\n\n  return _stringify(query, '')\n}\n","import { compile } from './compile'\nimport { isString } from './is'\nimport { parse } from './parse'\nimport type { JSONQuery, JSONQueryOptions } from './types'\n\nexport function jsonquery(\n  data: unknown,\n  query: string | JSONQuery,\n  options?: JSONQueryOptions\n): unknown {\n  return compile(isString(query) ? parse(query, options) : query, options)(data)\n}\n\nexport { compile } from './compile'\nexport { stringify } from './stringify'\nexport { parse } from './parse'\nexport { buildFunction } from './functions'\n\nexport * from './types'\n"],"names":["isArray","value","isObject","isString","buildFunction","fn","args","compiledArgs","arg","compile","arg0","arg1","data","functions","entries","_entries","entry","evaluator","query","getters","key","obj","getter","items","_items","item","path","prop","callback","_callback","output","updated","updatedKey","predicate","_predicate","truthy","direction","sign","compare","itemA","itemB","a","b","properties","_get","_pick","object","out","res","separator","text","start","end","count","queryGet","parentPath","parent","condition","valueIfTrue","valueIfFalse","_condition","_valueIfTrue","_valueIfFalse","values","_values","_in","expression","options","regex","digits","num","x","functionsStack","exec","compileFunction","throwTypeError","err","fnName","fnBuilder","message","operators","unquotedPropertyRegex","startsWithUnquotedPropertyRegex","startsWithStringRegex","startsWithNumberRegex","startsWithIntRegex","startsWithKeywordRegex","startsWithWhitespaceRegex","parse","allOperators","sortedOperatorNames","parsePipe","skipWhitespace","first","parseOperator","i","pipe","left","parseParenthesis","name","op","right","inner","eatChar","parseProperty","props","parseString","parseUnquotedString","parseInteger","throwError","parseFunction","parseObject","parseArray","array","parseNumber","parseKeyword","parseRegex","keyword","parseEnd","match","char","pos","DEFAULT_MAX_LINE_LENGTH","DEFAULT_INDENTATION","stringify","space","_stringify","indent","stringifyFunction","_a","stringifyPath","argsStr","join","stringifyObject","leftStr","rightStr","childIndent","stringifyProperty","compactStart","compactSeparator","compactEnd","formatStart","formatSeparator","formatEnd","sum","jsonquery"],"mappings":"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"}