{"version":3,"file":"index.js","sources":["../node_modules/svelte/src/internal/disclose-version.js","../node_modules/svelte/src/version.js","../node_modules/svelte/src/internal/flags/index.js","../node_modules/svelte/src/constants.js","../node_modules/esm-env/false.js","../node_modules/svelte/src/internal/client/constants.js","../node_modules/svelte/src/internal/shared/utils.js","../node_modules/svelte/src/internal/client/dom/task.js","../node_modules/svelte/src/internal/client/reactivity/equality.js","../node_modules/svelte/src/internal/client/reactivity/sources.js","../node_modules/svelte/src/internal/client/runtime.js","../node_modules/svelte/src/internal/client/errors.js","../node_modules/svelte/src/internal/client/reactivity/deriveds.js","../node_modules/svelte/src/internal/client/dom/hydration.js","../node_modules/svelte/src/internal/client/dom/operations.js","../node_modules/svelte/src/internal/client/proxy.js","../node_modules/svelte/src/internal/client/reactivity/effects.js","../node_modules/svelte/src/internal/shared/errors.js","../node_modules/svelte/src/internal/client/context.js","../node_modules/svelte/src/utils.js","../node_modules/svelte/src/internal/client/dom/elements/misc.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js","../node_modules/svelte/src/internal/client/dom/elements/events.js","../node_modules/svelte/src/internal/client/dom/reconciler.js","../node_modules/svelte/src/internal/client/dom/template.js","../node_modules/svelte/src/internal/client/render.js","../node_modules/svelte/src/internal/client/dom/blocks/if.js","../node_modules/svelte/src/internal/client/dom/blocks/key.js","../node_modules/svelte/src/internal/client/dom/blocks/each.js","../node_modules/svelte/src/internal/client/dom/blocks/html.js","../node_modules/svelte/src/internal/client/dom/blocks/slot.js","../node_modules/svelte/src/internal/client/dom/blocks/svelte-component.js","../node_modules/svelte/src/internal/client/dom/elements/actions.js","../node_modules/clsx/dist/clsx.mjs","../node_modules/svelte/src/internal/shared/attributes.js","../node_modules/svelte/src/internal/client/dom/elements/attributes.js","../node_modules/svelte/src/internal/client/dom/elements/class.js","../node_modules/svelte/src/internal/client/dom/elements/style.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/input.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/props.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/select.js","../node_modules/svelte/src/internal/client/dom/elements/bindings/this.js","../node_modules/svelte/src/internal/client/dom/legacy/event-modifiers.js","../node_modules/svelte/src/internal/client/dom/legacy/lifecycle.js","../node_modules/svelte/src/internal/client/dom/legacy/misc.js","../node_modules/svelte/src/index-client.js","../node_modules/svelte/src/internal/client/reactivity/store.js","../node_modules/svelte/src/internal/client/reactivity/props.js","../src/lib/utils/debug.ts","../src/lib/utils/uniqueId.ts","../src/lib/utils/numberUtils.ts","../src/lib/utils/typeUtils.ts","../src/lib/utils/arrayUtils.ts","../src/lib/utils/jsonUtils.ts","../src/lib/types.ts","../src/lib/utils/domUtils.ts","../src/lib/utils/navigatorUtils.ts","../src/lib/utils/keyBindings.ts","../node_modules/style-inject/dist/style-inject.es.js","../src/lib/components/modals/popup/AbsolutePopupEntry.svelte","../src/lib/components/modals/popup/AbsolutePopup.svelte","../src/lib/utils/stringUtils.ts","../src/lib/plugins/query/jsonQueryLanguage.ts","../node_modules/svelte-awesome/package/components/svg/Raw.svelte","../node_modules/svelte-awesome/package/components/Icon.svelte","../node_modules/svelte-awesome/package/components/svg/Svg.svelte","../src/lib/plugins/value/components/BooleanToggle.svelte","../src/lib/components/controls/ColorPickerPopup.svelte","../src/lib/plugins/value/components/ColorPicker.svelte","../src/lib/constants.ts","../src/lib/logic/expandItemsSections.ts","../src/lib/typeguards.ts","../src/lib/logic/documentState.ts","../src/lib/logic/selection.ts","../src/lib/utils/cssUtils.ts","../src/lib/plugins/value/components/utils/getValueClass.ts","../src/lib/components/controls/EditableDiv.svelte","../src/lib/plugins/value/components/EditableValue.svelte","../src/lib/logic/operations.ts","../src/lib/logic/search.ts","../src/lib/components/modes/treemode/highlight/SearchResultHighlighter.svelte","../src/lib/plugins/value/components/ReadonlyValue.svelte","../src/lib/components/controls/tooltip/Tooltip.svelte","../src/lib/components/controls/tooltip/tooltip.ts","../src/lib/plugins/value/components/TimestampTag.svelte","../src/lib/plugins/value/renderValue.ts","../src/lib/utils/pathUtils.ts","../src/lib/components/modals/transformModalStates.ts","../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","../node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../node_modules/svelte-floating-ui/index.js","../node_modules/svelte-select/filter.js","../node_modules/svelte-select/get-items.js","../node_modules/svelte-select/Select.svelte","../src/lib/components/modals/TransformWizard.svelte","../src/lib/components/controls/selectQueryLanguage/SelectQueryLanguage.svelte","../src/lib/components/modals/Header.svelte","../src/lib/components/controls/createAutoScrollHandler.ts","../src/lib/assets/jump.js/src/easing.ts","../src/lib/assets/jump.js/src/jump.ts","../src/lib/utils/timeUtils.ts","../src/lib/logic/validation.ts","../src/lib/components/controls/createFocusTracker.ts","../src/lib/components/controls/Message.svelte","../src/lib/components/controls/ValidationErrorsOverview.svelte","../src/lib/actions/onEscape.ts","../src/lib/components/modals/Modal.svelte","../src/lib/components/modals/CopyPasteModal.svelte","../src/lib/components/controls/Menu.svelte","../src/lib/components/modals/repair/JSONRepairComponent.svelte","../src/lib/components/modals/JSONRepairModal.svelte","../src/lib/components/modes/treemode/CollapsedItems.svelte","../src/lib/components/controls/contextmenu/ContextMenuPointer.svelte","../src/lib/components/modes/treemode/JSONValue.svelte","../src/lib/components/modes/treemode/singleton.ts","../src/lib/logic/dragging.ts","../src/lib/components/modes/treemode/ValidationErrorIcon.svelte","../src/lib/components/modes/treemode/JSONNode.svelte","../src/lib/components/modes/treemode/JSONKey.svelte","../src/lib/img/customFontawesomeIcons.ts","../src/lib/logic/sort.ts","../src/lib/components/controls/navigationBar/NavigationBarDropdown.svelte","../src/lib/components/controls/navigationBar/NavigationBarItem.svelte","../src/lib/utils/copyToClipboard.ts","../src/lib/components/controls/navigationBar/NavigationBarPathEditor.svelte","../src/lib/components/controls/navigationBar/NavigationBar.svelte","../src/lib/components/controls/SearchBox.svelte","../src/lib/logic/table.ts","../src/lib/logic/actions.ts","../src/lib/components/controls/JSONPreview.svelte","../src/lib/components/controls/contextmenu/ContextMenuButton.svelte","../src/lib/components/controls/contextmenu/ContextMenuDropDownButton.svelte","../src/lib/components/controls/DropdownButton.svelte","../src/lib/components/controls/contextmenu/ContextMenu.svelte","../src/lib/plugins/value/components/EnumValue.svelte","../src/lib/utils/jsonSchemaUtils.ts","../src/lib/plugins/value/renderJSONSchemaEnum.ts","../src/lib/plugins/validator/createAjvValidator.ts","../src/lib/plugins/query/jmespathQueryLanguage.ts","../src/lib/plugins/query/jsonpathQueryLanguage.ts","../src/lib/plugins/query/lodashQueryLanguage.ts","../src/lib/plugins/query/javascriptQueryLanguage.ts","../src/lib/actions/resizeObserver.ts","../src/lib/components/modes/treemode/TreeMode.svelte","../src/lib/components/modes/treemode/contextmenu/createTreeContextMenuItems.ts","../src/lib/components/modes/treemode/menu/TreeMenu.svelte","../src/lib/components/modes/treemode/Welcome.svelte","../src/lib/utils/readonlyProxy.ts","../src/lib/logic/history.ts","../src/lib/components/modals/TransformModal.svelte","../src/lib/components/modals/TransformModalHeader.svelte","../src/lib/utils/noop.ts","../src/lib/utils/fileUtils.ts","../src/lib/components/modes/textmode/codemirror/codemirror-theme.ts","../node_modules/codemirror-wrapped-line-indent/dist/index.js","../src/lib/components/modes/textmode/TextMode.svelte","../src/lib/components/modes/textmode/menu/TextMenu.svelte","../src/lib/components/modes/textmode/StatusBar.svelte","../src/lib/components/modes/tablemode/TableModeWelcome.svelte","../src/lib/components/modes/tablemode/TableMode.svelte","../src/lib/components/modes/tablemode/contextmenu/createTableContextMenuItems.ts","../src/lib/components/modes/tablemode/menu/TableMenu.svelte","../src/lib/components/modes/tablemode/ColumnHeader.svelte","../src/lib/components/modes/tablemode/RefreshColumnHeader.svelte","../src/lib/components/modes/tablemode/tag/InlineValue.svelte","../src/lib/components/modes/JSONEditorRoot.svelte","../src/lib/components/modals/sortModalStates.ts","../src/lib/components/JSONEditor.svelte","../src/lib/components/modals/SortModal.svelte","../src/lib/components/modals/JSONEditorModal.svelte","../src/lib/index-vanilla.ts"],"sourcesContent":["import { PUBLIC_VERSION } from '../version.js';\n\nif (typeof window !== 'undefined')\n\t// @ts-ignore\n\t(window.__svelte ||= { v: new Set() }).v.add(PUBLIC_VERSION);\n","// generated during release, do not modify\n\n/**\n * The current version, as set in package.json.\n * @type {string}\n */\nexport const VERSION = '5.20.0';\nexport const PUBLIC_VERSION = '5';\n","export let legacy_mode_flag = false;\nexport let tracing_mode_flag = false;\n\nexport function enable_legacy_mode_flag() {\n\tlegacy_mode_flag = true;\n}\n\nexport function enable_tracing_mode_flag() {\n\ttracing_mode_flag = true;\n}\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 2;\nexport const EACH_IS_ANIMATED = 1 << 3;\nexport const EACH_ITEM_IMMUTABLE = 1 << 4;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_BINDABLE = 1 << 3;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 4;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\n/** used to indicate that an `{:else}...` block was rendered */\nexport const HYDRATION_START_ELSE = '[!';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n// Dev-time component properties\nexport const FILENAME = Symbol('filename');\nexport const HMR = Symbol('hmr');\n\nexport const NAMESPACE_SVG = 'http://www.w3.org/2000/svg';\nexport const NAMESPACE_MATHML = 'http://www.w3.org/1998/Math/MathML';\n\n// we use a list of ignorable runtime warnings because not every runtime warning\n// can be ignored and we want to keep the validation for svelte-ignore in place\nexport const IGNORABLE_RUNTIME_WARNINGS = /** @type {const} */ ([\n\t'state_snapshot_uncloneable',\n\t'binding_property_non_reactive',\n\t'hydration_attribute_changed',\n\t'hydration_html_changed',\n\t'ownership_invalid_binding',\n\t'ownership_invalid_mutation'\n]);\n\n/**\n * Whitespace inside one of these elements will not result in\n * a whitespace node being created in any circumstances. (This\n * list is almost certainly very incomplete)\n * TODO this is currently unused\n */\nexport const ELEMENTS_WITHOUT_TEXT = ['audio', 'datalist', 'dl', 'optgroup', 'select', 'video'];\n","export default false;\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const BOUNDARY_EFFECT = 1 << 7;\nexport const UNOWNED = 1 << 8;\nexport const DISCONNECTED = 1 << 9;\nexport const CLEAN = 1 << 10;\nexport const DIRTY = 1 << 11;\nexport const MAYBE_DIRTY = 1 << 12;\nexport const INERT = 1 << 13;\nexport const DESTROYED = 1 << 14;\nexport const EFFECT_RAN = 1 << 15;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 16;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 17;\nexport const INSPECT_EFFECT = 1 << 18;\nexport const HEAD_EFFECT = 1 << 19;\nexport const EFFECT_HAS_DERIVED = 1 << 20;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_SYMBOL_METADATA = Symbol('$state metadata');\nexport const LEGACY_PROPS = Symbol('legacy props');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var index_of = Array.prototype.indexOf;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n\nexport const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n\n/**\n * TODO replace with Promise.withResolvers once supported widely enough\n * @template T\n */\nexport function deferred() {\n\t/** @type {(value: T) => void} */\n\tvar resolve;\n\n\t/** @type {(reason: any) => void} */\n\tvar reject;\n\n\t/** @type {Promise<T>} */\n\tvar promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\n\t// @ts-expect-error\n\treturn { promise, resolve, reject };\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {V | (() => V)} fallback\n * @param {boolean} [lazy]\n * @returns {V}\n */\nexport function fallback(value, fallback, lazy = false) {\n\treturn value === undefined\n\t\t? lazy\n\t\t\t? /** @type {() => V} */ (fallback)()\n\t\t\t: /** @type {V} */ (fallback)\n\t\t: value;\n}\n","import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nexport const request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\nlet is_micro_task_queued = false;\nlet is_idle_task_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_micro_tasks = [];\n/** @type {Array<() => void>} */\nlet current_queued_idle_tasks = [];\n\nfunction process_micro_tasks() {\n\tis_micro_task_queued = false;\n\tconst tasks = current_queued_micro_tasks.slice();\n\tcurrent_queued_micro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_idle_tasks() {\n\tis_idle_task_queued = false;\n\tconst tasks = current_queued_idle_tasks.slice();\n\tcurrent_queued_idle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(process_micro_tasks);\n\t}\n\tcurrent_queued_micro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (!is_idle_task_queued) {\n\t\tis_idle_task_queued = true;\n\t\trequest_idle_callback(process_idle_tasks);\n\t}\n\tcurrent_queued_idle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_micro_task_queued) {\n\t\tprocess_micro_tasks();\n\t}\n\tif (is_idle_task_queued) {\n\t\tprocess_idle_tasks();\n\t}\n}\n","/** @import { Equals } from '#client' */\n/** @type {Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function not_equal(a, b) {\n\treturn a !== b;\n}\n\n/** @type {Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","/** @import { Derived, Effect, Reaction, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport {\n\tactive_reaction,\n\tactive_effect,\n\tuntracked_writes,\n\tget,\n\tschedule_effect,\n\tset_untracked_writes,\n\tset_signal_status,\n\tuntrack,\n\tincrement_write_version,\n\tupdate_effect,\n\tderived_sources,\n\tset_derived_sources,\n\tcheck_dirtiness,\n\tset_is_flushing_effect,\n\tis_flushing_effect,\n\tuntracking\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport {\n\tCLEAN,\n\tDERIVED,\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tINSPECT_EFFECT,\n\tUNOWNED,\n\tMAYBE_DIRTY,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT\n} from '../constants.js';\nimport * as e from '../errors.js';\nimport { legacy_mode_flag, tracing_mode_flag } from '../../flags/index.js';\nimport { get_stack } from '../dev/tracing.js';\nimport { component_context, is_runes } from '../context.js';\n\nexport let inspect_effects = new Set();\n\n/**\n * @param {Set<any>} v\n */\nexport function set_inspect_effects(v) {\n\tinspect_effects = v;\n}\n\n/**\n * @template V\n * @param {V} v\n * @param {Error | null} [stack]\n * @returns {Source<V>}\n */\nexport function source(v, stack) {\n\t/** @type {Value} */\n\tvar signal = {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\tv,\n\t\treactions: null,\n\t\tequals,\n\t\trv: 0,\n\t\twv: 0\n\t};\n\n\tif (DEV && tracing_mode_flag) {\n\t\tsignal.created = stack ?? get_stack('CreatedAt');\n\t\tsignal.debug = null;\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {V} v\n */\nexport function state(v) {\n\treturn push_derived_source(source(v));\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @param {boolean} [immutable]\n * @returns {Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value, immutable = false) {\n\tconst s = source(initial_value);\n\tif (!immutable) {\n\t\ts.equals = safe_equals;\n\t}\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (legacy_mode_flag && component_context !== null && component_context.l !== null) {\n\t\t(component_context.l.s ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {V} v\n * @param {boolean} [immutable]\n * @returns {Source<V>}\n */\nexport function mutable_state(v, immutable = false) {\n\treturn push_derived_source(mutable_source(v, immutable));\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n */\n/*#__NO_SIDE_EFFECTS__*/\nfunction push_derived_source(source) {\n\tif (active_reaction !== null && !untracking && (active_reaction.f & DERIVED) !== 0) {\n\t\tif (derived_sources === null) {\n\t\t\tset_derived_sources([source]);\n\t\t} else {\n\t\t\tderived_sources.push(source);\n\t\t}\n\t}\n\n\treturn source;\n}\n\n/**\n * @template V\n * @param {Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function set(source, value) {\n\tif (\n\t\tactive_reaction !== null &&\n\t\t!untracking &&\n\t\tis_runes() &&\n\t\t(active_reaction.f & (DERIVED | BLOCK_EFFECT)) !== 0 &&\n\t\t// If the source was created locally within the current derived, then\n\t\t// we allow the mutation.\n\t\t(derived_sources === null || !derived_sources.includes(source))\n\t) {\n\t\te.state_unsafe_mutation();\n\t}\n\n\treturn internal_set(source, value);\n}\n\n/**\n * @template V\n * @param {Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function internal_set(source, value) {\n\tif (!source.equals(value)) {\n\t\tvar old_value = source.v;\n\t\tsource.v = value;\n\t\tsource.wv = increment_write_version();\n\n\t\tif (DEV && tracing_mode_flag) {\n\t\t\tsource.updated = get_stack('UpdatedAt');\n\t\t\tif (active_effect != null) {\n\t\t\t\tsource.trace_need_increase = true;\n\t\t\t\tsource.trace_v ??= old_value;\n\t\t\t}\n\t\t}\n\n\t\tmark_reactions(source, DIRTY);\n\n\t\t// It's possible that the current reaction might not have up-to-date dependencies\n\t\t// whilst it's actively running. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e: `$effect(() => x++)`\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tactive_effect !== null &&\n\t\t\t(active_effect.f & CLEAN) !== 0 &&\n\t\t\t(active_effect.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0\n\t\t) {\n\t\t\tif (untracked_writes === null) {\n\t\t\t\tset_untracked_writes([source]);\n\t\t\t} else {\n\t\t\t\tuntracked_writes.push(source);\n\t\t\t}\n\t\t}\n\n\t\tif (DEV && inspect_effects.size > 0) {\n\t\t\tconst inspects = Array.from(inspect_effects);\n\t\t\tvar previously_flushing_effect = is_flushing_effect;\n\t\t\tset_is_flushing_effect(true);\n\t\t\ttry {\n\t\t\t\tfor (const effect of inspects) {\n\t\t\t\t\t// Mark clean inspect-effects as maybe dirty and then check their dirtiness\n\t\t\t\t\t// instead of just updating the effects - this way we avoid overfiring.\n\t\t\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t\t\t}\n\t\t\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\t\t\tupdate_effect(effect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t\t}\n\t\t\tinspect_effects.clear();\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {number | bigint} T\n * @param {Source<T>} source\n * @param {1 | -1} [d]\n * @returns {T}\n */\nexport function update(source, d = 1) {\n\tvar value = get(source);\n\tvar result = d === 1 ? value++ : value--;\n\n\tset(source, value);\n\n\t// @ts-expect-error\n\treturn result;\n}\n\n/**\n * @template {number | bigint} T\n * @param {Source<T>} source\n * @param {1 | -1} [d]\n * @returns {T}\n */\nexport function update_pre(source, d = 1) {\n\tvar value = get(source);\n\n\t// @ts-expect-error\n\treturn set(source, d === 1 ? ++value : --value);\n}\n\n/**\n * @param {Value} signal\n * @param {number} status should be DIRTY or MAYBE_DIRTY\n * @returns {void}\n */\nfunction mark_reactions(signal, status) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tvar flags = reaction.f;\n\n\t\t// Skip any effects that are already dirty\n\t\tif ((flags & DIRTY) !== 0) continue;\n\n\t\t// In legacy mode, skip the current effect to prevent infinite loops\n\t\tif (!runes && reaction === active_effect) continue;\n\n\t\t// Inspect effects need to run immediately, so that the stack trace makes sense\n\t\tif (DEV && (flags & INSPECT_EFFECT) !== 0) {\n\t\t\tinspect_effects.add(reaction);\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_signal_status(reaction, status);\n\n\t\t// If the signal a) was previously clean or b) is an unowned derived, then mark it\n\t\tif ((flags & (CLEAN | UNOWNED)) !== 0) {\n\t\t\tif ((flags & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(/** @type {Derived} */ (reaction), MAYBE_DIRTY);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {Effect} */ (reaction));\n\t\t\t}\n\t\t}\n\t}\n}\n","/** @import { ComponentContext, Derived, Effect, Reaction, Signal, Source, Value } from '#client' */\nimport { DEV } from 'esm-env';\nimport { define_property, get_descriptors, get_prototype_of, index_of } from '../shared/utils.js';\nimport {\n\tdestroy_block_effect_children,\n\tdestroy_effect_children,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED,\n\tBOUNDARY_EFFECT\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { internal_set } from './reactivity/sources.js';\nimport { destroy_derived_effects, update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { FILENAME } from '../../constants.js';\nimport { tracing_mode_flag } from '../flags/index.js';\nimport { tracing_expressions, get_stack } from './dev/tracing.js';\nimport {\n\tcomponent_context,\n\tdev_current_component_function,\n\tis_runes,\n\tset_component_context,\n\tset_dev_current_component_function\n} from './context.js';\nimport { is_firefox } from './dom/operations.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\nexport let is_throwing_error = false;\n\n// Used for controlling the flush of effects.\nlet scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\n\n/** @type {Effect | null} */\nlet last_scheduled_effect = null;\n\nexport let is_flushing_effect = false;\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_flushing_effect(value) {\n\tis_flushing_effect = value;\n}\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\n// Handle effect queues\n\n/** @type {Effect[]} */\nlet queued_root_effects = [];\n\nlet flush_count = 0;\n/** @type {Effect[]} Stack of effects, dev only */\nlet dev_effect_stack = [];\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | Reaction} */\nexport let active_reaction = null;\n\nexport let untracking = false;\n\n/** @param {null | Reaction} reaction */\nexport function set_active_reaction(reaction) {\n\tactive_reaction = reaction;\n}\n\n/** @type {null | Effect} */\nexport let active_effect = null;\n\n/** @param {null | Effect} effect */\nexport function set_active_effect(effect) {\n\tactive_effect = effect;\n}\n\n/**\n * When sources are created within a derived, we record them so that we can safely allow\n * local mutations to these sources without the side-effect error being invoked unnecessarily.\n * @type {null | Source[]}\n */\nexport let derived_sources = null;\n\n/**\n * @param {Source[] | null} sources\n */\nexport function set_derived_sources(sources) {\n\tderived_sources = sources;\n}\n\n/**\n * The dependencies of the reaction that is currently being executed. In many cases,\n * the dependencies are unchanged between runs, and so this will be `null` unless\n * and until a new dependency is accessed — we track this via `skipped_deps`\n * @type {null | Value[]}\n */\nexport let new_deps = null;\n\nlet skipped_deps = 0;\n\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | Source[]}\n */\nexport let untracked_writes = null;\n\n/** @param {null | Source[]} value */\nexport function set_untracked_writes(value) {\n\tuntracked_writes = value;\n}\n\n/**\n * @type {number} Used by sources and deriveds for handling updates.\n * Version starts from 1 so that unowned deriveds differentiate between a created effect and a run one for tracing\n **/\nlet write_version = 1;\n\n/** @type {number} Used to version each read of a source of derived to avoid duplicating depedencies inside a reaction */\nlet read_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\n/** @type {Set<Value> | null} */\nexport let captured_signals = null;\n\n/** @param {Set<Value> | null} value */\nexport function set_captured_signals(value) {\n\tcaptured_signals = value;\n}\n\nexport function increment_write_version() {\n\treturn ++write_version;\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\n\tif ((flags & DIRTY) !== 0) {\n\t\treturn true;\n\t}\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\t\tvar is_unowned = (flags & UNOWNED) !== 0;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar i;\n\t\t\tvar dependency;\n\t\t\tvar is_disconnected = (flags & DISCONNECTED) !== 0;\n\t\t\tvar is_unowned_connected = is_unowned && active_effect !== null && !skip_reaction;\n\t\t\tvar length = dependencies.length;\n\n\t\t\t// If we are working with a disconnected or an unowned signal that is now connected (due to an active effect)\n\t\t\t// then we need to re-connect the reaction to the dependency\n\t\t\tif (is_disconnected || is_unowned_connected) {\n\t\t\t\tvar derived = /** @type {Derived} */ (reaction);\n\t\t\t\tvar parent = derived.parent;\n\n\t\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\t\tdependency = dependencies[i];\n\n\t\t\t\t\t// We always re-add all reactions (even duplicates) if the derived was\n\t\t\t\t\t// previously disconnected, however we don't if it was unowned as we\n\t\t\t\t\t// de-duplicate dependencies in that case\n\t\t\t\t\tif (is_disconnected || !dependency?.reactions?.includes(derived)) {\n\t\t\t\t\t\t(dependency.reactions ??= []).push(derived);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (is_disconnected) {\n\t\t\t\t\tderived.f ^= DISCONNECTED;\n\t\t\t\t}\n\t\t\t\t// If the unowned derived is now fully connected to the graph again (it's unowned and reconnected, has a parent\n\t\t\t\t// and the parent is not unowned), then we can mark it as connected again, removing the need for the unowned\n\t\t\t\t// flag\n\t\t\t\tif (is_unowned_connected && parent !== null && (parent.f & UNOWNED) === 0) {\n\t\t\t\t\tderived.f ^= UNOWNED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < length; i++) {\n\t\t\t\tdependency = dependencies[i];\n\n\t\t\t\tif (check_dirtiness(/** @type {Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {Derived} */ (dependency));\n\t\t\t\t}\n\n\t\t\t\tif (dependency.wv > reaction.wv) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals should never be marked as clean unless they\n\t\t// are used within an active_effect without skip_reaction\n\t\tif (!is_unowned || (active_effect !== null && !skip_reaction)) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {unknown} error\n * @param {Effect} effect\n */\nfunction propagate_error(error, effect) {\n\t/** @type {Effect | null} */\n\tvar current = effect;\n\n\twhile (current !== null) {\n\t\tif ((current.f & BOUNDARY_EFFECT) !== 0) {\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tcurrent.fn(error);\n\t\t\t\treturn;\n\t\t\t} catch {\n\t\t\t\t// Remove boundary flag from effect\n\t\t\t\tcurrent.f ^= BOUNDARY_EFFECT;\n\t\t\t}\n\t\t}\n\n\t\tcurrent = current.parent;\n\t}\n\n\tis_throwing_error = false;\n\tthrow error;\n}\n\n/**\n * @param {Effect} effect\n */\nfunction should_rethrow_error(effect) {\n\treturn (\n\t\t(effect.f & DESTROYED) === 0 &&\n\t\t(effect.parent === null || (effect.parent.f & BOUNDARY_EFFECT) === 0)\n\t);\n}\n\nexport function reset_is_throwing_error() {\n\tis_throwing_error = false;\n}\n\n/**\n * @param {unknown} error\n * @param {Effect} effect\n * @param {Effect | null} previous_effect\n * @param {ComponentContext | null} component_context\n */\nexport function handle_error(error, effect, previous_effect, component_context) {\n\tif (is_throwing_error) {\n\t\tif (previous_effect === null) {\n\t\t\tis_throwing_error = false;\n\t\t}\n\n\t\tif (should_rethrow_error(effect)) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (previous_effect !== null) {\n\t\tis_throwing_error = true;\n\t}\n\n\tif (\n\t\t!DEV ||\n\t\tcomponent_context === null ||\n\t\t!(error instanceof Error) ||\n\t\thandled_errors.has(error)\n\t) {\n\t\tpropagate_error(error, effect);\n\t\treturn;\n\t}\n\n\thandled_errors.add(error);\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tif (DEV) {\n\t\t\t/** @type {string} */\n\t\t\tvar filename = current_context.function?.[FILENAME];\n\n\t\t\tif (filename) {\n\t\t\t\tconst file = filename.split('/').pop();\n\t\t\t\tcomponent_stack.push(file);\n\t\t\t}\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = is_firefox ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\tdefine_property(error, 'component_stack', {\n\t\tvalue: component_stack\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: new_lines.join('\\n')\n\t\t});\n\t}\n\n\tpropagate_error(error, effect);\n\n\tif (should_rethrow_error(effect)) {\n\t\tthrow error;\n\t}\n}\n\n/**\n * @param {Value} signal\n * @param {Effect} effect\n * @param {boolean} [root]\n */\nfunction schedule_possible_effect_self_invalidation(signal, effect, root = true) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tfor (var i = 0; i < reactions.length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tif ((reaction.f & DERIVED) !== 0) {\n\t\t\tschedule_possible_effect_self_invalidation(/** @type {Derived} */ (reaction), effect, false);\n\t\t} else if (effect === reaction) {\n\t\t\tif (root) {\n\t\t\t\tset_signal_status(reaction, DIRTY);\n\t\t\t} else if ((reaction.f & CLEAN) !== 0) {\n\t\t\t\tset_signal_status(reaction, MAYBE_DIRTY);\n\t\t\t}\n\t\t\tschedule_effect(/** @type {Effect} */ (reaction));\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {Reaction} reaction\n * @returns {V}\n */\nexport function update_reaction(reaction) {\n\tvar previous_deps = new_deps;\n\tvar previous_skipped_deps = skipped_deps;\n\tvar previous_untracked_writes = untracked_writes;\n\tvar previous_reaction = active_reaction;\n\tvar previous_skip_reaction = skip_reaction;\n\tvar prev_derived_sources = derived_sources;\n\tvar previous_component_context = component_context;\n\tvar previous_untracking = untracking;\n\tvar flags = reaction.f;\n\n\tnew_deps = /** @type {null | Value[]} */ (null);\n\tskipped_deps = 0;\n\tuntracked_writes = null;\n\tactive_reaction = (flags & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? reaction : null;\n\tskip_reaction =\n\t\t(flags & UNOWNED) !== 0 &&\n\t\t(!is_flushing_effect || previous_reaction === null || previous_untracking);\n\n\tderived_sources = null;\n\tset_component_context(reaction.ctx);\n\tuntracking = false;\n\tread_version++;\n\n\ttry {\n\t\tvar result = /** @type {Function} */ (0, reaction.fn)();\n\t\tvar deps = reaction.deps;\n\n\t\tif (new_deps !== null) {\n\t\t\tvar i;\n\n\t\t\tremove_reactions(reaction, skipped_deps);\n\n\t\t\tif (deps !== null && skipped_deps > 0) {\n\t\t\t\tdeps.length = skipped_deps + new_deps.length;\n\t\t\t\tfor (i = 0; i < new_deps.length; i++) {\n\t\t\t\t\tdeps[skipped_deps + i] = new_deps[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treaction.deps = deps = new_deps;\n\t\t\t}\n\n\t\t\tif (!skip_reaction) {\n\t\t\t\tfor (i = skipped_deps; i < deps.length; i++) {\n\t\t\t\t\t(deps[i].reactions ??= []).push(reaction);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (deps !== null && skipped_deps < deps.length) {\n\t\t\tremove_reactions(reaction, skipped_deps);\n\t\t\tdeps.length = skipped_deps;\n\t\t}\n\n\t\t// If we're inside an effect and we have untracked writes, then we need to\n\t\t// ensure that if any of those untracked writes result in re-invalidation\n\t\t// of the current effect, then that happens accordingly\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tuntracked_writes !== null &&\n\t\t\t!untracking &&\n\t\t\tdeps !== null &&\n\t\t\t(reaction.f & (DERIVED | MAYBE_DIRTY | DIRTY)) === 0\n\t\t) {\n\t\t\tfor (i = 0; i < /** @type {Source[]} */ (untracked_writes).length; i++) {\n\t\t\t\tschedule_possible_effect_self_invalidation(\n\t\t\t\t\tuntracked_writes[i],\n\t\t\t\t\t/** @type {Effect} */ (reaction)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\t// If we are returning to an previous reaction then\n\t\t// we need to increment the read version to ensure that\n\t\t// any dependencies in this reaction aren't marked with\n\t\t// the same version\n\t\tif (previous_reaction !== null) {\n\t\t\tread_version++;\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tnew_deps = previous_deps;\n\t\tskipped_deps = previous_skipped_deps;\n\t\tuntracked_writes = previous_untracked_writes;\n\t\tactive_reaction = previous_reaction;\n\t\tskip_reaction = previous_skip_reaction;\n\t\tderived_sources = prev_derived_sources;\n\t\tset_component_context(previous_component_context);\n\t\tuntracking = previous_untracking;\n\t}\n}\n\n/**\n * @template V\n * @param {Reaction} signal\n * @param {Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tlet reactions = dependency.reactions;\n\tif (reactions !== null) {\n\t\tvar index = index_of.call(reactions, signal);\n\t\tif (index !== -1) {\n\t\t\tvar new_length = reactions.length - 1;\n\t\t\tif (new_length === 0) {\n\t\t\t\treactions = dependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[new_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (\n\t\treactions === null &&\n\t\t(dependency.f & DERIVED) !== 0 &&\n\t\t// Destroying a child effect while updating a parent effect can cause a dependency to appear\n\t\t// to be unused, when in fact it is used by the currently-updating parent. Checking `new_deps`\n\t\t// allows us to skip the expensive work of disconnecting and immediately reconnecting it\n\t\t(new_deps === null || !new_deps.includes(dependency))\n\t) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\t// Disconnect any reactions owned by this reaction\n\t\tdestroy_derived_effects(/** @type {Derived} **/ (dependency));\n\t\tremove_reactions(/** @type {Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tvar dependencies = signal.deps;\n\tif (dependencies === null) return;\n\n\tfor (var i = start_index; i < dependencies.length; i++) {\n\t\tremove_reaction(signal, dependencies[i]);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @returns {void}\n */\nexport function update_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar previous_effect = active_effect;\n\tvar previous_component_context = component_context;\n\n\tactive_effect = effect;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tset_dev_current_component_function(effect.component_function);\n\t}\n\n\ttry {\n\t\tif ((flags & BLOCK_EFFECT) !== 0) {\n\t\t\tdestroy_block_effect_children(effect);\n\t\t} else {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = update_reaction(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t\teffect.wv = write_version;\n\n\t\tvar deps = effect.deps;\n\n\t\t// In DEV, we need to handle a case where $inspect.trace() might\n\t\t// incorrectly state a source dependency has not changed when it has.\n\t\t// That's beacuse that source was changed by the same effect, causing\n\t\t// the versions to match. We can avoid this by incrementing the version\n\t\tif (DEV && tracing_mode_flag && (effect.f & DIRTY) !== 0 && deps !== null) {\n\t\t\tfor (let i = 0; i < deps.length; i++) {\n\t\t\t\tvar dep = deps[i];\n\t\t\t\tif (dep.trace_need_increase) {\n\t\t\t\t\tdep.wv = increment_write_version();\n\t\t\t\t\tdep.trace_need_increase = undefined;\n\t\t\t\t\tdep.trace_v = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DEV) {\n\t\t\tdev_effect_stack.push(effect);\n\t\t}\n\t} catch (error) {\n\t\thandle_error(error, effect, previous_effect, previous_component_context || effect.ctx);\n\t} finally {\n\t\tactive_effect = previous_effect;\n\n\t\tif (DEV) {\n\t\t\tset_dev_current_component_function(previous_component_fn);\n\t\t}\n\t}\n}\n\nfunction log_effect_stack() {\n\t// eslint-disable-next-line no-console\n\tconsole.error(\n\t\t'Last ten effects were: ',\n\t\tdev_effect_stack.slice(-10).map((d) => d.fn)\n\t);\n\tdev_effect_stack = [];\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 1000) {\n\t\tflush_count = 0;\n\t\ttry {\n\t\t\te.effect_update_depth_exceeded();\n\t\t} catch (error) {\n\t\t\tif (DEV) {\n\t\t\t\t// stack is garbage, ignore. Instead add a console.error message.\n\t\t\t\tdefine_property(error, 'stack', {\n\t\t\t\t\tvalue: ''\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Try and handle the error so it can be caught at a boundary, that's\n\t\t\t// if there's an effect available from when it was last scheduled\n\t\t\tif (last_scheduled_effect !== null) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\thandle_error(error, last_scheduled_effect, null, null);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// Only log the effect stack if the error is re-thrown\n\t\t\t\t\t\tlog_effect_stack();\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thandle_error(error, last_scheduled_effect, null, null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (DEV) {\n\t\t\t\t\tlog_effect_stack();\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<Effect>} root_effects\n * @returns {void}\n */\nfunction flush_queued_root_effects(root_effects) {\n\tvar length = root_effects.length;\n\tif (length === 0) {\n\t\treturn;\n\t}\n\tinfinite_loop_guard();\n\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar effect = root_effects[i];\n\n\t\t\tif ((effect.f & CLEAN) === 0) {\n\t\t\t\teffect.f ^= CLEAN;\n\t\t\t}\n\n\t\t\tvar collected_effects = process_effects(effect);\n\t\t\tflush_queued_effects(collected_effects);\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n}\n\n/**\n * @param {Array<Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0) {\n\t\t\ttry {\n\t\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\t\tupdate_effect(effect);\n\n\t\t\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t\t\t// here (rather than in `update_effect`) allows us to skip the work for\n\t\t\t\t\t// immediate effects.\n\t\t\t\t\tif (effect.deps === null && effect.first === null && effect.nodes_start === null) {\n\t\t\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\t\t\teffect.fn = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\thandle_error(error, effect, null, effect.ctx);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_deferred() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tconst previous_queued_root_effects = queued_root_effects;\n\tqueued_root_effects = [];\n\tflush_queued_root_effects(previous_queued_root_effects);\n\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t\tlast_scheduled_effect = null;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (scheduler_mode === FLUSH_MICROTASK) {\n\t\tif (!is_micro_task_queued) {\n\t\t\tis_micro_task_queued = true;\n\t\t\tqueueMicrotask(process_deferred);\n\t\t}\n\t}\n\n\tlast_scheduled_effect = signal;\n\n\tvar effect = signal;\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & (ROOT_EFFECT | BRANCH_EFFECT)) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\teffect.f ^= CLEAN;\n\t\t}\n\t}\n\n\tqueued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {Effect} effect\n * @returns {Effect[]}\n */\nfunction process_effects(effect) {\n\t/** @type {Effect[]} */\n\tvar effects = [];\n\n\tvar current_effect = effect.first;\n\n\tmain_loop: while (current_effect !== null) {\n\t\tvar flags = current_effect.f;\n\t\tvar is_branch = (flags & BRANCH_EFFECT) !== 0;\n\t\tvar is_skippable_branch = is_branch && (flags & CLEAN) !== 0;\n\t\tvar sibling = current_effect.next;\n\n\t\tif (!is_skippable_branch && (flags & INERT) === 0) {\n\t\t\tif ((flags & EFFECT) !== 0) {\n\t\t\t\teffects.push(current_effect);\n\t\t\t} else if (is_branch) {\n\t\t\t\tcurrent_effect.f ^= CLEAN;\n\t\t\t} else {\n\t\t\t\t// Ensure we set the effect to be the active reaction\n\t\t\t\t// to ensure that unowned deriveds are correctly tracked\n\t\t\t\t// because we're flushing the current effect\n\t\t\t\tvar previous_active_reaction = active_reaction;\n\t\t\t\ttry {\n\t\t\t\t\tactive_reaction = current_effect;\n\t\t\t\t\tif (check_dirtiness(current_effect)) {\n\t\t\t\t\t\tupdate_effect(current_effect);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\thandle_error(error, current_effect, null, current_effect.ctx);\n\t\t\t\t} finally {\n\t\t\t\t\tactive_reaction = previous_active_reaction;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar child = current_effect.first;\n\n\t\t\tif (child !== null) {\n\t\t\t\tcurrent_effect = child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif (sibling === null) {\n\t\t\tlet parent = current_effect.parent;\n\n\t\t\twhile (parent !== null) {\n\t\t\t\tif (effect === parent) {\n\t\t\t\t\tbreak main_loop;\n\t\t\t\t}\n\t\t\t\tvar parent_sibling = parent.next;\n\t\t\t\tif (parent_sibling !== null) {\n\t\t\t\t\tcurrent_effect = parent_sibling;\n\t\t\t\t\tcontinue main_loop;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\tcurrent_effect = sibling;\n\t}\n\n\treturn effects;\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @returns {any}\n */\nexport function flush_sync(fn) {\n\tvar previous_scheduler_mode = scheduler_mode;\n\tvar previous_queued_root_effects = queued_root_effects;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\n\t\t/** @type {Effect[]} */\n\t\tconst root_effects = [];\n\n\t\tscheduler_mode = FLUSH_SYNC;\n\t\tqueued_root_effects = root_effects;\n\t\tis_micro_task_queued = false;\n\n\t\tflush_queued_root_effects(previous_queued_root_effects);\n\n\t\tvar result = fn?.();\n\n\t\tflush_tasks();\n\t\tif (queued_root_effects.length > 0 || root_effects.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\t\tlast_scheduled_effect = null;\n\t\tif (DEV) {\n\t\t\tdev_effect_stack = [];\n\t\t}\n\n\t\treturn result;\n\t} finally {\n\t\tscheduler_mode = previous_scheduler_mode;\n\t\tqueued_root_effects = previous_queued_root_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flush_sync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflush_sync();\n}\n\n/**\n * @template V\n * @param {Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tvar flags = signal.f;\n\tvar is_derived = (flags & DERIVED) !== 0;\n\n\tif (captured_signals !== null) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (active_reaction !== null && !untracking) {\n\t\tif (derived_sources !== null && derived_sources.includes(signal)) {\n\t\t\te.state_unsafe_local_read();\n\t\t}\n\t\tvar deps = active_reaction.deps;\n\t\tif (signal.rv < read_version) {\n\t\t\tsignal.rv = read_version;\n\t\t\t// If the signal is accessing the same dependencies in the same\n\t\t\t// order as it did last time, increment `skipped_deps`\n\t\t\t// rather than updating `new_deps`, which creates GC cost\n\t\t\tif (new_deps === null && deps !== null && deps[skipped_deps] === signal) {\n\t\t\t\tskipped_deps++;\n\t\t\t} else if (new_deps === null) {\n\t\t\t\tnew_deps = [signal];\n\t\t\t} else if (!skip_reaction || !new_deps.includes(signal)) {\n\t\t\t\t// Normally we can push duplicated dependencies to `new_deps`, but if we're inside\n\t\t\t\t// an unowned derived because skip_reaction is true, then we need to ensure that\n\t\t\t\t// we don't have duplicates\n\t\t\t\tnew_deps.push(signal);\n\t\t\t}\n\t\t}\n\t} else if (\n\t\tis_derived &&\n\t\t/** @type {Derived} */ (signal).deps === null &&\n\t\t/** @type {Derived} */ (signal).effects === null\n\t) {\n\t\tvar derived = /** @type {Derived} */ (signal);\n\t\tvar parent = derived.parent;\n\n\t\tif (parent !== null && (parent.f & UNOWNED) === 0) {\n\t\t\t// If the derived is owned by another derived then mark it as unowned\n\t\t\t// as the derived value might have been referenced in a different context\n\t\t\t// since and thus its parent might not be its true owner anymore\n\t\t\tderived.f ^= UNOWNED;\n\t\t}\n\t}\n\n\tif (is_derived) {\n\t\tderived = /** @type {Derived} */ (signal);\n\n\t\tif (check_dirtiness(derived)) {\n\t\t\tupdate_derived(derived);\n\t\t}\n\t}\n\n\tif (\n\t\tDEV &&\n\t\ttracing_mode_flag &&\n\t\ttracing_expressions !== null &&\n\t\tactive_reaction !== null &&\n\t\ttracing_expressions.reaction === active_reaction\n\t) {\n\t\t// Used when mapping state between special blocks like `each`\n\t\tif (signal.debug) {\n\t\t\tsignal.debug();\n\t\t} else if (signal.created) {\n\t\t\tvar entry = tracing_expressions.entries.get(signal);\n\n\t\t\tif (entry === undefined) {\n\t\t\t\tentry = { read: [] };\n\t\t\t\ttracing_expressions.entries.set(signal, entry);\n\t\t\t}\n\n\t\t\tentry.read.push(get_stack('TracedAt'));\n\t\t}\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Like `get`, but checks for `undefined`. Used for `var` declarations because they can be accessed before being declared\n * @template V\n * @param {Value<V> | undefined} signal\n * @returns {V | undefined}\n */\nexport function safe_get(signal) {\n\treturn signal && get(signal);\n}\n\n/**\n * Capture an array of all the signals that are read when `fn` is called\n * @template T\n * @param {() => T} fn\n */\nexport function capture_signals(fn) {\n\tvar previous_captured_signals = captured_signals;\n\tcaptured_signals = new Set();\n\n\tvar captured = captured_signals;\n\tvar signal;\n\n\ttry {\n\t\tuntrack(fn);\n\t\tif (previous_captured_signals !== null) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\n\treturn captured;\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar captured = capture_signals(() => untrack(fn));\n\n\tfor (var signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\t// Use internal_set instead of set here and below to avoid mutation validation\n\t\t\t\t\tinternal_set(dep, dep.v);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tinternal_set(signal, signal.v);\n\t\t}\n\t}\n}\n\n/**\n * When used inside a [`$derived`](https://svelte.dev/docs/svelte/$derived) or [`$effect`](https://svelte.dev/docs/svelte/$effect),\n * any state read inside `fn` will not be treated as a dependency.\n *\n * ```ts\n * $effect(() => {\n *   // this will run when `data` changes, but not when `time` changes\n *   save(data, {\n *     timestamp: untrack(() => time)\n *   });\n * });\n * ```\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tvar previous_untracking = untracking;\n\ttry {\n\t\tuntracking = true;\n\t\treturn fn();\n\t} finally {\n\t\tuntracking = previous_untracking;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\t/** @type {Record<string, unknown>} */\n\tvar result = {};\n\n\tfor (var key in obj) {\n\t\tif (!keys.includes(key)) {\n\t\t\tresult[key] = obj[key];\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible SvelteDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead\\nhttps://svelte.dev/e/bind_invalid_checkbox_value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/bind_invalid_checkbox_value`);\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)\\nhttps://svelte.dev/e/bind_invalid_export`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/bind_invalid_export`);\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\`\\nhttps://svelte.dev/e/bind_not_bindable`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/bind_not_bindable`);\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5\\nhttps://svelte.dev/e/component_api_changed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/component_api_changed`);\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `compatibility.componentApi` compiler option to `4` to keep it working.\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`compatibility.componentApi\\` compiler option to \\`4\\` to keep it working.\\nhttps://svelte.dev/e/component_api_invalid_new`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/component_api_invalid_new`);\n\t}\n}\n\n/**\n * A derived value cannot reference itself recursively\n * @returns {never}\n */\nexport function derived_references_self() {\n\tif (DEV) {\n\t\tconst error = new Error(`derived_references_self\\nA derived value cannot reference itself recursively\\nhttps://svelte.dev/e/derived_references_self`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/derived_references_self`);\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}\\nhttps://svelte.dev/e/each_key_duplicate`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/each_key_duplicate`);\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function\\nhttps://svelte.dev/e/effect_in_teardown`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_in_teardown`);\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect\\nhttps://svelte.dev/e/effect_in_unowned_derived`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_in_unowned_derived`);\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)\\nhttps://svelte.dev/e/effect_orphan`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_orphan`);\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\\nhttps://svelte.dev/e/effect_update_depth_exceeded`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/effect_update_depth_exceeded`);\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application\\nhttps://svelte.dev/e/hydration_failed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/hydration_failed`);\n\t}\n}\n\n/**\n * Could not `{@render}` snippet due to the expression being `null` or `undefined`. Consider using optional chaining `{@render snippet?.()}`\n * @returns {never}\n */\nexport function invalid_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_snippet\\nCould not \\`{@render}\\` snippet due to the expression being \\`null\\` or \\`undefined\\`. Consider using optional chaining \\`{@render snippet?.()}\\`\\nhttps://svelte.dev/e/invalid_snippet`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/invalid_snippet`);\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode\\nhttps://svelte.dev/e/lifecycle_legacy_only`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/lifecycle_legacy_only`);\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value\\nhttps://svelte.dev/e/props_invalid_value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/props_invalid_value`);\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly\\nhttps://svelte.dev/e/props_rest_readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/props_rest_readonly`);\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files\\nhttps://svelte.dev/e/rune_outside_svelte`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/rune_outside_svelte`);\n\t}\n}\n\n/**\n * Property descriptors defined on `$state` objects must contain `value` and always be `enumerable`, `configurable` and `writable`.\n * @returns {never}\n */\nexport function state_descriptors_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_descriptors_fixed\\nProperty descriptors defined on \\`$state\\` objects must contain \\`value\\` and always be \\`enumerable\\`, \\`configurable\\` and \\`writable\\`.\\nhttps://svelte.dev/e/state_descriptors_fixed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/state_descriptors_fixed`);\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object\\nhttps://svelte.dev/e/state_prototype_fixed`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/state_prototype_fixed`);\n\t}\n}\n\n/**\n * Reading state that was created inside the same derived is forbidden. Consider using `untrack` to read locally created state\n * @returns {never}\n */\nexport function state_unsafe_local_read() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_local_read\\nReading state that was created inside the same derived is forbidden. Consider using \\`untrack\\` to read locally created state\\nhttps://svelte.dev/e/state_unsafe_local_read`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/state_unsafe_local_read`);\n\t}\n}\n\n/**\n * Updating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived or a template expression is forbidden. If the value should not be reactive, declare it without \\`$state\\`\\nhttps://svelte.dev/e/state_unsafe_mutation`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/state_unsafe_mutation`);\n\t}\n}","/** @import { Derived, Effect } from '#client' */\nimport { DEV } from 'esm-env';\nimport { CLEAN, DERIVED, DIRTY, EFFECT_HAS_DERIVED, MAYBE_DIRTY, UNOWNED } from '../constants.js';\nimport {\n\tactive_reaction,\n\tactive_effect,\n\tset_signal_status,\n\tskip_reaction,\n\tupdate_reaction,\n\tincrement_write_version,\n\tset_active_effect\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport { destroy_effect } from './effects.js';\nimport { inspect_effects, set_inspect_effects } from './sources.js';\nimport { get_stack } from '../dev/tracing.js';\nimport { tracing_mode_flag } from '../../flags/index.js';\nimport { component_context } from '../context.js';\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tvar flags = DERIVED | DIRTY;\n\tvar parent_derived =\n\t\tactive_reaction !== null && (active_reaction.f & DERIVED) !== 0\n\t\t\t? /** @type {Derived} */ (active_reaction)\n\t\t\t: null;\n\n\tif (active_effect === null || (parent_derived !== null && (parent_derived.f & UNOWNED) !== 0)) {\n\t\tflags |= UNOWNED;\n\t} else {\n\t\t// Since deriveds are evaluated lazily, any effects created inside them are\n\t\t// created too late to ensure that the parent effect is added to the tree\n\t\tactive_effect.f |= EFFECT_HAS_DERIVED;\n\t}\n\n\t/** @type {Derived<V>} */\n\tconst signal = {\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\teffects: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfn,\n\t\treactions: null,\n\t\trv: 0,\n\t\tv: /** @type {V} */ (null),\n\t\twv: 0,\n\t\tparent: parent_derived ?? active_effect\n\t};\n\n\tif (DEV && tracing_mode_flag) {\n\t\tsignal.created = get_stack('CreatedAt');\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nexport function destroy_derived_effects(derived) {\n\tvar effects = derived.effects;\n\n\tif (effects !== null) {\n\t\tderived.effects = null;\n\n\t\tfor (var i = 0; i < effects.length; i += 1) {\n\t\t\tdestroy_effect(/** @type {Effect} */ (effects[i]));\n\t\t}\n\t}\n}\n\n/**\n * The currently updating deriveds, used to detect infinite recursion\n * in dev mode and provide a nicer error than 'too much recursion'\n * @type {Derived[]}\n */\nlet stack = [];\n\n/**\n * @param {Derived} derived\n * @returns {Effect | null}\n */\nfunction get_derived_parent_effect(derived) {\n\tvar parent = derived.parent;\n\twhile (parent !== null) {\n\t\tif ((parent.f & DERIVED) === 0) {\n\t\t\treturn /** @type {Effect} */ (parent);\n\t\t}\n\t\tparent = parent.parent;\n\t}\n\treturn null;\n}\n\n/**\n * @template T\n * @param {Derived} derived\n * @returns {T}\n */\nexport function execute_derived(derived) {\n\tvar value;\n\tvar prev_active_effect = active_effect;\n\n\tset_active_effect(get_derived_parent_effect(derived));\n\n\tif (DEV) {\n\t\tlet prev_inspect_effects = inspect_effects;\n\t\tset_inspect_effects(new Set());\n\t\ttry {\n\t\t\tif (stack.includes(derived)) {\n\t\t\t\te.derived_references_self();\n\t\t\t}\n\n\t\t\tstack.push(derived);\n\n\t\t\tdestroy_derived_effects(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t\tset_inspect_effects(prev_inspect_effects);\n\t\t\tstack.pop();\n\t\t}\n\t} else {\n\t\ttry {\n\t\t\tdestroy_derived_effects(derived);\n\t\t\tvalue = update_reaction(derived);\n\t\t} finally {\n\t\t\tset_active_effect(prev_active_effect);\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar value = execute_derived(derived);\n\tvar status =\n\t\t(skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null ? MAYBE_DIRTY : CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.wv = increment_write_version();\n\t}\n}\n","/** @import { TemplateNode } from '#client' */\n\nimport {\n\tHYDRATION_END,\n\tHYDRATION_ERROR,\n\tHYDRATION_START,\n\tHYDRATION_START_ELSE\n} from '../../../constants.js';\nimport * as w from '../warnings.js';\nimport { get_next_sibling } from './operations.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * The node that is currently being hydrated. This starts out as the first node inside the opening\n * <!--[--> comment, and updates each time a component calls `$.child(...)` or `$.sibling(...)`.\n * When entering a block (e.g. `{#if ...}`), `hydrate_node` is the block opening comment; by the\n * time we leave the block it is the closing comment, which serves as the block's anchor.\n * @type {TemplateNode}\n */\nexport let hydrate_node;\n\n/** @param {TemplateNode} node */\nexport function set_hydrate_node(node) {\n\tif (node === null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\treturn (hydrate_node = node);\n}\n\nexport function hydrate_next() {\n\treturn set_hydrate_node(/** @type {TemplateNode} */ (get_next_sibling(hydrate_node)));\n}\n\n/** @param {TemplateNode} node */\nexport function reset(node) {\n\tif (!hydrating) return;\n\n\t// If the node has remaining siblings, something has gone wrong\n\tif (get_next_sibling(hydrate_node) !== null) {\n\t\tw.hydration_mismatch();\n\t\tthrow HYDRATION_ERROR;\n\t}\n\n\thydrate_node = node;\n}\n\n/**\n * @param {HTMLTemplateElement} template\n */\nexport function hydrate_template(template) {\n\tif (hydrating) {\n\t\t// @ts-expect-error TemplateNode doesn't include DocumentFragment, but it's actually fine\n\t\thydrate_node = template.content;\n\t}\n}\n\nexport function next(count = 1) {\n\tif (hydrating) {\n\t\tvar i = count;\n\t\tvar node = hydrate_node;\n\n\t\twhile (i--) {\n\t\t\tnode = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\t}\n\n\t\thydrate_node = node;\n\t}\n}\n\n/**\n * Removes all nodes starting at `hydrate_node` up until the next hydration end comment\n */\nexport function remove_nodes() {\n\tvar depth = 0;\n\tvar node = hydrate_node;\n\n\twhile (true) {\n\t\tif (node.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (node).data;\n\n\t\t\tif (data === HYDRATION_END) {\n\t\t\t\tif (depth === 0) return node;\n\t\t\t\tdepth -= 1;\n\t\t\t} else if (data === HYDRATION_START || data === HYDRATION_START_ELSE) {\n\t\t\t\tdepth += 1;\n\t\t\t}\n\t\t}\n\n\t\tvar next = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tnode.remove();\n\t\tnode = next;\n\t}\n}\n","/** @import { TemplateNode } from '#client' */\nimport { hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\nimport { get_descriptor } from '../../shared/utils.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/** @type {boolean} */\nexport var is_firefox;\n\n/** @type {() => Node | null} */\nvar first_child_getter;\n/** @type {() => Node | null} */\nvar next_sibling_getter;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\tis_firefox = /Firefox/.test(navigator.userAgent);\n\n\tvar element_prototype = Element.prototype;\n\tvar node_prototype = Node.prototype;\n\n\t// @ts-ignore\n\tfirst_child_getter = get_descriptor(node_prototype, 'firstChild').get;\n\t// @ts-ignore\n\tnext_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\t// @ts-expect-error\n\telement_prototype.__attributes = null;\n\t// @ts-expect-error\n\telement_prototype.__styles = null;\n\t// @ts-expect-error\n\telement_prototype.__e = undefined;\n\n\t// @ts-expect-error\n\tText.prototype.__t = undefined;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/**\n * @param {string} value\n * @returns {Text}\n */\nexport function create_text(value = '') {\n\treturn document.createTextNode(value);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_first_child(node) {\n\treturn first_child_getter.call(node);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function get_next_sibling(node) {\n\treturn next_sibling_getter.call(node);\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function child(node, is_text) {\n\tif (!hydrating) {\n\t\treturn get_first_child(node);\n\t}\n\n\tvar child = /** @type {TemplateNode} */ (get_first_child(hydrate_node));\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\tchild = hydrate_node.appendChild(create_text());\n\t} else if (is_text && child.nodeType !== 3) {\n\t\tvar text = create_text();\n\t\tchild?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(child);\n\treturn child;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {DocumentFragment | TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\tvar first = /** @type {DocumentFragment} */ (get_first_child(/** @type {Node} */ (fragment)));\n\n\t\t// TODO prevent user comments with the empty string when preserveComments is true\n\t\tif (first instanceof Comment && first.data === '') return get_next_sibling(first);\n\n\t\treturn first;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && hydrate_node?.nodeType !== 3) {\n\t\tvar text = create_text();\n\n\t\thydrate_node?.before(text);\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\treturn hydrate_node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {TemplateNode} node\n * @param {number} count\n * @param {boolean} is_text\n * @returns {Node | null}\n */\nexport function sibling(node, count = 1, is_text = false) {\n\tlet next_sibling = hydrating ? hydrate_node : node;\n\tvar last_sibling;\n\n\twhile (count--) {\n\t\tlast_sibling = next_sibling;\n\t\tnext_sibling = /** @type {TemplateNode} */ (get_next_sibling(next_sibling));\n\t}\n\n\tif (!hydrating) {\n\t\treturn next_sibling;\n\t}\n\n\tvar type = next_sibling?.nodeType;\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate — we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = create_text();\n\t\t// If the next sibling is `null` and we're handling text then it's because\n\t\t// the SSR content was empty for the text, so we need to generate a new text\n\t\t// node and insert it after the last sibling\n\t\tif (next_sibling === null) {\n\t\t\tlast_sibling?.after(text);\n\t\t} else {\n\t\t\tnext_sibling.before(text);\n\t\t}\n\t\tset_hydrate_node(text);\n\t\treturn text;\n\t}\n\n\tset_hydrate_node(next_sibling);\n\treturn /** @type {TemplateNode} */ (next_sibling);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n","/** @import { ProxyMetadata, Source } from '#client' */\nimport { DEV } from 'esm-env';\nimport { get, active_effect } from './runtime.js';\nimport { component_context } from './context.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype\n} from '../shared/utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { source, set } from './reactivity/sources.js';\nimport { STATE_SYMBOL, STATE_SYMBOL_METADATA } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\nimport { get_stack } from './dev/tracing.js';\nimport { tracing_mode_flag } from '../flags/index.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {ProxyMetadata | null} [parent]\n * @param {Source<T>} [prev] dev mode only\n * @returns {T}\n */\nexport function proxy(value, parent = null, prev) {\n\t/** @type {Error | null} */\n\tvar stack = null;\n\tif (DEV && tracing_mode_flag) {\n\t\tstack = get_stack('CreatedAt');\n\t}\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (typeof value !== 'object' || value === null || STATE_SYMBOL in value) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any, Source<any>>} */\n\tvar sources = new Map();\n\tvar is_proxied_array = is_array(value);\n\tvar version = source(0);\n\n\tif (is_proxied_array) {\n\t\t// We need to create the length source eagerly to ensure that\n\t\t// mutations to the array are properly synced with our proxy\n\t\tsources.set('length', source(/** @type {any[]} */ (value).length, stack));\n\t}\n\n\t/** @type {ProxyMetadata} */\n\tvar metadata;\n\n\tif (DEV) {\n\t\tmetadata = {\n\t\t\tparent,\n\t\t\towners: null\n\t\t};\n\n\t\tif (prev) {\n\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t// @ts-expect-error\n\t\t\tconst prev_owners = prev.v?.[STATE_SYMBOL_METADATA]?.owners;\n\t\t\tmetadata.owners = prev_owners ? new Set(prev_owners) : null;\n\t\t} else {\n\t\t\tmetadata.owners =\n\t\t\t\tparent === null\n\t\t\t\t\t? component_context !== null\n\t\t\t\t\t\t? new Set([component_context.function])\n\t\t\t\t\t\t: null\n\t\t\t\t\t: new Set();\n\t\t}\n\t}\n\n\treturn new Proxy(/** @type {any} */ (value), {\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object — which we avoid, so that state can be forked — we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\te.state_descriptors_fixed();\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\ts = source(descriptor.value, stack);\n\t\t\t\tsources.set(prop, s);\n\t\t\t} else {\n\t\t\t\tset(s, proxy(descriptor.value, metadata));\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar s = sources.get(prop);\n\n\t\t\tif (s === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tsources.set(prop, source(UNINITIALIZED, stack));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// When working with arrays, we need to also ensure we update the length when removing\n\t\t\t\t// an indexed property\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n < ls.v) {\n\t\t\t\t\t\tset(ls, n);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset(s, UNINITIALIZED);\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tget(target, prop, receiver) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn metadata;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\t// create a source, but only if it's an own property and not a prototype property\n\t\t\tif (s === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\ts = source(proxy(exists ? target[prop] : UNINITIALIZED, metadata), stack);\n\t\t\t\tsources.set(prop, s);\n\t\t\t}\n\n\t\t\tif (s !== undefined) {\n\t\t\t\tvar v = get(s);\n\n\t\t\t\t// In case of something like `foo = bar.map(...)`, foo would have ownership\n\t\t\t\t// of the array itself, while the individual items would have ownership\n\t\t\t\t// of the component that created bar. That means if we later do `foo[0].baz = 42`,\n\t\t\t\t// we could get a false-positive ownership violation, since the two proxies\n\t\t\t\t// are not connected to each other via the parent metadata relationship.\n\t\t\t\t// For this reason, we need to widen the ownership of the children\n\t\t\t\t// upon access when we detect they are not connected.\n\t\t\t\tif (DEV) {\n\t\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\t\tvar prop_metadata = v?.[STATE_SYMBOL_METADATA];\n\t\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\treturn Reflect.get(target, prop, receiver);\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar s = sources.get(prop);\n\t\t\t\tif (s) descriptor.value = get(s);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar source = sources.get(prop);\n\t\t\t\tvar value = source?.v;\n\n\t\t\t\tif (source !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (DEV && prop === STATE_SYMBOL_METADATA) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === STATE_SYMBOL) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = (s !== undefined && s.v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (\n\t\t\t\ts !== undefined ||\n\t\t\t\t(active_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t\t) {\n\t\t\t\tif (s === undefined) {\n\t\t\t\t\ts = source(has ? proxy(target[prop], metadata) : UNINITIALIZED, stack);\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(s);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn has;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar s = sources.get(prop);\n\t\t\tvar has = prop in target;\n\n\t\t\t// variable.length = value -> clear all signals with index >= value\n\t\t\tif (is_proxied_array && prop === 'length') {\n\t\t\t\tfor (var i = value; i < /** @type {Source<number>} */ (s).v; i += 1) {\n\t\t\t\t\tvar other_s = sources.get(i + '');\n\t\t\t\t\tif (other_s !== undefined) {\n\t\t\t\t\t\tset(other_s, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized source,\n\t\t\t\t\t\t// else a later read of the property would result in a source being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_s = source(UNINITIALIZED, stack);\n\t\t\t\t\t\tsources.set(i + '', other_s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (s === undefined) {\n\t\t\t\tif (!has || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\ts = source(undefined, stack);\n\t\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t\t\tsources.set(prop, s);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thas = s.v !== UNINITIALIZED;\n\t\t\t\tset(s, proxy(value, metadata));\n\t\t\t}\n\n\t\t\tif (DEV) {\n\t\t\t\t/** @type {ProxyMetadata | undefined} */\n\t\t\t\tvar prop_metadata = value?.[STATE_SYMBOL_METADATA];\n\t\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t\t}\n\t\t\t\tcheck_ownership(metadata);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!has) {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tif (is_proxied_array && typeof prop === 'string') {\n\t\t\t\t\tvar ls = /** @type {Source<number>} */ (sources.get('length'));\n\t\t\t\t\tvar n = Number(prop);\n\n\t\t\t\t\tif (Number.isInteger(n) && n >= ls.v) {\n\t\t\t\t\t\tset(ls, n + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tupdate_version(version);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tget(version);\n\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar source = sources.get(key);\n\t\t\t\treturn source === undefined || source.v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, source] of sources) {\n\t\t\t\tif (source.v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\te.state_prototype_fixed();\n\t\t}\n\t});\n}\n\n/**\n * @param {Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\treturn value[STATE_SYMBOL];\n\t}\n\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","/** @import { ComponentContext, ComponentContextLegacy, Derived, Effect, TemplateNode, TransitionManager } from '#client' */\nimport {\n\tcheck_dirtiness,\n\tactive_effect,\n\tactive_reaction,\n\tupdate_effect,\n\tget,\n\tis_destroying_effect,\n\tis_flushing_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_active_reaction,\n\tset_is_destroying_effect,\n\tset_is_flushing_effect,\n\tset_signal_status,\n\tuntrack,\n\tskip_reaction,\n\tuntracking\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT,\n\tHEAD_EFFECT,\n\tMAYBE_DIRTY,\n\tEFFECT_HAS_DERIVED,\n\tBOUNDARY_EFFECT\n} from '../constants.js';\nimport { set } from './sources.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../../shared/utils.js';\nimport { get_next_sibling } from '../dom/operations.js';\nimport { derived } from './deriveds.js';\nimport { component_context, dev_current_component_function } from '../context.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (active_effect === null && active_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (active_reaction !== null && (active_reaction.f & UNOWNED) !== 0 && active_effect === null) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect} parent_effect\n */\nfunction push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @param {boolean} push\n * @returns {Effect}\n */\nfunction create_effect(type, fn, sync, push = true) {\n\tvar is_root = (type & ROOT_EFFECT) !== 0;\n\tvar parent_effect = active_effect;\n\n\tif (DEV) {\n\t\t// Ensure the parent is never an inspect effect\n\t\twhile (parent_effect !== null && (parent_effect.f & INSPECT_EFFECT) !== 0) {\n\t\t\tparent_effect = parent_effect.parent;\n\t\t}\n\t}\n\n\t/** @type {Effect} */\n\tvar effect = {\n\t\tctx: component_context,\n\t\tdeps: null,\n\t\tnodes_start: null,\n\t\tnodes_end: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent: is_root ? null : parent_effect,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null,\n\t\twv: 0\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\tvar previously_flushing_effect = is_flushing_effect;\n\n\t\ttry {\n\t\t\tset_is_flushing_effect(true);\n\t\t\tupdate_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} catch (e) {\n\t\t\tdestroy_effect(effect);\n\t\t\tthrow e;\n\t\t} finally {\n\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.nodes_start === null &&\n\t\teffect.teardown === null &&\n\t\t(effect.f & (EFFECT_HAS_DERIVED | BOUNDARY_EFFECT)) === 0;\n\n\tif (!inert && !is_root && push) {\n\t\tif (parent_effect !== null) {\n\t\t\tpush_effect(effect, parent_effect);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\t\tvar derived = /** @type {Derived} */ (active_reaction);\n\t\t\t(derived.effects ??= []).push(effect);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\treturn active_reaction !== null && !untracking;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tactive_effect !== null &&\n\t\t(active_effect.f & BRANCH_EFFECT) !== 0 &&\n\t\tcomponent_context !== null &&\n\t\t!component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {ComponentContext} */ (component_context);\n\t\t(context.e ??= []).push({\n\t\t\tfn,\n\t\t\teffect: active_effect,\n\t\t\treaction: active_reaction\n\t\t});\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * An effect root whose children can transition out\n * @param {() => void} fn\n * @returns {(options?: { outro?: boolean }) => Promise<void>}\n */\nexport function component_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\n\treturn (options = {}) => {\n\t\treturn new Promise((fulfil) => {\n\t\t\tif (options.outro) {\n\t\t\t\tpause_effect(effect, () => {\n\t\t\t\t\tdestroy_effect(effect);\n\t\t\t\t\tfulfil(undefined);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdestroy_effect(effect);\n\t\t\t\tfulfil(undefined);\n\t\t\t}\n\t\t});\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\t/** @type {{ effect: null | Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\t// If the effect is CLEAN, then make it MAYBE_DIRTY. This ensures we traverse through\n\t\t\t// the effects dependencies and correctly ensure each dependency is up-to-date.\n\t\t\tif ((effect.f & CLEAN) !== 0) {\n\t\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t\t}\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\tupdate_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {(...expressions: any) => void | (() => void)} fn\n * @param {Array<() => any>} thunks\n * @returns {Effect}\n */\nexport function template_effect(fn, thunks = [], d = derived) {\n\tconst deriveds = thunks.map(d);\n\tconst effect = () => fn(...deriveds.map(get));\n\n\tif (DEV) {\n\t\tdefine_property(effect, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\n\treturn block(effect);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {boolean} [push]\n */\nexport function branch(fn, push = true) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true, push);\n}\n\n/**\n * @param {Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = active_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_active_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_active_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @param {boolean} remove_dom\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = false) {\n\tvar effect = signal.first;\n\tsignal.first = signal.last = null;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tdestroy_effect(effect, remove_dom);\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} signal\n * @returns {void}\n */\nexport function destroy_block_effect_children(signal) {\n\tvar effect = signal.first;\n\n\twhile (effect !== null) {\n\t\tvar next = effect.next;\n\t\tif ((effect.f & BRANCH_EFFECT) === 0) {\n\t\t\tdestroy_effect(effect);\n\t\t}\n\t\teffect = next;\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar removed = false;\n\n\tif ((remove_dom || (effect.f & HEAD_EFFECT) !== 0) && effect.nodes_start !== null) {\n\t\t/** @type {TemplateNode | null} */\n\t\tvar node = effect.nodes_start;\n\t\tvar end = effect.nodes_end;\n\n\t\twhile (node !== null) {\n\t\t\t/** @type {TemplateNode | null} */\n\t\t\tvar next = node === end ? null : /** @type {TemplateNode} */ (get_next_sibling(node));\n\n\t\t\tnode.remove();\n\t\t\tnode = next;\n\t\t}\n\n\t\tremoved = true;\n\t}\n\n\tdestroy_effect_children(effect, remove_dom && !removed);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tvar transitions = effect.transitions;\n\n\tif (transitions !== null) {\n\t\tfor (const transition of transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\tif (DEV) {\n\t\teffect.component_function = null;\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\t// we don't null out `parent` so that error propagation can work correctly\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.deps =\n\t\teffect.fn =\n\t\teffect.nodes_start =\n\t\teffect.nodes_end =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {Effect} effect\n * @param {TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\teffect.f ^= INERT;\n\n\t// Ensure the effect is marked as clean again so that any dirty child\n\t// effects can schedule themselves for execution\n\tif ((effect.f & CLEAN) === 0) {\n\t\teffect.f ^= CLEAN;\n\t}\n\n\t// If a dependency of this effect changed while it was paused,\n\t// schedule the effect to update\n\tif (check_dirtiness(effect)) {\n\t\tset_signal_status(effect, DIRTY);\n\t\tschedule_effect(effect);\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Cannot use `{@render children(...)}` if the parent component uses `let:` directives. Consider using a named snippet instead\n * @returns {never}\n */\nexport function invalid_default_snippet() {\n\tif (DEV) {\n\t\tconst error = new Error(`invalid_default_snippet\\nCannot use \\`{@render children(...)}\\` if the parent component uses \\`let:\\` directives. Consider using a named snippet instead\\nhttps://svelte.dev/e/invalid_default_snippet`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/invalid_default_snippet`);\n\t}\n}\n\n/**\n * `%name%(...)` can only be used during component initialisation\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_outside_component(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_outside_component\\n\\`${name}(...)\\` can only be used during component initialisation\\nhttps://svelte.dev/e/lifecycle_outside_component`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/lifecycle_outside_component`);\n\t}\n}\n\n/**\n * `%name%` is not a store with a `subscribe` method\n * @param {string} name\n * @returns {never}\n */\nexport function store_invalid_shape(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`store_invalid_shape\\n\\`${name}\\` is not a store with a \\`subscribe\\` method\\nhttps://svelte.dev/e/store_invalid_shape`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/store_invalid_shape`);\n\t}\n}\n\n/**\n * The `this` prop on `<svelte:element>` must be a string, if defined\n * @returns {never}\n */\nexport function svelte_element_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_element_invalid_this_value\\nThe \\`this\\` prop on \\`<svelte:element>\\` must be a string, if defined\\nhttps://svelte.dev/e/svelte_element_invalid_this_value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\tthrow new Error(`https://svelte.dev/e/svelte_element_invalid_this_value`);\n\t}\n}","/** @import { ComponentContext } from '#client' */\n\nimport { DEV } from 'esm-env';\nimport { add_owner } from './dev/ownership.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\nimport { source } from './reactivity/sources.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction,\n\tuntrack\n} from './runtime.js';\nimport { effect } from './reactivity/effects.js';\nimport { legacy_mode_flag } from '../flags/index.js';\n\n/** @type {ComponentContext | null} */\nexport let component_context = null;\n\n/** @param {ComponentContext | null} context */\nexport function set_component_context(context) {\n\tcomponent_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\n\tif (DEV) {\n\t\t// When state is put into context, we treat as if it's global from now on.\n\t\t// We do for performance reasons (it's for example very expensive to call\n\t\t// getContext on a big object many times when part of a list component)\n\t\t// and danger of false positives.\n\t\tuntrack(() => add_owner(context, null, true));\n\t}\n\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcomponent_context = {\n\t\tp: component_context,\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t};\n\n\tif (legacy_mode_flag && !runes) {\n\t\tcomponent_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tif (DEV) {\n\t\t// component function\n\t\tcomponent_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst component_effects = context_stack_item.e;\n\t\tif (component_effects !== null) {\n\t\t\tvar previous_effect = active_effect;\n\t\t\tvar previous_reaction = active_reaction;\n\t\t\tcontext_stack_item.e = null;\n\t\t\ttry {\n\t\t\t\tfor (var i = 0; i < component_effects.length; i++) {\n\t\t\t\t\tvar component_effect = component_effects[i];\n\t\t\t\t\tset_active_effect(component_effect.effect);\n\t\t\t\t\tset_active_reaction(component_effect.reaction);\n\t\t\t\t\teffect(component_effect.fn);\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tset_active_effect(previous_effect);\n\t\t\t\tset_active_reaction(previous_reaction);\n\t\t\t}\n\t\t}\n\t\tcomponent_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn !legacy_mode_flag || (component_context !== null && component_context.l === null);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (component_context.c ??= new Map(get_parent_context(component_context) || undefined));\n}\n\n/**\n * @param {ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n","const regex_return_characters = /\\r/g;\n\n/**\n * @param {string} str\n * @returns {string}\n */\nexport function hash(str) {\n\tstr = str.replace(regex_return_characters, '');\n\tlet hash = 5381;\n\tlet i = str.length;\n\n\twhile (i--) hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n\treturn (hash >>> 0).toString(36);\n}\n\nconst VOID_ELEMENT_NAMES = [\n\t'area',\n\t'base',\n\t'br',\n\t'col',\n\t'command',\n\t'embed',\n\t'hr',\n\t'img',\n\t'input',\n\t'keygen',\n\t'link',\n\t'meta',\n\t'param',\n\t'source',\n\t'track',\n\t'wbr'\n];\n\n/**\n * Returns `true` if `name` is of a void element\n * @param {string} name\n */\nexport function is_void(name) {\n\treturn VOID_ELEMENT_NAMES.includes(name) || name.toLowerCase() === '!doctype';\n}\n\nconst RESERVED_WORDS = [\n\t'arguments',\n\t'await',\n\t'break',\n\t'case',\n\t'catch',\n\t'class',\n\t'const',\n\t'continue',\n\t'debugger',\n\t'default',\n\t'delete',\n\t'do',\n\t'else',\n\t'enum',\n\t'eval',\n\t'export',\n\t'extends',\n\t'false',\n\t'finally',\n\t'for',\n\t'function',\n\t'if',\n\t'implements',\n\t'import',\n\t'in',\n\t'instanceof',\n\t'interface',\n\t'let',\n\t'new',\n\t'null',\n\t'package',\n\t'private',\n\t'protected',\n\t'public',\n\t'return',\n\t'static',\n\t'super',\n\t'switch',\n\t'this',\n\t'throw',\n\t'true',\n\t'try',\n\t'typeof',\n\t'var',\n\t'void',\n\t'while',\n\t'with',\n\t'yield'\n];\n\n/**\n * Returns `true` if `word` is a reserved JavaScript keyword\n * @param {string} word\n */\nexport function is_reserved(word) {\n\treturn RESERVED_WORDS.includes(word);\n}\n\n/**\n * @param {string} name\n */\nexport function is_capture_event(name) {\n\treturn name.endsWith('capture') && name !== 'gotpointercapture' && name !== 'lostpointercapture';\n}\n\n/** List of Element events that will be delegated */\nconst DELEGATED_EVENTS = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/**\n * Returns `true` if `event_name` is a delegated event\n * @param {string} event_name\n */\nexport function is_delegated(event_name) {\n\treturn DELEGATED_EVENTS.includes(event_name);\n}\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nconst DOM_BOOLEAN_ATTRIBUTES = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'inert',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory',\n\t'defer',\n\t'disablepictureinpicture',\n\t'disableremoteplayback'\n];\n\n/**\n * Returns `true` if `name` is a boolean attribute\n * @param {string} name\n */\nexport function is_boolean_attribute(name) {\n\treturn DOM_BOOLEAN_ATTRIBUTES.includes(name);\n}\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nconst ATTRIBUTE_ALIASES = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly',\n\tdefaultvalue: 'defaultValue',\n\tdefaultchecked: 'defaultChecked',\n\tsrcobject: 'srcObject',\n\tnovalidate: 'noValidate',\n\tallowfullscreen: 'allowFullscreen',\n\tdisablepictureinpicture: 'disablePictureInPicture',\n\tdisableremoteplayback: 'disableRemotePlayback'\n};\n\n/**\n * @param {string} name\n */\nexport function normalize_attribute(name) {\n\tname = name.toLowerCase();\n\treturn ATTRIBUTE_ALIASES[name] ?? name;\n}\n\nconst DOM_PROPERTIES = [\n\t...DOM_BOOLEAN_ATTRIBUTES,\n\t'formNoValidate',\n\t'isMap',\n\t'noModule',\n\t'playsInline',\n\t'readOnly',\n\t'value',\n\t'volume',\n\t'defaultValue',\n\t'defaultChecked',\n\t'srcObject',\n\t'noValidate',\n\t'allowFullscreen',\n\t'disablePictureInPicture',\n\t'disableRemotePlayback'\n];\n\n/**\n * @param {string} name\n */\nexport function is_dom_property(name) {\n\treturn DOM_PROPERTIES.includes(name);\n}\n\nconst NON_STATIC_PROPERTIES = ['autofocus', 'muted', 'defaultValue', 'defaultChecked'];\n\n/**\n * Returns `true` if the given attribute cannot be set through the template\n * string, i.e. needs some kind of JavaScript handling to work.\n * @param {string} name\n */\nexport function cannot_be_set_statically(name) {\n\treturn NON_STATIC_PROPERTIES.includes(name);\n}\n\n/**\n * Subset of delegated events which should be passive by default.\n * These two are already passive via browser defaults on window, document and body.\n * But since\n * - we're delegating them\n * - they happen often\n * - they apply to mobile which is generally less performant\n * we're marking them as passive by default for other elements, too.\n */\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove'];\n\n/**\n * Returns `true` if `name` is a passive event\n * @param {string} name\n */\nexport function is_passive_event(name) {\n\treturn PASSIVE_EVENTS.includes(name);\n}\n\nconst CONTENT_EDITABLE_BINDINGS = ['textContent', 'innerHTML', 'innerText'];\n\n/** @param {string} name */\nexport function is_content_editable_binding(name) {\n\treturn CONTENT_EDITABLE_BINDINGS.includes(name);\n}\n\nconst LOAD_ERROR_ELEMENTS = [\n\t'body',\n\t'embed',\n\t'iframe',\n\t'img',\n\t'link',\n\t'object',\n\t'script',\n\t'style',\n\t'track'\n];\n\n/**\n * Returns `true` if the element emits `load` and `error` events\n * @param {string} name\n */\nexport function is_load_error_element(name) {\n\treturn LOAD_ERROR_ELEMENTS.includes(name);\n}\n\nconst SVG_ELEMENTS = [\n\t'altGlyph',\n\t'altGlyphDef',\n\t'altGlyphItem',\n\t'animate',\n\t'animateColor',\n\t'animateMotion',\n\t'animateTransform',\n\t'circle',\n\t'clipPath',\n\t'color-profile',\n\t'cursor',\n\t'defs',\n\t'desc',\n\t'discard',\n\t'ellipse',\n\t'feBlend',\n\t'feColorMatrix',\n\t'feComponentTransfer',\n\t'feComposite',\n\t'feConvolveMatrix',\n\t'feDiffuseLighting',\n\t'feDisplacementMap',\n\t'feDistantLight',\n\t'feDropShadow',\n\t'feFlood',\n\t'feFuncA',\n\t'feFuncB',\n\t'feFuncG',\n\t'feFuncR',\n\t'feGaussianBlur',\n\t'feImage',\n\t'feMerge',\n\t'feMergeNode',\n\t'feMorphology',\n\t'feOffset',\n\t'fePointLight',\n\t'feSpecularLighting',\n\t'feSpotLight',\n\t'feTile',\n\t'feTurbulence',\n\t'filter',\n\t'font',\n\t'font-face',\n\t'font-face-format',\n\t'font-face-name',\n\t'font-face-src',\n\t'font-face-uri',\n\t'foreignObject',\n\t'g',\n\t'glyph',\n\t'glyphRef',\n\t'hatch',\n\t'hatchpath',\n\t'hkern',\n\t'image',\n\t'line',\n\t'linearGradient',\n\t'marker',\n\t'mask',\n\t'mesh',\n\t'meshgradient',\n\t'meshpatch',\n\t'meshrow',\n\t'metadata',\n\t'missing-glyph',\n\t'mpath',\n\t'path',\n\t'pattern',\n\t'polygon',\n\t'polyline',\n\t'radialGradient',\n\t'rect',\n\t'set',\n\t'solidcolor',\n\t'stop',\n\t'svg',\n\t'switch',\n\t'symbol',\n\t'text',\n\t'textPath',\n\t'tref',\n\t'tspan',\n\t'unknown',\n\t'use',\n\t'view',\n\t'vkern'\n];\n\n/** @param {string} name */\nexport function is_svg(name) {\n\treturn SVG_ELEMENTS.includes(name);\n}\n\nconst MATHML_ELEMENTS = [\n\t'annotation',\n\t'annotation-xml',\n\t'maction',\n\t'math',\n\t'merror',\n\t'mfrac',\n\t'mi',\n\t'mmultiscripts',\n\t'mn',\n\t'mo',\n\t'mover',\n\t'mpadded',\n\t'mphantom',\n\t'mprescripts',\n\t'mroot',\n\t'mrow',\n\t'ms',\n\t'mspace',\n\t'msqrt',\n\t'mstyle',\n\t'msub',\n\t'msubsup',\n\t'msup',\n\t'mtable',\n\t'mtd',\n\t'mtext',\n\t'mtr',\n\t'munder',\n\t'munderover',\n\t'semantics'\n];\n\n/** @param {string} name */\nexport function is_mathml(name) {\n\treturn MATHML_ELEMENTS.includes(name);\n}\n\nconst RUNES = /** @type {const} */ ([\n\t'$state',\n\t'$state.raw',\n\t'$state.snapshot',\n\t'$props',\n\t'$props.id',\n\t'$bindable',\n\t'$derived',\n\t'$derived.by',\n\t'$effect',\n\t'$effect.pre',\n\t'$effect.tracking',\n\t'$effect.root',\n\t'$inspect',\n\t'$inspect().with',\n\t'$inspect.trace',\n\t'$host'\n]);\n\n/**\n * @param {string} name\n * @returns {name is RUNES[number]}\n */\nexport function is_rune(name) {\n\treturn RUNES.includes(/** @type {RUNES[number]} */ (name));\n}\n\n/** List of elements that require raw contents and should not have SSR comments put in them */\nconst RAW_TEXT_ELEMENTS = /** @type {const} */ (['textarea', 'script', 'style', 'title']);\n\n/** @param {string} name */\nexport function is_raw_text_element(name) {\n\treturn RAW_TEXT_ELEMENTS.includes(/** @type {RAW_TEXT_ELEMENTS[number]} */ (name));\n}\n\n/**\n * Prevent devtools trying to make `location` a clickable link by inserting a zero-width space\n * @param {string | undefined} location\n */\nexport function sanitize_location(location) {\n\treturn location?.replace(/\\//g, '/\\u200b');\n}\n","import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { teardown } from '../../../reactivity/effects.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../../runtime.js';\nimport { add_form_reset_listener } from '../misc.js';\n\n/**\n * Fires the handler once immediately (unless corresponding arg is set to `false`),\n * then listens to the given events until the render effect context is destroyed\n * @param {EventTarget} target\n * @param {Array<string>} events\n * @param {(event?: Event) => void} handler\n * @param {any} call_handler_immediately\n */\nexport function listen(target, events, handler, call_handler_immediately = true) {\n\tif (call_handler_immediately) {\n\t\thandler();\n\t}\n\n\tfor (var name of events) {\n\t\ttarget.addEventListener(name, handler);\n\t}\n\n\tteardown(() => {\n\t\tfor (var name of events) {\n\t\t\ttarget.removeEventListener(name, handler);\n\t\t}\n\t});\n}\n\n/**\n * @template T\n * @param {() => T} fn\n */\nexport function without_reactive_context(fn) {\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * Listen to the given event, and then instantiate a global form reset listener if not already done,\n * to notify all bindings when the form is reset\n * @param {HTMLElement} element\n * @param {string} event\n * @param {(is_reset?: true) => void} handler\n * @param {(is_reset?: true) => void} [on_reset]\n */\nexport function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {\n\telement.addEventListener(event, () => without_reactive_context(handler));\n\t// @ts-expect-error\n\tconst prev = element.__on_r;\n\tif (prev) {\n\t\t// special case for checkbox that can have multiple binds (group & checked)\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => {\n\t\t\tprev();\n\t\t\ton_reset(true);\n\t\t};\n\t} else {\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => on_reset(true);\n\t}\n\n\tadd_form_reset_listener();\n}\n","/** @import { Location } from 'locate-character' */\nimport { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { without_reactive_context } from './bindings/shared.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} [handler]\n * @param {AddEventListenerOptions} [options]\n */\nexport function create_event(event_name, dom, handler, options = {}) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn without_reactive_context(() => {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} [handler]\n * @param {boolean} [capture]\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler === 'function') {\n\t\thandler.apply(element, args);\n\t} else if (has_side_effects || handler != null || error) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\n\t\tconst event_name = args[0].type;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n","/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from './hydration.js';\nimport { create_text, get_first_child, is_firefox } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { active_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\n\n/**\n * @param {TemplateNode} start\n * @param {TemplateNode | null} end\n */\nexport function assign_nodes(start, end) {\n\tvar effect = /** @type {Effect} */ (active_effect);\n\tif (effect.nodes_start === null) {\n\t\teffect.nodes_start = start;\n\t\teffect.nodes_end = end;\n\t}\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (node === undefined) {\n\t\t\tnode = create_fragment_from_html(has_start ? content : '<!>' + content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (get_first_child(node));\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (\n\t\t\tuse_import_node || is_firefox ? document.importNode(node, true) : node.cloneNode(true)\n\t\t);\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar fn = template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\t/**\n\t * Whether or not the first item is a text/element node. If not, we need to\n\t * create an additional comment node to act as `effect.nodes.start`\n\t */\n\tvar has_start = !content.startsWith('<!>');\n\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar wrapped = `<${ns}>${has_start ? content : '<!>' + content}</${ns}>`;\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tassign_nodes(hydrate_node, null);\n\t\t\treturn hydrate_node;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar fragment = /** @type {DocumentFragment} */ (create_fragment_from_html(wrapped));\n\t\t\tvar root = /** @type {Element} */ (get_first_child(fragment));\n\n\t\t\tif (is_fragment) {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (get_first_child(root)) {\n\t\t\t\t\tnode.appendChild(/** @type {Node} */ (get_first_child(root)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(root));\n\t\t\t}\n\t\t}\n\n\t\tvar clone = /** @type {TemplateNode} */ (node.cloneNode(true));\n\n\t\tif (is_fragment) {\n\t\t\tvar start = /** @type {TemplateNode} */ (get_first_child(clone));\n\t\t\tvar end = /** @type {TemplateNode} */ (clone.lastChild);\n\n\t\t\tassign_nodes(start, end);\n\t\t} else {\n\t\t\tassign_nodes(clone, clone);\n\t\t}\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar fn = ns_template(content, flags);\n\treturn () => run_scripts(/** @type {Element | DocumentFragment} */ (fn()));\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n * @returns {Node | Node[]}\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return node;\n\n\tconst is_fragment = node.nodeType === 11;\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tconst effect = /** @type {Effect} */ (active_effect);\n\n\tfor (const script of scripts) {\n\t\tconst clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\n\t\t// The script has changed - if it's at the edges, the effect now points at dead nodes\n\t\tif (is_fragment ? node.firstChild === script : node === script) {\n\t\t\teffect.nodes_start = clone;\n\t\t}\n\t\tif (is_fragment ? node.lastChild === script : node === script) {\n\t\t\teffect.nodes_end = clone;\n\t\t}\n\n\t\tscript.replaceWith(clone);\n\t}\n\treturn node;\n}\n\n/**\n * Don't mark this as side-effect-free, hydration needs to walk all nodes\n * @param {any} value\n */\nexport function text(value = '') {\n\tif (!hydrating) {\n\t\tvar t = create_text(value + '');\n\t\tassign_nodes(t, t);\n\t\treturn t;\n\t}\n\n\tvar node = hydrate_node;\n\n\tif (node.nodeType !== 3) {\n\t\t// if an {expression} is empty during SSR, we need to insert an empty text node\n\t\tnode.before((node = create_text()));\n\t\tset_hydrate_node(node);\n\t}\n\n\tassign_nodes(node, node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tassign_nodes(hydrate_node, null);\n\t\treturn hydrate_node;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar start = document.createComment('');\n\tvar anchor = create_text();\n\tfrag.append(start, anchor);\n\n\tassign_nodes(start, anchor);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) {\n\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\thydrate_next();\n\t\treturn;\n\t}\n\n\tif (anchor === null) {\n\t\t// edge case — void `<svelte:element>` with content\n\t\treturn;\n\t}\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n\nlet uid = 1;\n\n/**\n * Create (or hydrate) an unique UID for the component instance.\n */\nexport function props_id() {\n\tif (\n\t\thydrating &&\n\t\thydrate_node &&\n\t\thydrate_node.nodeType === 8 &&\n\t\thydrate_node.textContent?.startsWith('#s')\n\t) {\n\t\tconst id = hydrate_node.textContent.substring(1);\n\t\thydrate_next();\n\t\treturn id;\n\t}\n\n\treturn 'c' + uid++;\n}\n","/** @import { ComponentContext, Effect, TemplateNode } from '#client' */\n/** @import { Component, ComponentType, SvelteComponent, MountOptions } from '../../index.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tinit_operations\n} from './dom/operations.js';\nimport { HYDRATION_END, HYDRATION_ERROR, HYDRATION_START } from '../../constants.js';\nimport { active_effect } from './runtime.js';\nimport { push, pop, component_context } from './context.js';\nimport { component_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tset_hydrate_node,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from '../shared/utils.js';\nimport {\n\tall_registered_events,\n\thandle_event_propagation,\n\troot_event_handles\n} from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { assign_nodes } from './dom/template.js';\nimport { is_passive_event } from '../../utils.js';\n\n/**\n * This is normally true — block effects should run their intro transitions —\n * but is false during hydration (unless `options.intro` is `true`) and\n * when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// For objects, we apply string coercion (which might make things like $state array references in the template reactive) before diffing\n\tvar str = value == null ? '' : typeof value === 'object' ? value + '' : value;\n\t// @ts-expect-error\n\tif (str !== (text.__t ??= text.nodeValue)) {\n\t\t// @ts-expect-error\n\t\ttext.__t = str;\n\t\ttext.nodeValue = str + '';\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component.\n * Transitions will play during the initial render unless the `intro` option is set to `false`.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {MountOptions<Props>} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\treturn _mount(component, options);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<Props>> | Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tinit_operations();\n\toptions.intro = options.intro ?? false;\n\tconst target = options.target;\n\tconst was_hydrating = hydrating;\n\tconst previous_hydrate_node = hydrate_node;\n\n\ttry {\n\t\tvar anchor = /** @type {TemplateNode} */ (get_first_child(target));\n\t\twhile (\n\t\t\tanchor &&\n\t\t\t(anchor.nodeType !== 8 || /** @type {Comment} */ (anchor).data !== HYDRATION_START)\n\t\t) {\n\t\t\tanchor = /** @type {TemplateNode} */ (get_next_sibling(anchor));\n\t\t}\n\n\t\tif (!anchor) {\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(true);\n\t\tset_hydrate_node(/** @type {Comment} */ (anchor));\n\t\thydrate_next();\n\n\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\tif (\n\t\t\thydrate_node === null ||\n\t\t\thydrate_node.nodeType !== 8 ||\n\t\t\t/** @type {Comment} */ (hydrate_node).data !== HYDRATION_END\n\t\t) {\n\t\t\tw.hydration_mismatch();\n\t\t\tthrow HYDRATION_ERROR;\n\t\t}\n\n\t\tset_hydrating(false);\n\n\t\treturn /**  @type {Exports} */ (instance);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(was_hydrating);\n\t\tset_hydrate_node(previous_hydrate_node);\n\t\treset_head_anchor();\n\t}\n}\n\n/** @type {Map<string, number>} */\nconst document_listeners = new Map();\n\n/**\n * @template {Record<string, any>} Exports\n * @param {ComponentType<SvelteComponent<any>> | Component<any>} Component\n * @param {MountOptions} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = true }) {\n\tinit_operations();\n\n\tvar registered_events = new Set();\n\n\t/** @param {Array<string>} events */\n\tvar event_handle = (events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t// Add the event listener to both the container and the document.\n\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t// the outer content stops propagation of the event.\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, { passive });\n\n\t\t\tvar n = document_listeners.get(event_name);\n\n\t\t\tif (n === undefined) {\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(event_name, handle_event_propagation, { passive });\n\t\t\t\tdocument_listeners.set(event_name, 1);\n\t\t\t} else {\n\t\t\t\tdocument_listeners.set(event_name, n + 1);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tvar component = undefined;\n\n\tvar unmount = component_root(() => {\n\t\tvar anchor_node = anchor ?? target.appendChild(create_text());\n\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {ComponentContext} */ (component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tif (hydrating) {\n\t\t\t\tassign_nodes(/** @type {TemplateNode} */ (anchor_node), null);\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor_node, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (hydrating) {\n\t\t\t\t/** @type {Effect} */ (active_effect).nodes_end = hydrate_node;\n\t\t\t}\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (var event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\n\t\t\t\tvar n = /** @type {number} */ (document_listeners.get(event_name));\n\n\t\t\t\tif (--n === 0) {\n\t\t\t\t\tdocument.removeEventListener(event_name, handle_event_propagation);\n\t\t\t\t\tdocument_listeners.delete(event_name);\n\t\t\t\t} else {\n\t\t\t\t\tdocument_listeners.set(event_name, n);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\troot_event_handles.delete(event_handle);\n\n\t\t\tif (anchor_node !== anchor) {\n\t\t\t\tanchor_node.parentNode?.removeChild(anchor_node);\n\t\t\t}\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n *\n * Since 5.13.0, if `options.outro` is `true`, [transitions](https://svelte.dev/docs/svelte/transition) will play before the component is removed from the DOM.\n *\n * Returns a `Promise` that resolves after transitions have completed if `options.outro` is true, or immediately otherwise (prior to 5.13.0, returns `void`).\n *\n * ```js\n * import { mount, unmount } from 'svelte';\n * import App from './App.svelte';\n *\n * const app = mount(App, { target: document.body });\n *\n * // later...\n * unmount(app, { outro: true });\n * ```\n * @param {Record<string, any>} component\n * @param {{ outro?: boolean }} [options]\n * @returns {Promise<void>}\n */\nexport function unmount(component, options) {\n\tconst fn = mounted_components.get(component);\n\n\tif (fn) {\n\t\tmounted_components.delete(component);\n\t\treturn fn(options);\n\t}\n\n\tif (DEV) {\n\t\tw.lifecycle_double_unmount();\n\t}\n\n\treturn Promise.resolve();\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_START_ELSE, UNINITIALIZED } from '../../../../constants.js';\n\n/**\n * @param {TemplateNode} node\n * @param {(branch: (fn: (anchor: Node) => void, flag?: boolean) => void) => void} fn\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(node, fn, elseif = false) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {UNINITIALIZED | boolean | null} */\n\tvar condition = UNINITIALIZED;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tvar has_branch = false;\n\n\tconst set_branch = (/** @type {(anchor: Node) => void} */ fn, flag = true) => {\n\t\thas_branch = true;\n\t\tupdate_branch(flag, fn);\n\t};\n\n\tconst update_branch = (\n\t\t/** @type {boolean | null} */ new_condition,\n\t\t/** @type {null | ((anchor: Node) => void)} */ fn\n\t) => {\n\t\tif (condition === (condition = new_condition)) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (!!condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else if (fn) {\n\t\t\t\tconsequent_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (fn) {\n\t\t\t\talternate_effect = branch(() => fn(anchor));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t};\n\n\tblock(() => {\n\t\thas_branch = false;\n\t\tfn(set_branch);\n\t\tif (!has_branch) {\n\t\t\tupdate_branch(null, null);\n\t\t}\n\t}, flags);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { UNINITIALIZED } from '../../../../constants.js';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { not_equal, safe_not_equal } from '../../reactivity/equality.js';\nimport { is_runes } from '../../context.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template V\n * @param {TemplateNode} node\n * @param {() => V} get_key\n * @param {(anchor: Node) => TemplateNode | void} render_fn\n * @returns {void}\n */\nexport function key_block(node, get_key, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {V | typeof UNINITIALIZED} */\n\tvar key = UNINITIALIZED;\n\n\t/** @type {Effect} */\n\tvar effect;\n\n\tvar changed = is_runes() ? not_equal : safe_not_equal;\n\n\tblock(() => {\n\t\tif (changed(key, (key = get_key()))) {\n\t\t\tif (effect) {\n\t\t\t\tpause_effect(effect);\n\t\t\t}\n\n\t\t\teffect = branch(() => render_fn(anchor));\n\t\t}\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { EachItem, EachState, Effect, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tremove_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { INERT } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\nimport { active_effect, active_reaction, get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, EachItem>} items_map\n */\nfunction pause_effects(state, items, controlled_anchor, items_map) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(state, items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {EachState} */\n\tvar state = { flags, items: new Map(), first: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(/** @type {Comment | Text} */ (get_first_child(parent_node)))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\tvar was_empty = false;\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\tblock(() => {\n\t\tvar array = get(each_array);\n\t\tvar length = array.length;\n\n\t\tif (was_empty && length === 0) {\n\t\t\t// ignore updates if the array is empty,\n\t\t\t// and it already was empty on previous run\n\t\t\treturn;\n\t\t}\n\t\twas_empty = length === 0;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = remove_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {EachItem | null} */\n\t\t\tvar prev = null;\n\n\t\t\t/** @type {EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\thydrate_node.nodeType === 8 &&\n\t\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t\t) {\n\t\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(\n\t\t\t\t\thydrate_node,\n\t\t\t\t\tstate,\n\t\t\t\t\tprev,\n\t\t\t\t\tnull,\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\ti,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\t\t\t\tstate.items.set(key, item);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\tset_hydrate_node(remove_nodes());\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key, get_collection);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {Array<V>} array\n * @param {EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: MaybeSource<V>, index: number | Source<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @param {() => V[]} get_collection\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key, get_collection) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.first;\n\tvar current = first;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar seen;\n\n\t/** @type {EachItem | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<EachItem>} */\n\tvar to_animate;\n\n\t/** @type {EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? /** @type {TemplateNode} */ (current.e.nodes_start) : anchor;\n\n\t\t\tprev = create_item(\n\t\t\t\tchild_anchor,\n\t\t\t\tstate,\n\t\t\t\tprev,\n\t\t\t\tprev === null ? state.first : prev.next,\n\t\t\t\tvalue,\n\t\t\t\tkey,\n\t\t\t\ti,\n\t\t\t\trender_fn,\n\t\t\t\tflags,\n\t\t\t\tget_collection\n\t\t\t);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen !== undefined && seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(state, item.prev, item.next);\n\t\t\t\t\tlink(state, item, prev === null ? state.first : prev.next);\n\t\t\t\t\tlink(state, prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\t// If the each block isn't inert and an item has an effect that is already inert,\n\t\t\t\t// skip over adding it to our seen Set as the item is already being handled\n\t\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\t}\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\tvar to_destroy = seen === undefined ? [] : array_from(seen);\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.e.f & INERT) === 0) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor, items);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n\n\t/** @type {Effect} */ (active_effect).first = state.first && state.first.e;\n\t/** @type {Effect} */ (active_effect).last = prev && prev.e;\n}\n\n/**\n * @param {EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tinternal_set(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tinternal_set(/** @type {Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @returns {EachItem}\n */\nfunction create_item(\n\tanchor,\n\tstate,\n\tprev,\n\tnext,\n\tvalue,\n\tkey,\n\tindex,\n\trender_fn,\n\tflags,\n\tget_collection\n) {\n\tvar previous_each_item = current_each_item;\n\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\tvar mutable = (flags & EACH_ITEM_IMMUTABLE) === 0;\n\n\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\tif (DEV && reactive) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\t/** @type {Value} */ (v).debug = () => {\n\t\t\tvar collection_index = typeof i === 'number' ? index : i.v;\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[collection_index];\n\t\t};\n\t}\n\n\t/** @type {EachItem} */\n\tvar item = {\n\t\ti,\n\t\tv,\n\t\tk: key,\n\t\ta: null,\n\t\t// @ts-expect-error\n\t\te: null,\n\t\tprev,\n\t\tnext\n\t};\n\n\tcurrent_each_item = item;\n\n\ttry {\n\t\titem.e = branch(() => render_fn(anchor, v, i, get_collection), hydrating);\n\n\t\titem.e.prev = prev && prev.e;\n\t\titem.e.next = next && next.e;\n\n\t\tif (prev === null) {\n\t\t\tstate.first = item;\n\t\t} else {\n\t\t\tprev.next = item;\n\t\t\tprev.e.next = item.e;\n\t\t}\n\n\t\tif (next !== null) {\n\t\t\tnext.prev = item;\n\t\t\tnext.e.prev = item.e;\n\t\t}\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {EachItem} item\n * @param {EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? /** @type {TemplateNode} */ (item.next.e.nodes_start) : anchor;\n\n\tvar dest = next ? /** @type {TemplateNode} */ (next.e.nodes_start) : anchor;\n\tvar node = /** @type {TemplateNode} */ (item.e.nodes_start);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {EachItem | null} prev\n * @param {EachItem | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.first = next;\n\t} else {\n\t\tprev.next = next;\n\t\tprev.e.next = next && next.e;\n\t}\n\n\tif (next !== null) {\n\t\tnext.prev = prev;\n\t\tnext.e.prev = prev && prev.e;\n\t}\n}\n","/** @import { Effect, TemplateNode } from '#client' */\nimport { FILENAME, HYDRATION_ERROR } from '../../../../constants.js';\nimport { block, branch, destroy_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from '../hydration.js';\nimport { create_fragment_from_html } from '../reconciler.js';\nimport { assign_nodes } from '../template.js';\nimport * as w from '../../warnings.js';\nimport { hash, sanitize_location } from '../../../../utils.js';\nimport { DEV } from 'esm-env';\nimport { dev_current_component_function } from '../../context.js';\nimport { get_first_child, get_next_sibling } from '../operations.js';\n\n/**\n * @param {Element} element\n * @param {string | null} server_hash\n * @param {string} value\n */\nfunction check_hash(element, server_hash, value) {\n\tif (!server_hash || server_hash === hash(String(value ?? ''))) return;\n\n\tlet location;\n\n\t// @ts-expect-error\n\tconst loc = element.__svelte_meta?.loc;\n\tif (loc) {\n\t\tlocation = `near ${loc.file}:${loc.line}:${loc.column}`;\n\t} else if (dev_current_component_function?.[FILENAME]) {\n\t\tlocation = `in ${dev_current_component_function[FILENAME]}`;\n\t}\n\n\tw.hydration_html_changed(sanitize_location(location));\n}\n\n/**\n * @param {Element | Text | Comment} node\n * @param {() => string} get_value\n * @param {boolean} svg\n * @param {boolean} mathml\n * @param {boolean} [skip_warning]\n * @returns {void}\n */\nexport function html(node, get_value, svg, mathml, skip_warning) {\n\tvar anchor = node;\n\n\tvar value = '';\n\n\t/** @type {Effect | undefined} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (value === (value = get_value() ?? '')) {\n\t\t\tif (hydrating) {\n\t\t\t\thydrate_next();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (effect !== undefined) {\n\t\t\tdestroy_effect(effect);\n\t\t\teffect = undefined;\n\t\t}\n\n\t\tif (value === '') return;\n\n\t\teffect = branch(() => {\n\t\t\tif (hydrating) {\n\t\t\t\t// We're deliberately not trying to repair mismatches between server and client,\n\t\t\t\t// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)\n\t\t\t\tvar hash = /** @type {Comment} */ (hydrate_node).data;\n\t\t\t\tvar next = hydrate_next();\n\t\t\t\tvar last = next;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext !== null &&\n\t\t\t\t\t(next.nodeType !== 8 || /** @type {Comment} */ (next).data !== '')\n\t\t\t\t) {\n\t\t\t\t\tlast = next;\n\t\t\t\t\tnext = /** @type {TemplateNode} */ (get_next_sibling(next));\n\t\t\t\t}\n\n\t\t\t\tif (next === null) {\n\t\t\t\t\tw.hydration_mismatch();\n\t\t\t\t\tthrow HYDRATION_ERROR;\n\t\t\t\t}\n\n\t\t\t\tif (DEV && !skip_warning) {\n\t\t\t\t\tcheck_hash(/** @type {Element} */ (next.parentNode), hash, value);\n\t\t\t\t}\n\n\t\t\t\tassign_nodes(hydrate_node, last);\n\t\t\t\tanchor = set_hydrate_node(next);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar html = value + '';\n\t\t\tif (svg) html = `<svg>${html}</svg>`;\n\t\t\telse if (mathml) html = `<math>${html}</math>`;\n\n\t\t\t// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.\n\t\t\t// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.\n\t\t\t/** @type {DocumentFragment | Element} */\n\t\t\tvar node = create_fragment_from_html(html);\n\n\t\t\tif (svg || mathml) {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(node));\n\t\t\t}\n\n\t\t\tassign_nodes(\n\t\t\t\t/** @type {TemplateNode} */ (get_first_child(node)),\n\t\t\t\t/** @type {TemplateNode} */ (node.lastChild)\n\t\t\t);\n\n\t\t\tif (svg || mathml) {\n\t\t\t\twhile (get_first_child(node)) {\n\t\t\t\t\tanchor.before(/** @type {Node} */ (get_first_child(node)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanchor.before(node);\n\t\t\t}\n\t\t});\n\t});\n}\n","import { hydrate_next, hydrating } from '../hydration.js';\n\n/**\n * @param {Comment} anchor\n * @param {Record<string, any>} $$props\n * @param {string} name\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor, $$props, name, slot_props, fallback_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar slot_fn = $$props.$$slots?.[name];\n\t// Interop: Can use snippets to fill slots\n\tvar is_interop = false;\n\tif (slot_fn === true) {\n\t\tslot_fn = $$props[name === 'default' ? 'children' : name];\n\t\tis_interop = true;\n\t}\n\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor, is_interop ? () => slot_props : slot_props);\n\t}\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, boolean>}\n */\nexport function sanitize_slots(props) {\n\t/** @type {Record<string, boolean>} */\n\tconst sanitized = {};\n\tif (props.children) sanitized.default = true;\n\tfor (const key in props.$$slots) {\n\t\tsanitized[key] = true;\n\t}\n\treturn sanitized;\n}\n","/** @import { TemplateNode, Dom, Effect } from '#client' */\nimport { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { block, branch, pause_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating } from '../hydration.js';\n\n/**\n * @template P\n * @template {(props: P) => void} C\n * @param {TemplateNode} node\n * @param {() => C} get_component\n * @param {(anchor: TemplateNode, component: C) => Dom | void} render_fn\n * @returns {void}\n */\nexport function component(node, get_component, render_fn) {\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\tvar anchor = node;\n\n\t/** @type {C} */\n\tvar component;\n\n\t/** @type {Effect | null} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (component === (component = get_component())) return;\n\n\t\tif (effect) {\n\t\t\tpause_effect(effect);\n\t\t\teffect = null;\n\t\t}\n\n\t\tif (component) {\n\t\t\teffect = branch(() => render_fn(anchor, component));\n\t\t}\n\t}, EFFECT_TRANSPARENT);\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n","/** @import { ActionPayload } from '#client' */\nimport { effect, render_effect } from '../../reactivity/effects.js';\nimport { safe_not_equal } from '../../reactivity/equality.js';\nimport { deep_read_state, untrack } from '../../runtime.js';\n\n/**\n * @template P\n * @param {Element} dom\n * @param {(dom: Element, value?: P) => ActionPayload<P>} action\n * @param {() => P} [get_value]\n * @returns {void}\n */\nexport function action(dom, action, get_value) {\n\teffect(() => {\n\t\tvar payload = untrack(() => action(dom, get_value?.()) || {});\n\n\t\tif (get_value && payload?.update) {\n\t\t\tvar inited = false;\n\t\t\t/** @type {P} */\n\t\t\tvar prev = /** @type {any} */ ({}); // initialize with something so it's never equal on first run\n\n\t\t\trender_effect(() => {\n\t\t\t\tvar value = get_value();\n\n\t\t\t\t// Action's update method is coarse-grained, i.e. when anything in the passed value changes, update.\n\t\t\t\t// This works in legacy mode because of mutable_source being updated as a whole, but when using $state\n\t\t\t\t// together with actions and mutation, it wouldn't notice the change without a deep read.\n\t\t\t\tdeep_read_state(value);\n\n\t\t\t\tif (inited && safe_not_equal(prev, value)) {\n\t\t\t\t\tprev = value;\n\t\t\t\t\t/** @type {Function} */ (payload.update)(value);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tinited = true;\n\t\t}\n\n\t\tif (payload?.destroy) {\n\t\t\treturn () => /** @type {Function} */ (payload.destroy)();\n\t\t}\n\t});\n}\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","import { escape_html } from '../../escaping.js';\nimport { clsx as _clsx } from 'clsx';\n\n/**\n * `<div translate={false}>` should be rendered as `<div translate=\"no\">` and _not_\n * `<div translate=\"false\">`, which is equivalent to `<div translate=\"yes\">`. There\n * may be other odd cases that need to be added to this list in future\n * @type {Record<string, Map<any, string>>}\n */\nconst replacements = {\n\ttranslate: new Map([\n\t\t[true, 'yes'],\n\t\t[false, 'no']\n\t])\n};\n\n/**\n * @template V\n * @param {string} name\n * @param {V} value\n * @param {boolean} [is_boolean]\n * @returns {string}\n */\nexport function attr(name, value, is_boolean = false) {\n\tif (value == null || (!value && is_boolean) || (value === '' && name === 'class')) return '';\n\tconst normalized = (name in replacements && replacements[name].get(value)) || value;\n\tconst assignment = is_boolean ? '' : `=\"${escape_html(normalized, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/**\n * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.\n * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)\n * @param  {any} value\n */\nexport function clsx(value) {\n\tif (typeof value === 'object') {\n\t\treturn _clsx(value);\n\t} else {\n\t\treturn value ?? '';\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { hydrating, set_hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '../../constants.js';\nimport { queue_idle_task } from '../task.js';\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { clsx } from '../../../shared/attributes.js';\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (\n\t\tattributes.value ===\n\t\t\t(attributes.value =\n\t\t\t\t// treat null and undefined the same for the initial value\n\t\t\t\tvalue ?? undefined) ||\n\t\t// @ts-expect-error\n\t\t// `progress` elements always need their value set when it's `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.value = value ?? '';\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (\n\t\tattributes.checked ===\n\t\t(attributes.checked =\n\t\t\t// treat null and undefined the same for the initial value\n\t\t\tchecked ?? undefined)\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * Sets the `selected` attribute on an `option` element.\n * Not set through the property because that doesn't reflect to the DOM,\n * which means it wouldn't be taken into account when a form is reset.\n * @param {HTMLOptionElement} element\n * @param {boolean} selected\n */\nexport function set_selected(element, selected) {\n\tif (selected) {\n\t\t// The selected option could've changed via user selection, and\n\t\t// setting the value without this check would set it back.\n\t\tif (!element.hasAttribute('selected')) {\n\t\t\telement.setAttribute('selected', '');\n\t\t}\n\t} else {\n\t\telement.removeAttribute('selected');\n\t}\n}\n\n/**\n * Applies the default checked property without influencing the current checked property.\n * @param {HTMLInputElement} element\n * @param {boolean} checked\n */\nexport function set_default_checked(element, checked) {\n\tconst existing_value = element.checked;\n\telement.defaultChecked = checked;\n\telement.checked = existing_value;\n}\n\n/**\n * Applies the default value property without influencing the current value property.\n * @param {HTMLInputElement | HTMLTextAreaElement} element\n * @param {string} value\n */\nexport function set_default_value(element, value) {\n\tconst existing_value = element.value;\n\telement.defaultValue = value;\n\telement.value = existing_value;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'style' && '__styles' in element) {\n\t\t// reset styles to force style: directive to update\n\t\telement.__styles = {};\n\t}\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\t// We need to ensure that setting custom element props, which can\n\t// invoke lifecycle methods on other custom elements, does not also\n\t// associate those lifecycle methods with the current active reaction\n\t// or effect\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet was_hydrating = hydrating;\n\tif (hydrating) {\n\t\tset_hydrating(false);\n\t}\n\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\tif (\n\t\t\t// Don't compute setters for custom elements while they aren't registered yet,\n\t\t\t// because during their upgrade/instantiation they might add more setters.\n\t\t\t// Instead, fall back to a simple \"an object, then set as property\" heuristic.\n\t\t\tsetters_cache.has(node.nodeName) ||\n\t\t\t// customElements may not be available in browser extension contexts\n\t\t\t!customElements ||\n\t\t\tcustomElements.get(node.tagName.toLowerCase())\n\t\t\t\t? get_setters(node).includes(prop)\n\t\t\t\t: value && typeof value === 'object'\n\t\t) {\n\t\t\t// @ts-expect-error\n\t\t\tnode[prop] = value;\n\t\t} else {\n\t\t\t// We did getters etc checks already, stringify before passing to set_attribute\n\t\t\t// to ensure it doesn't invoke the same logic again, and potentially populating\n\t\t\t// the setters cache too early.\n\t\t\tset_attribute(node, prop, value == null ? value : String(value));\n\t\t}\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t\tif (was_hydrating) {\n\t\t\tset_hydrating(true);\n\t\t}\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string, any> | undefined} prev\n * @param {Record<string, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [preserve_attribute_case]\n * @param {boolean} [is_custom_element]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nexport function set_attributes(\n\telement,\n\tprev,\n\tnext,\n\tcss_hash,\n\tpreserve_attribute_case = false,\n\tis_custom_element = false,\n\tskip_warning = false\n) {\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet is_hydrating_custom_element = hydrating && is_custom_element;\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(false);\n\t}\n\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (next.class) {\n\t\tnext.class = clsx(next.class);\n\t}\n\n\tif (css_hash !== undefined) {\n\t\tnext.class = next.class ? next.class + ' ' + css_hash : css_hash;\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// @ts-expect-error\n\tvar attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = is_delegated(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t} else if (delegated) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[`__${event_name}`] = undefined;\n\t\t\t}\n\t\t} else if (key === 'style' && value != null) {\n\t\t\telement.style.cssText = value + '';\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {\n\t\t\t// @ts-ignore We're not running this for custom elements because __value is actually\n\t\t\t// how Lit stores the current value on the element, and messing with that would break things.\n\t\t\telement.value = element.__value = value;\n\t\t} else if (key === 'selected' && is_option_element) {\n\t\t\tset_selected(/** @type {HTMLOptionElement} */ (element), value);\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tvar is_default = name === 'defaultValue' || name === 'defaultChecked';\n\n\t\t\tif (value == null && !is_custom_element && !is_default) {\n\t\t\t\tattributes[key] = null;\n\n\t\t\t\tif (name === 'value' || name === 'checked') {\n\t\t\t\t\t// removing value/checked also removes defaultValue/defaultChecked — preserve\n\t\t\t\t\tlet input = /** @type {HTMLInputElement} */ (element);\n\t\t\t\t\tconst use_default = prev === undefined;\n\t\t\t\t\tif (name === 'value') {\n\t\t\t\t\t\tlet previous = input.defaultValue;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultValue = previous;\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tinput.value = input.__value = use_default ? previous : null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet previous = input.defaultChecked;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultChecked = previous;\n\t\t\t\t\t\tinput.checked = use_default ? previous : false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.removeAttribute(key);\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tis_default ||\n\t\t\t\t(setters.includes(name) && (is_custom_element || typeof value !== 'string'))\n\t\t\t) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tset_attribute(element, name, value);\n\t\t\t}\n\t\t}\n\t\tif (key === 'style' && '__styles' in element) {\n\t\t\t// reset styles to force style: directive to update\n\t\t\telement.__styles = {};\n\t\t}\n\t}\n\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(true);\n\t}\n\n\treturn current;\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\n\tvar descriptors;\n\tvar proto = element; // In the case of custom elements there might be setters on the instance\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n","import { hydrating } from '../hydration.js';\n\n/**\n * @param {SVGElement} dom\n * @param {string} value\n * @param {string} [hash]\n * @returns {void}\n */\nexport function set_svg_class(dom, value, hash) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value, hash);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {MathMLElement} dom\n * @param {string} value\n * @param {string} [hash]\n * @returns {void}\n */\nexport function set_mathml_class(dom, value, hash) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value, hash);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {string} value\n * @param {string} [hash]\n * @returns {void}\n */\nexport function set_class(dom, value, hash) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value, hash);\n\n\tif (hydrating && dom.className === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.className !== next_class_name)\n\t) {\n\t\t// Removing the attribute when the value is only an empty string causes\n\t\t// peformance issues vs simply making the className an empty string. So\n\t\t// we should only remove the class if the the value is nullish.\n\t\tif (value == null && !hash) {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.className = next_class_name;\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {string} [hash]\n * @returns {string | V}\n */\nfunction to_class(value, hash) {\n\treturn (value == null ? '' : value) + (hash ? ' ' + hash : '');\n}\n\n/**\n * @param {Element} dom\n * @param {string} class_name\n * @param {boolean} value\n * @returns {void}\n */\nexport function toggle_class(dom, class_name, value) {\n\tif (value) {\n\t\tif (dom.classList.contains(class_name)) return;\n\t\tdom.classList.add(class_name);\n\t} else {\n\t\tif (!dom.classList.contains(class_name)) return;\n\t\tdom.classList.remove(class_name);\n\t}\n}\n","/**\n * @param {HTMLElement} dom\n * @param {string} key\n * @param {string} value\n * @param {boolean} [important]\n */\nexport function set_style(dom, key, value, important) {\n\t// @ts-expect-error\n\tvar styles = (dom.__styles ??= {});\n\n\tif (styles[key] === value) {\n\t\treturn;\n\t}\n\n\tstyles[key] = value;\n\n\tif (value == null) {\n\t\tdom.style.removeProperty(key);\n\t} else {\n\t\tdom.style.setProperty(key, value, important ? 'important' : '');\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { render_effect, teardown } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport * as e from '../../../errors.js';\nimport { is } from '../../../proxy.js';\nimport { queue_micro_task } from '../../task.js';\nimport { hydrating } from '../../hydration.js';\nimport { untrack } from '../../../runtime.js';\nimport { is_runes } from '../../../context.js';\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_value(input, get, set = get) {\n\tvar runes = is_runes();\n\n\tlisten_to_event_and_reset_event(input, 'input', (is_reset) => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\t/** @type {any} */\n\t\tvar value = is_reset ? input.defaultValue : input.value;\n\t\tvalue = is_numberlike_input(input) ? to_number(value) : value;\n\t\tset(value);\n\n\t\t// In runes mode, respect any validation in accessors (doesn't apply in legacy mode,\n\t\t// because we use mutable state which ensures the render effect always runs)\n\t\tif (runes && value !== (value = get())) {\n\t\t\tvar start = input.selectionStart;\n\t\t\tvar end = input.selectionEnd;\n\n\t\t\t// the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\n\t\t\t// Restore selection\n\t\t\tif (end !== null) {\n\t\t\t\tinput.selectionStart = start;\n\t\t\t\tinput.selectionEnd = Math.min(end, input.value.length);\n\t\t\t}\n\t\t}\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\t(hydrating && input.defaultValue !== input.value) ||\n\t\t// If defaultValue is set, then value == defaultValue\n\t\t// TODO Svelte 6: remove input.value check and set to empty string?\n\t\t(untrack(get) == null && input.value)\n\t) {\n\t\tset(is_numberlike_input(input) ? to_number(input.value) : input.value);\n\t}\n\n\trender_effect(() => {\n\t\tif (DEV && input.type === 'checkbox') {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.bind_invalid_checkbox_value();\n\t\t}\n\n\t\tvar value = get();\n\n\t\tif (is_numberlike_input(input) && value === to_number(input.value)) {\n\t\t\t// handles 0 vs 00 case (see https://github.com/sveltejs/svelte/issues/9959)\n\t\t\treturn;\n\t\t}\n\n\t\tif (input.type === 'date' && !value && !input.value) {\n\t\t\t// Handles the case where a temporarily invalid date is set (while typing, for example with a leading 0 for the day)\n\t\t\t// and prevents this state from clearing the other parts of the date input (see https://github.com/sveltejs/svelte/issues/7897)\n\t\t\treturn;\n\t\t}\n\n\t\t// don't set the value of the input if it's the same to allow\n\t\t// minlength to work properly\n\t\tif (value !== input.value) {\n\t\t\t// @ts-expect-error the value is coerced on assignment\n\t\t\tinput.value = value ?? '';\n\t\t}\n\t});\n}\n\n/** @type {Set<HTMLInputElement[]>} */\nconst pending = new Set();\n\n/**\n * @param {HTMLInputElement[]} inputs\n * @param {null | [number]} group_index\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_group(inputs, group_index, input, get, set = get) {\n\tvar is_checkbox = input.getAttribute('type') === 'checkbox';\n\tvar binding_group = inputs;\n\n\t// needs to be let or related code isn't treeshaken out if it's always false\n\tlet hydration_mismatch = false;\n\n\tif (group_index !== null) {\n\t\tfor (var index of group_index) {\n\t\t\t// @ts-expect-error\n\t\t\tbinding_group = binding_group[index] ??= [];\n\t\t}\n\t}\n\n\tbinding_group.push(input);\n\n\tlisten_to_event_and_reset_event(\n\t\tinput,\n\t\t'change',\n\t\t() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = input.__value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t}\n\n\t\t\tset(value);\n\t\t},\n\t\t// TODO better default value handling\n\t\t() => set(is_checkbox ? [] : null)\n\t);\n\n\trender_effect(() => {\n\t\tvar value = get();\n\n\t\t// If we are hydrating and the value has since changed, then use the update value\n\t\t// from the input instead.\n\t\tif (hydrating && input.defaultChecked !== input.checked) {\n\t\t\thydration_mismatch = true;\n\t\t\treturn;\n\t\t}\n\n\t\tif (is_checkbox) {\n\t\t\tvalue = value || [];\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = value.includes(input.__value);\n\t\t} else {\n\t\t\t// @ts-ignore\n\t\t\tinput.checked = is(input.__value, value);\n\t\t}\n\t});\n\n\tteardown(() => {\n\t\tvar index = binding_group.indexOf(input);\n\n\t\tif (index !== -1) {\n\t\t\tbinding_group.splice(index, 1);\n\t\t}\n\t});\n\n\tif (!pending.has(binding_group)) {\n\t\tpending.add(binding_group);\n\n\t\tqueue_micro_task(() => {\n\t\t\t// necessary to maintain binding group order in all insertion scenarios\n\t\t\tbinding_group.sort((a, b) => (a.compareDocumentPosition(b) === 4 ? -1 : 1));\n\t\t\tpending.delete(binding_group);\n\t\t});\n\t}\n\n\tqueue_micro_task(() => {\n\t\tif (hydration_mismatch) {\n\t\t\tvar value;\n\n\t\t\tif (is_checkbox) {\n\t\t\t\tvalue = get_binding_group_value(binding_group, value, input.checked);\n\t\t\t} else {\n\t\t\t\tvar hydration_input = binding_group.find((input) => input.checked);\n\t\t\t\t// @ts-ignore\n\t\t\t\tvalue = hydration_input?.__value;\n\t\t\t}\n\n\t\t\tset(value);\n\t\t}\n\t});\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_checked(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', (is_reset) => {\n\t\tvar value = is_reset ? input.defaultChecked : input.checked;\n\t\tset(value);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the update value from the input instead.\n\t\t(hydrating && input.defaultChecked !== input.checked) ||\n\t\t// If defaultChecked is set, then checked == defaultChecked\n\t\tuntrack(get) == null\n\t) {\n\t\tset(input.checked);\n\t}\n\n\trender_effect(() => {\n\t\tvar value = get();\n\t\tinput.checked = Boolean(value);\n\t});\n}\n\n/**\n * @template V\n * @param {Array<HTMLInputElement>} group\n * @param {V} __value\n * @param {boolean} checked\n * @returns {V[]}\n */\nfunction get_binding_group_value(group, __value, checked) {\n\tvar value = new Set();\n\n\tfor (var i = 0; i < group.length; i += 1) {\n\t\tif (group[i].checked) {\n\t\t\t// @ts-ignore\n\t\t\tvalue.add(group[i].__value);\n\t\t}\n\t}\n\n\tif (!checked) {\n\t\tvalue.delete(__value);\n\t}\n\n\treturn Array.from(value);\n}\n\n/**\n * @param {HTMLInputElement} input\n */\nfunction is_numberlike_input(input) {\n\tvar type = input.type;\n\treturn type === 'number' || type === 'range';\n}\n\n/**\n * @param {string} value\n */\nfunction to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/**\n * @param {HTMLInputElement} input\n * @param {() => FileList | null} get\n * @param {(value: FileList | null) => void} set\n */\nexport function bind_files(input, get, set = get) {\n\tlisten_to_event_and_reset_event(input, 'change', () => {\n\t\tset(input.files);\n\t});\n\n\tif (\n\t\t// If we are hydrating and the value has since changed,\n\t\t// then use the updated value from the input instead.\n\t\thydrating &&\n\t\tinput.files\n\t) {\n\t\tset(input.files);\n\t}\n\n\trender_effect(() => {\n\t\tinput.files = get();\n\t});\n}\n","import { teardown } from '../../../reactivity/effects.js';\nimport { get_descriptor } from '../../../../shared/utils.js';\n\n/**\n * Makes an `export`ed (non-prop) variable available on the `$$props` object\n * so that consumers can do `bind:x` on the component.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} prop\n * @param {V} value\n * @returns {void}\n */\nexport function bind_prop(props, prop, value) {\n\tvar desc = get_descriptor(props, prop);\n\n\tif (desc && desc.set) {\n\t\tprops[prop] = value;\n\t\tteardown(() => {\n\t\t\tprops[prop] = null;\n\t\t});\n\t}\n}\n","import { effect } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { untrack } from '../../../runtime.js';\nimport { is } from '../../../proxy.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} [mounting]\n */\nexport function select_option(select, value, mounting) {\n\tif (select.multiple) {\n\t\treturn select_options(select, value);\n\t}\n\n\tfor (var option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @template V\n * @param {HTMLSelectElement} select\n * @param {() => V} [get_value]\n */\nexport function init_select(select, get_value) {\n\tlet mounting = true;\n\teffect(() => {\n\t\tif (get_value) {\n\t\t\tselect_option(select, untrack(get_value), mounting);\n\t\t}\n\t\tmounting = false;\n\n\t\tvar observer = new MutationObserver(() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = select.__value;\n\t\t\tselect_option(select, value);\n\t\t\t// Deliberately don't update the potential binding value,\n\t\t\t// the model should be preserved unless explicitly changed\n\t\t});\n\n\t\tobserver.observe(select, {\n\t\t\t// Listen to option element changes\n\t\t\tchildList: true,\n\t\t\tsubtree: true, // because of <optgroup>\n\t\t\t// Listen to option element value attribute changes\n\t\t\t// (doesn't get notified of select value changes,\n\t\t\t// because that property is not reflected as an attribute)\n\t\t\tattributes: true,\n\t\t\tattributeFilter: ['value']\n\t\t});\n\n\t\treturn () => {\n\t\t\tobserver.disconnect();\n\t\t};\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_select_value(select, get, set = get) {\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', (is_reset) => {\n\t\tvar query = is_reset ? '[selected]' : ':checked';\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option =\n\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tset(value);\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get();\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tset(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\t// don't pass get_value, we already initialize it in the effect above\n\tinit_select(select);\n}\n\n/**\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n */\nfunction select_options(select, value) {\n\tfor (var option of select.options) {\n\t\t// @ts-ignore\n\t\toption.selected = ~value.indexOf(get_option_value(option));\n\t}\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n","import { STATE_SYMBOL } from '../../../constants.js';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\treturn (\n\t\tbound_value === element_or_component || bound_value?.[STATE_SYMBOL] === element_or_component\n\t);\n}\n\n/**\n * @param {any} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component = {}, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n\n\treturn element_or_component;\n}\n","/** @import { ActionReturn } from 'svelte/action' */\nimport { noop } from '../../../shared/utils.js';\nimport { user_pre_effect } from '../../reactivity/effects.js';\nimport { on } from '../elements/events.js';\n\n/**\n * Substitute for the `trusted` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function trusted(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tif (event.isTrusted) {\n\t\t\t// @ts-ignore\n\t\t\tfn?.apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * Substitute for the `self` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function self(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\t// @ts-ignore\n\t\tif (event.target === this) {\n\t\t\t// @ts-ignore\n\t\t\tfn?.apply(this, args);\n\t\t}\n\t};\n}\n\n/**\n * Substitute for the `stopPropagation` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopPropagation(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.stopPropagation();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `once` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function once(fn) {\n\tvar ran = false;\n\n\treturn function (...args) {\n\t\tif (ran) return;\n\t\tran = true;\n\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `stopImmediatePropagation` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function stopImmediatePropagation(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.stopImmediatePropagation();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `preventDefault` event modifier\n * @deprecated\n * @param {(event: Event, ...args: Array<unknown>) => void} fn\n * @returns {(event: Event, ...args: unknown[]) => void}\n */\nexport function preventDefault(fn) {\n\treturn function (...args) {\n\t\tvar event = /** @type {Event} */ (args[0]);\n\t\tevent.preventDefault();\n\t\t// @ts-ignore\n\t\treturn fn?.apply(this, args);\n\t};\n}\n\n/**\n * Substitute for the `passive` event modifier, implemented as an action\n * @deprecated\n * @param {HTMLElement} node\n * @param {[event: string, handler: () => EventListener]} options\n */\nexport function passive(node, [event, handler]) {\n\tuser_pre_effect(() => {\n\t\treturn on(node, event, handler() ?? noop, {\n\t\t\tpassive: true\n\t\t});\n\t});\n}\n\n/**\n * Substitute for the `nonpassive` event modifier, implemented as an action\n * @deprecated\n * @param {HTMLElement} node\n * @param {[event: string, handler: () => EventListener]} options\n */\nexport function nonpassive(node, [event, handler]) {\n\tuser_pre_effect(() => {\n\t\treturn on(node, event, handler() ?? noop, {\n\t\t\tpassive: false\n\t\t});\n\t});\n}\n","/** @import { ComponentContextLegacy } from '#client' */\nimport { run, run_all } from '../../../shared/utils.js';\nimport { component_context } from '../../context.js';\nimport { derived } from '../../reactivity/deriveds.js';\nimport { user_pre_effect, user_effect } from '../../reactivity/effects.js';\nimport { deep_read_state, get, untrack } from '../../runtime.js';\n\n/**\n * Legacy-mode only: Call `onMount` callbacks and set up `beforeUpdate`/`afterUpdate` effects\n * @param {boolean} [immutable]\n */\nexport function init(immutable = false) {\n\tconst context = /** @type {ComponentContextLegacy} */ (component_context);\n\n\tconst callbacks = context.l.u;\n\tif (!callbacks) return;\n\n\tlet props = () => deep_read_state(context.s);\n\n\tif (immutable) {\n\t\tlet version = 0;\n\t\tlet prev = /** @type {Record<string, any>} */ ({});\n\n\t\t// In legacy immutable mode, before/afterUpdate only fire if the object identity of a prop changes\n\t\tconst d = derived(() => {\n\t\t\tlet changed = false;\n\t\t\tconst props = context.s;\n\t\t\tfor (const key in props) {\n\t\t\t\tif (props[key] !== prev[key]) {\n\t\t\t\t\tprev[key] = props[key];\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (changed) version++;\n\t\t\treturn version;\n\t\t});\n\n\t\tprops = () => get(d);\n\t}\n\n\t// beforeUpdate\n\tif (callbacks.b.length) {\n\t\tuser_pre_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.b);\n\t\t});\n\t}\n\n\t// onMount (must run before afterUpdate)\n\tuser_effect(() => {\n\t\tconst fns = untrack(() => callbacks.m.map(run));\n\t\treturn () => {\n\t\t\tfor (const fn of fns) {\n\t\t\t\tif (typeof fn === 'function') {\n\t\t\t\t\tfn();\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\n\t// afterUpdate\n\tif (callbacks.a.length) {\n\t\tuser_effect(() => {\n\t\t\tobserve_all(context, props);\n\t\t\trun_all(callbacks.a);\n\t\t});\n\t}\n}\n\n/**\n * Invoke the getter of all signals associated with a component\n * so they can be registered to the effect this function is called in.\n * @param {ComponentContextLegacy} context\n * @param {(() => void)} props\n */\nfunction observe_all(context, props) {\n\tif (context.l.s) {\n\t\tfor (const signal of context.l.s) get(signal);\n\t}\n\n\tprops();\n}\n","import { set, source } from '../../reactivity/sources.js';\nimport { get } from '../../runtime.js';\nimport { is_array } from '../../../shared/utils.js';\n\n/**\n * Under some circumstances, imports may be reactive in legacy mode. In that case,\n * they should be using `reactive_import` as part of the transformation\n * @param {() => any} fn\n */\nexport function reactive_import(fn) {\n\tvar s = source(0);\n\n\treturn function () {\n\t\tif (arguments.length === 1) {\n\t\t\tset(s, get(s) + 1);\n\t\t\treturn arguments[0];\n\t\t} else {\n\t\t\tget(s);\n\t\t\treturn fn();\n\t\t}\n\t};\n}\n\n/**\n * @this {any}\n * @param {Record<string, unknown>} $$props\n * @param {Event} event\n * @returns {void}\n */\nexport function bubble_event($$props, event) {\n\tvar events = /** @type {Record<string, Function[] | Function>} */ ($$props.$$events)?.[\n\t\tevent.type\n\t];\n\n\tvar callbacks = is_array(events) ? events.slice() : events == null ? [] : [events];\n\n\tfor (var fn of callbacks) {\n\t\t// Preserve \"this\" context\n\t\tfn.call(this, event);\n\t}\n}\n\n/**\n * Used to simulate `$on` on a component instance when `compatibility.componentApi === 4`\n * @param {Record<string, any>} $$props\n * @param {string} event_name\n * @param {Function} event_callback\n */\nexport function add_legacy_event_listener($$props, event_name, event_callback) {\n\t$$props.$$events ||= {};\n\t$$props.$$events[event_name] ||= [];\n\t$$props.$$events[event_name].push(event_callback);\n}\n\n/**\n * Used to simulate `$set` on a component instance when `compatibility.componentApi === 4`.\n * Needs component accessors so that it can call the setter of the prop. Therefore doesn't\n * work for updating props in `$$props` or `$$restProps`.\n * @this {Record<string, any>}\n * @param {Record<string, any>} $$new_props\n */\nexport function update_legacy_props($$new_props) {\n\tfor (var key in $$new_props) {\n\t\tif (key in this) {\n\t\t\tthis[key] = $$new_props[key];\n\t\t}\n\t}\n}\n","/** @import { ComponentContext, ComponentContextLegacy } from '#client' */\n/** @import { EventDispatcher } from './index.js' */\n/** @import { NotFunction } from './internal/types.js' */\nimport { flush_sync, untrack } from './internal/client/runtime.js';\nimport { is_array } from './internal/shared/utils.js';\nimport { user_effect } from './internal/client/index.js';\nimport * as e from './internal/client/errors.js';\nimport { lifecycle_outside_component } from './internal/shared/errors.js';\nimport { legacy_mode_flag } from './internal/flags/index.js';\nimport { component_context } from './internal/client/context.js';\nimport { DEV } from 'esm-env';\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n\n/**\n * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.\n * It must be called during the component's initialisation (but doesn't need to live *inside* the component;\n * it can be called from an external module).\n *\n * If a function is returned _synchronously_ from `onMount`, it will be called when the component is unmounted.\n *\n * `onMount` does not run inside [server-side components](https://svelte.dev/docs/svelte/svelte-server#render).\n *\n * @template T\n * @param {() => NotFunction<T> | Promise<NotFunction<T>> | (() => any)} fn\n * @returns {void}\n */\nexport function onMount(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onMount');\n\t}\n\n\tif (legacy_mode_flag && component_context.l !== null) {\n\t\tinit_update_callbacks(component_context).m.push(fn);\n\t} else {\n\t\tuser_effect(() => {\n\t\t\tconst cleanup = untrack(fn);\n\t\t\tif (typeof cleanup === 'function') return /** @type {() => void} */ (cleanup);\n\t\t});\n\t}\n}\n\n/**\n * Schedules a callback to run immediately before the component is unmounted.\n *\n * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the\n * only one that runs inside a server-side component.\n *\n * @param {() => any} fn\n * @returns {void}\n */\nexport function onDestroy(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('onDestroy');\n\t}\n\n\tonMount(() => () => untrack(fn));\n}\n\n/**\n * @template [T=any]\n * @param {string} type\n * @param {T} [detail]\n * @param {any}params_0\n * @returns {CustomEvent<T>}\n */\nfunction create_custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {\n\treturn new CustomEvent(type, { detail, bubbles, cancelable });\n}\n\n/**\n * Creates an event dispatcher that can be used to dispatch [component events](https://svelte.dev/docs/svelte/legacy-on#Component-events).\n * Event dispatchers are functions that can take two arguments: `name` and `detail`.\n *\n * Component events created with `createEventDispatcher` create a\n * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).\n * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).\n * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)\n * property and can contain any type of data.\n *\n * The event dispatcher can be typed to narrow the allowed event names and the type of the `detail` argument:\n * ```ts\n * const dispatch = createEventDispatcher<{\n *  loaded: never; // does not take a detail argument\n *  change: string; // takes a detail argument of type string, which is required\n *  optional: number | null; // takes an optional detail argument of type number\n * }>();\n * ```\n *\n * @deprecated Use callback props and/or the `$host()` rune instead — see [migration guide](https://svelte.dev/docs/svelte/v5-migration-guide#Event-changes-Component-events)\n * @template {Record<string, any>} [EventMap = any]\n * @returns {EventDispatcher<EventMap>}\n */\nexport function createEventDispatcher() {\n\tconst active_component_context = component_context;\n\tif (active_component_context === null) {\n\t\tlifecycle_outside_component('createEventDispatcher');\n\t}\n\n\treturn (type, detail, options) => {\n\t\tconst events = /** @type {Record<string, Function | Function[]>} */ (\n\t\t\tactive_component_context.s.$$events\n\t\t)?.[/** @type {any} */ (type)];\n\n\t\tif (events) {\n\t\t\tconst callbacks = is_array(events) ? events.slice() : [events];\n\t\t\t// TODO are there situations where events could be dispatched\n\t\t\t// in a server (non-DOM) environment?\n\t\t\tconst event = create_custom_event(/** @type {string} */ (type), detail, options);\n\t\t\tfor (const fn of callbacks) {\n\t\t\t\tfn.call(active_component_context.x, event);\n\t\t\t}\n\t\t\treturn !event.defaultPrevented;\n\t\t}\n\n\t\treturn true;\n\t};\n}\n\n// TODO mark beforeUpdate and afterUpdate as deprecated in Svelte 6\n\n/**\n * Schedules a callback to run immediately before the component is updated after any state change.\n *\n * The first time the callback runs will be before the initial `onMount`.\n *\n * In runes mode use `$effect.pre` instead.\n *\n * @deprecated Use [`$effect.pre`](https://svelte.dev/docs/svelte/$effect#$effect.pre) instead\n * @param {() => void} fn\n * @returns {void}\n */\nexport function beforeUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('beforeUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('beforeUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).b.push(fn);\n}\n\n/**\n * Schedules a callback to run immediately after the component has been updated.\n *\n * The first time the callback runs will be after the initial `onMount`.\n *\n * In runes mode use `$effect` instead.\n *\n * @deprecated Use [`$effect`](https://svelte.dev/docs/svelte/$effect) instead\n * @param {() => void} fn\n * @returns {void}\n */\nexport function afterUpdate(fn) {\n\tif (component_context === null) {\n\t\tlifecycle_outside_component('afterUpdate');\n\t}\n\n\tif (component_context.l === null) {\n\t\te.lifecycle_legacy_only('afterUpdate');\n\t}\n\n\tinit_update_callbacks(component_context).a.push(fn);\n}\n\n/**\n * Legacy-mode: Init callbacks object for onMount/beforeUpdate/afterUpdate\n * @param {ComponentContext} context\n */\nfunction init_update_callbacks(context) {\n\tvar l = /** @type {ComponentContextLegacy} */ (context).l;\n\treturn (l.u ??= { a: [], b: [], m: [] });\n}\n\n/**\n * Synchronously flushes any pending state changes and those that result from it.\n * @param {() => void} [fn]\n * @returns {void}\n */\nexport function flushSync(fn) {\n\tflush_sync(fn);\n}\n\nexport { getContext, getAllContexts, hasContext, setContext } from './internal/client/context.js';\nexport { hydrate, mount, unmount } from './internal/client/render.js';\nexport { tick, untrack } from './internal/client/runtime.js';\nexport { createRawSnippet } from './internal/client/dom/blocks/snippet.js';\n","/** @import { StoreReferencesContainer } from '#client' */\n/** @import { Store } from '#shared' */\nimport { subscribe_to_store } from '../../../store/utils.js';\nimport { get as get_store } from '../../../store/shared/index.js';\nimport { define_property, noop } from '../../shared/utils.js';\nimport { get } from '../runtime.js';\nimport { teardown } from './effects.js';\nimport { mutable_source, set } from './sources.js';\n\n/**\n * Whether or not the prop currently being read is a store binding, as in\n * `<Child bind:x={$y} />`. If it is, we treat the prop as mutable even in\n * runes mode, and skip `binding_property_non_reactive` validation\n */\nlet is_store_binding = false;\n\nlet IS_UNMOUNTED = Symbol();\n\n/**\n * Gets the current value of a store. If the store isn't subscribed to yet, it will create a proxy\n * signal that will be updated when the store is. The store references container is needed to\n * track reassignments to stores and to track the correct component context.\n * @template V\n * @param {Store<V> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n * @returns {V}\n */\nexport function store_get(store, store_name, stores) {\n\tconst entry = (stores[store_name] ??= {\n\t\tstore: null,\n\t\tsource: mutable_source(undefined),\n\t\tunsubscribe: noop\n\t});\n\n\t// if the component that setup this is already unmounted we don't want to register a subscription\n\tif (entry.store !== store && !(IS_UNMOUNTED in stores)) {\n\t\tentry.unsubscribe();\n\t\tentry.store = store ?? null;\n\n\t\tif (store == null) {\n\t\t\tentry.source.v = undefined; // see synchronous callback comment below\n\t\t\tentry.unsubscribe = noop;\n\t\t} else {\n\t\t\tvar is_synchronous_callback = true;\n\n\t\t\tentry.unsubscribe = subscribe_to_store(store, (v) => {\n\t\t\t\tif (is_synchronous_callback) {\n\t\t\t\t\t// If the first updates to the store value (possibly multiple of them) are synchronously\n\t\t\t\t\t// inside a derived, we will hit the `state_unsafe_mutation` error if we `set` the value\n\t\t\t\t\tentry.source.v = v;\n\t\t\t\t} else {\n\t\t\t\t\tset(entry.source, v);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tis_synchronous_callback = false;\n\t\t}\n\t}\n\n\t// if the component that setup this stores is already unmounted the source will be out of sync\n\t// so we just use the `get` for the stores, less performant but it avoids to create a memory leak\n\t// and it will keep the value consistent\n\tif (store && IS_UNMOUNTED in stores) {\n\t\treturn get_store(store);\n\t}\n\n\treturn get(entry.source);\n}\n\n/**\n * Unsubscribe from a store if it's not the same as the one in the store references container.\n * We need this in addition to `store_get` because someone could unsubscribe from a store but\n * then never subscribe to the new one (if any), causing the subscription to stay open wrongfully.\n * @param {Store<any> | null | undefined} store\n * @param {string} store_name\n * @param {StoreReferencesContainer} stores\n */\nexport function store_unsub(store, store_name, stores) {\n\t/** @type {StoreReferencesContainer[''] | undefined} */\n\tlet entry = stores[store_name];\n\n\tif (entry && entry.store !== store) {\n\t\t// Don't reset store yet, so that store_get above can resubscribe to new store if necessary\n\t\tentry.unsubscribe();\n\t\tentry.unsubscribe = noop;\n\t}\n\n\treturn store;\n}\n\n/**\n * Sets the new value of a store and returns that value.\n * @template V\n * @param {Store<V>} store\n * @param {V} value\n * @returns {V}\n */\nexport function store_set(store, value) {\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * @param {StoreReferencesContainer} stores\n * @param {string} store_name\n */\nexport function invalidate_store(stores, store_name) {\n\tvar entry = stores[store_name];\n\tif (entry.store !== null) {\n\t\tstore_set(entry.store, entry.source.v);\n\t}\n}\n\n/**\n * Unsubscribes from all auto-subscribed stores on destroy\n * @returns {[StoreReferencesContainer, ()=>void]}\n */\nexport function setup_stores() {\n\t/** @type {StoreReferencesContainer} */\n\tconst stores = {};\n\n\tfunction cleanup() {\n\t\tteardown(() => {\n\t\t\tfor (var store_name in stores) {\n\t\t\t\tconst ref = stores[store_name];\n\t\t\t\tref.unsubscribe();\n\t\t\t}\n\t\t\tdefine_property(stores, IS_UNMOUNTED, {\n\t\t\t\tenumerable: false,\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t});\n\t}\n\n\treturn [stores, cleanup];\n}\n\n/**\n * Updates a store with a new value.\n * @param {Store<V>} store  the store to update\n * @param {any} expression  the expression that mutates the store\n * @param {V} new_value  the new store value\n * @template V\n */\nexport function store_mutate(store, expression, new_value) {\n\tstore.set(new_value);\n\treturn expression;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_store(store, store_value, d = 1) {\n\tstore.set(store_value + d);\n\treturn store_value;\n}\n\n/**\n * @param {Store<number>} store\n * @param {number} store_value\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_store(store, store_value, d = 1) {\n\tconst value = store_value + d;\n\tstore.set(value);\n\treturn value;\n}\n\n/**\n * Called inside prop getters to communicate that the prop is a store binding\n */\nexport function mark_store_binding() {\n\tis_store_binding = true;\n}\n\n/**\n * Returns a tuple that indicates whether `fn()` reads a prop that is a store binding.\n * Used to prevent `binding_property_non_reactive` validation false positives and\n * ensure that these props are treated as mutable even in runes mode\n * @template T\n * @param {() => T} fn\n * @returns {[T, boolean]}\n */\nexport function capture_store_binding(fn) {\n\tvar previous_is_store_binding = is_store_binding;\n\n\ttry {\n\t\tis_store_binding = false;\n\t\treturn [fn(), is_store_binding];\n\t} finally {\n\t\tis_store_binding = previous_is_store_binding;\n\t}\n}\n","/** @import { Source } from './types.js' */\nimport { DEV } from 'esm-env';\nimport {\n\tPROPS_IS_BINDABLE,\n\tPROPS_IS_IMMUTABLE,\n\tPROPS_IS_LAZY_INITIAL,\n\tPROPS_IS_RUNES,\n\tPROPS_IS_UPDATED\n} from '../../../constants.js';\nimport { get_descriptor, is_function } from '../../shared/utils.js';\nimport { mutable_source, set, source, update } from './sources.js';\nimport { derived, derived_safe_equal } from './deriveds.js';\nimport {\n\tactive_effect,\n\tget,\n\tcaptured_signals,\n\tset_active_effect,\n\tuntrack,\n\tactive_reaction,\n\tset_active_reaction\n} from '../runtime.js';\nimport { safe_equals } from './equality.js';\nimport * as e from '../errors.js';\nimport {\n\tBRANCH_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tLEGACY_PROPS,\n\tROOT_EFFECT,\n\tSTATE_SYMBOL\n} from '../constants.js';\nimport { proxy } from '../proxy.js';\nimport { capture_store_binding } from './store.js';\nimport { legacy_mode_flag } from '../../flags/index.js';\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_prop(fn, d = 1) {\n\tconst value = fn();\n\tfn(value + d);\n\treturn value;\n}\n\n/**\n * @param {((value?: number) => number)} fn\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre_prop(fn, d = 1) {\n\tconst value = fn() + d;\n\tfn(value);\n\treturn value;\n}\n\n/**\n * The proxy handler for rest props (i.e. `const { x, ...rest } = $props()`).\n * Is passed the full `$$props` object and excludes the named props.\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, name?: string }>}}\n */\nconst rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\treturn target.props[key];\n\t},\n\tset(target, key) {\n\t\tif (DEV) {\n\t\t\t// TODO should this happen in prod too?\n\t\t\te.props_rest_readonly(`${target.name}.${String(key)}`);\n\t\t}\n\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @param {string} [name]\n * @returns {Record<string, unknown>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function rest_props(props, exclude, name) {\n\treturn new Proxy(\n\t\tDEV ? { props, exclude, name, other: {}, to_proxy: [] } : { props, exclude },\n\t\trest_props_handler\n\t);\n}\n\n/**\n * The proxy handler for legacy $$restProps and $$props\n * @type {ProxyHandler<{ props: Record<string | symbol, unknown>, exclude: Array<string | symbol>, special: Record<string | symbol, (v?: unknown) => unknown>, version: Source<number> }>}}\n */\nconst legacy_rest_props_handler = {\n\tget(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tget(target.version);\n\t\treturn key in target.special ? target.special[key]() : target.props[key];\n\t},\n\tset(target, key, value) {\n\t\tif (!(key in target.special)) {\n\t\t\t// Handle props that can temporarily get out of sync with the parent\n\t\t\t/** @type {Record<string, (v?: unknown) => unknown>} */\n\t\t\ttarget.special[key] = prop(\n\t\t\t\t{\n\t\t\t\t\tget [key]() {\n\t\t\t\t\t\treturn target.props[key];\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t/** @type {string} */ (key),\n\t\t\t\tPROPS_IS_UPDATED\n\t\t\t);\n\t\t}\n\n\t\ttarget.special[key](value);\n\t\tupdate(target.version); // $$props is coarse-grained: when $$props.x is updated, usages of $$props.y etc are also rerun\n\t\treturn true;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tif (target.exclude.includes(key)) return;\n\t\tif (key in target.props) {\n\t\t\treturn {\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true,\n\t\t\t\tvalue: target.props[key]\n\t\t\t};\n\t\t}\n\t},\n\tdeleteProperty(target, key) {\n\t\t// Svelte 4 allowed for deletions on $$restProps\n\t\tif (target.exclude.includes(key)) return true;\n\t\ttarget.exclude.push(key);\n\t\tupdate(target.version);\n\t\treturn true;\n\t},\n\thas(target, key) {\n\t\tif (target.exclude.includes(key)) return false;\n\t\treturn key in target.props;\n\t},\n\townKeys(target) {\n\t\treturn Reflect.ownKeys(target.props).filter((key) => !target.exclude.includes(key));\n\t}\n};\n\n/**\n * @param {Record<string, unknown>} props\n * @param {string[]} exclude\n * @returns {Record<string, unknown>}\n */\nexport function legacy_rest_props(props, exclude) {\n\treturn new Proxy({ props, exclude, special: {}, version: source(0) }, legacy_rest_props_handler);\n}\n\n/**\n * The proxy handler for spread props. Handles the incoming array of props\n * that looks like `() => { dynamic: props }, { static: prop }, ..` and wraps\n * them so that the whole thing is passed to the component as the `$$props` argument.\n * @template {Record<string | symbol, unknown>} T\n * @type {ProxyHandler<{ props: Array<T | (() => T)> }>}}\n */\nconst spread_props_handler = {\n\tget(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) return p[key];\n\t\t}\n\t},\n\tset(target, key, value) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tconst desc = get_descriptor(p, key);\n\t\t\tif (desc && desc.set) {\n\t\t\t\tdesc.set(value);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\tgetOwnPropertyDescriptor(target, key) {\n\t\tlet i = target.props.length;\n\t\twhile (i--) {\n\t\t\tlet p = target.props[i];\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (typeof p === 'object' && p !== null && key in p) {\n\t\t\t\tconst descriptor = get_descriptor(p, key);\n\t\t\t\tif (descriptor && !descriptor.configurable) {\n\t\t\t\t\t// Prevent a \"Non-configurability Report Error\": The target is an array, it does\n\t\t\t\t\t// not actually contain this property. If it is now described as non-configurable,\n\t\t\t\t\t// the proxy throws a validation error. Setting it to true avoids that.\n\t\t\t\t\tdescriptor.configurable = true;\n\t\t\t\t}\n\t\t\t\treturn descriptor;\n\t\t\t}\n\t\t}\n\t},\n\thas(target, key) {\n\t\t// To prevent a false positive `is_entry_props` in the `prop` function\n\t\tif (key === STATE_SYMBOL || key === LEGACY_PROPS) return false;\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tif (p != null && key in p) return true;\n\t\t}\n\n\t\treturn false;\n\t},\n\townKeys(target) {\n\t\t/** @type {Array<string | symbol>} */\n\t\tconst keys = [];\n\n\t\tfor (let p of target.props) {\n\t\t\tif (is_function(p)) p = p();\n\t\t\tfor (const key in p) {\n\t\t\t\tif (!keys.includes(key)) keys.push(key);\n\t\t\t}\n\t\t}\n\n\t\treturn keys;\n\t}\n};\n\n/**\n * @param {Array<Record<string, unknown> | (() => Record<string, unknown>)>} props\n * @returns {any}\n */\nexport function spread_props(...props) {\n\treturn new Proxy({ props }, spread_props_handler);\n}\n\n/**\n * This function is responsible for synchronizing a possibly bound prop with the inner component state.\n * It is used whenever the compiler sees that the component writes to the prop, or when it has a default prop_value.\n * @template V\n * @param {Record<string, unknown>} props\n * @param {string} key\n * @param {number} flags\n * @param {V | (() => V)} [fallback]\n * @returns {(() => V | ((arg: V) => V) | ((arg: V, mutation: boolean) => V))}\n */\nexport function prop(props, key, flags, fallback) {\n\tvar immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;\n\tvar runes = !legacy_mode_flag || (flags & PROPS_IS_RUNES) !== 0;\n\tvar bindable = (flags & PROPS_IS_BINDABLE) !== 0;\n\tvar lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;\n\tvar is_store_sub = false;\n\tvar prop_value;\n\n\tif (bindable) {\n\t\t[prop_value, is_store_sub] = capture_store_binding(() => /** @type {V} */ (props[key]));\n\t} else {\n\t\tprop_value = /** @type {V} */ (props[key]);\n\t}\n\n\t// Can be the case when someone does `mount(Component, props)` with `let props = $state({...})`\n\t// or `createClassComponent(Component, props)`\n\tvar is_entry_props = STATE_SYMBOL in props || LEGACY_PROPS in props;\n\n\tvar setter =\n\t\t(bindable &&\n\t\t\t(get_descriptor(props, key)?.set ??\n\t\t\t\t(is_entry_props && key in props && ((v) => (props[key] = v))))) ||\n\t\tundefined;\n\n\tvar fallback_value = /** @type {V} */ (fallback);\n\tvar fallback_dirty = true;\n\tvar fallback_used = false;\n\n\tvar get_fallback = () => {\n\t\tfallback_used = true;\n\t\tif (fallback_dirty) {\n\t\t\tfallback_dirty = false;\n\t\t\tif (lazy) {\n\t\t\t\tfallback_value = untrack(/** @type {() => V} */ (fallback));\n\t\t\t} else {\n\t\t\t\tfallback_value = /** @type {V} */ (fallback);\n\t\t\t}\n\t\t}\n\n\t\treturn fallback_value;\n\t};\n\n\tif (prop_value === undefined && fallback !== undefined) {\n\t\tif (setter && runes) {\n\t\t\te.props_invalid_value(key);\n\t\t}\n\n\t\tprop_value = get_fallback();\n\t\tif (setter) setter(prop_value);\n\t}\n\n\t/** @type {() => V} */\n\tvar getter;\n\tif (runes) {\n\t\tgetter = () => {\n\t\t\tvar value = /** @type {V} */ (props[key]);\n\t\t\tif (value === undefined) return get_fallback();\n\t\t\tfallback_dirty = true;\n\t\t\tfallback_used = false;\n\t\t\treturn value;\n\t\t};\n\t} else {\n\t\t// Svelte 4 did not trigger updates when a primitive value was updated to the same value.\n\t\t// Replicate that behavior through using a derived\n\t\tvar derived_getter = (immutable ? derived : derived_safe_equal)(\n\t\t\t() => /** @type {V} */ (props[key])\n\t\t);\n\t\tderived_getter.f |= LEGACY_DERIVED_PROP;\n\t\tgetter = () => {\n\t\t\tvar value = get(derived_getter);\n\t\t\tif (value !== undefined) fallback_value = /** @type {V} */ (undefined);\n\t\t\treturn value === undefined ? fallback_value : value;\n\t\t};\n\t}\n\n\t// easy mode — prop is never written to\n\tif ((flags & PROPS_IS_UPDATED) === 0) {\n\t\treturn getter;\n\t}\n\n\t// intermediate mode — prop is written to, but the parent component had\n\t// `bind:foo` which means we can just call `$$props.foo = value` directly\n\tif (setter) {\n\t\tvar legacy_parent = props.$$legacy;\n\t\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t\tif (arguments.length > 0) {\n\t\t\t\t// We don't want to notify if the value was mutated and the parent is in runes mode.\n\t\t\t\t// In that case the state proxy (if it exists) should take care of the notification.\n\t\t\t\t// If the parent is not in runes mode, we need to notify on mutation, too, that the prop\n\t\t\t\t// has changed because the parent will not be able to detect the change otherwise.\n\t\t\t\tif (!runes || !mutation || legacy_parent || is_store_sub) {\n\t\t\t\t\t/** @type {Function} */ (setter)(mutation ? getter() : value);\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t} else {\n\t\t\t\treturn getter();\n\t\t\t}\n\t\t};\n\t}\n\n\t// hard mode. this is where it gets ugly — the value in the child should\n\t// synchronize with the parent, but it should also be possible to temporarily\n\t// set the value to something else locally.\n\tvar from_child = false;\n\tvar was_from_child = false;\n\n\t// The derived returns the current value. The underlying mutable\n\t// source is written to from various places to persist this value.\n\tvar inner_current_value = mutable_source(prop_value);\n\tvar current_value = derived(() => {\n\t\tvar parent_value = getter();\n\t\tvar child_value = get(inner_current_value);\n\n\t\tif (from_child) {\n\t\t\tfrom_child = false;\n\t\t\twas_from_child = true;\n\t\t\treturn child_value;\n\t\t}\n\n\t\twas_from_child = false;\n\t\treturn (inner_current_value.v = parent_value);\n\t});\n\n\tif (!immutable) current_value.equals = safe_equals;\n\n\treturn function (/** @type {any} */ value, /** @type {boolean} */ mutation) {\n\t\t// legacy nonsense — need to ensure the source is invalidated when necessary\n\t\t// also needed for when handling inspect logic so we can inspect the correct source signal\n\t\tif (captured_signals !== null) {\n\t\t\t// set this so that we don't reset to the parent value if `d`\n\t\t\t// is invalidated because of `invalidate_inner_signals` (rather\n\t\t\t// than because the parent or child value changed)\n\t\t\tfrom_child = was_from_child;\n\t\t\t// invoke getters so that signals are picked up by `invalidate_inner_signals`\n\t\t\tgetter();\n\t\t\tget(inner_current_value);\n\t\t}\n\n\t\tif (arguments.length > 0) {\n\t\t\tconst new_value = mutation ? get(current_value) : runes && bindable ? proxy(value) : value;\n\n\t\t\tif (!current_value.equals(new_value)) {\n\t\t\t\tfrom_child = true;\n\t\t\t\tset(inner_current_value, new_value);\n\t\t\t\t// To ensure the fallback value is consistent when used with proxies, we\n\t\t\t\t// update the local fallback_value, but only if the fallback is actively used\n\t\t\t\tif (fallback_used && fallback_value !== undefined) {\n\t\t\t\t\tfallback_value = new_value;\n\t\t\t\t}\n\t\t\t\tuntrack(() => get(current_value)); // force a synchronisation immediately\n\t\t\t}\n\n\t\t\treturn value;\n\t\t}\n\t\treturn get(current_value);\n\t};\n}\n","/**\n * Create a lightweight debug function to log output into the browser console.\n *\n * Inspired by https://github.com/visionmedia/debug (some code is copied below)\n *\n * Usage:\n *\n *     import { createDebug } from './debug.js'\n *\n *     const debug = createDebug('my:namespace')\n *\n *     debug('testing:', 2 + 2)\n *\n * By default, logging is only enabled when a property DEBUG is set in the\n * localStorage of your browser:\n *\n *     localStorage['debug'] = '*'\n *     localStorage['debug'] = 'jsoneditor:*'\n *     localStorage['debug'] = 'jsoneditor:TreeMode'\n *\n * The actual value of 'debug' is used to filter the debug messages.\n * The value can end with a '*' wild card to match any remaining text.\n *\n * By providing a value for `enabled`, you can choose conditions to\n * enable/disable debugging if you want, for example some flag determining\n * whether in development or production.\n */\nexport function createDebug(\n  namespace: string,\n  enabled = enableDebug(namespace)\n): (...args: unknown[]) => void {\n  if (!enabled) {\n    return noop\n  }\n\n  const color = selectColor(namespace)\n\n  return function debug(...args) {\n    console.log(`%c${namespace}`, `color:${color}`, ...args)\n  }\n}\n\nfunction enableDebug(namespace: string) {\n  const debug = tryReadLocalStorage('debug')\n\n  return debug?.endsWith('*') ? namespace.startsWith(debug.slice(0, -1)) : namespace === debug\n}\n\nfunction noop() {\n  // no operation\n}\n\n/**\n * Try read a specific key from localStorage\n */\nfunction tryReadLocalStorage(key: string): string | undefined {\n  try {\n    if (typeof window !== 'undefined' && typeof window.localStorage !== 'undefined') {\n      // reading local storage can fail for example because of security restrictions\n      return window.localStorage[key]\n    }\n  } catch {\n    // we do nothing with the error, not needed in this specific case\n  }\n\n  return undefined\n}\n\n/**\n * Selects a color for a debug namespace\n *\n * Code is copied from the following source: https://github.com/visionmedia/debug\n *\n * @param namespace The namespace string for the debug instance to be colored\n * @return An ANSI color code for the given namespace\n */\nfunction selectColor(namespace: string): string {\n  let hash = 0\n\n  for (let i = 0; i < namespace.length; i++) {\n    hash = (hash << 5) - hash + namespace.charCodeAt(i)\n    hash |= 0 // Convert to 32bit integer\n  }\n\n  return colors[Math.abs(hash) % colors.length]\n}\n\nconst colors = [\n  '#0000CC',\n  '#0099FF',\n  '#009400',\n  '#8dd200',\n  '#CCCC00',\n  '#CC9933',\n  '#ae04e7',\n  '#ff35d7',\n  '#FF3333',\n  '#FF6600',\n  '#FF9933',\n  '#FFCC33'\n]\n","let id = 0\n\nexport function uniqueId(): number {\n  id++\n  return id\n}\n","export function int(value: string): number {\n  return parseInt(value, 10)\n}\n\nexport function isDigit(char: string): boolean {\n  return DIGIT_REGEX.test(char)\n}\n\nconst DIGIT_REGEX = /^[0-9]$/\n\n// TODO: unit test\nexport function containsNumber(value: string): boolean {\n  return NUMBER_REGEX.test(value)\n}\n\nconst NUMBER_REGEX = /^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/\n","// TODO: unit test typeUtils.js\n\nimport { containsNumber } from './numberUtils.js'\nimport type { JSONParser } from '../types.js'\n\n/**\n * Test whether a value is an Object (and not an Array or Class)\n */\nexport function isObject(value: unknown): value is Record<string, unknown> {\n  // note that we check constructor.name, not constructor === Object,\n  // so we can use objects created in a different JS realm like an iframe.\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value.constructor === undefined || value.constructor.name === 'Object')\n  )\n}\n\n/**\n * Test whether a value is an Object or an Array (and not a Class)\n */\nexport function isObjectOrArray(value: unknown): value is object | Array<unknown> {\n  // Note that we check constructor.name, not constructor === Object,\n  // so we can use objects created in a different JS realm like an iframe.\n  return (\n    typeof value === 'object' &&\n    value !== null &&\n    (value.constructor === undefined ||\n      value.constructor.name === 'Object' ||\n      value.constructor.name === 'Array')\n  )\n}\n\n/**\n * Test whether a value is a boolean\n *\n * @param {*} value\n * @return {boolean}\n */\nexport function isBoolean(value: unknown): value is boolean {\n  return value === true || value === false\n}\n\n/**\n * Test whether a value is a timestamp in milliseconds after the year 2000.\n */\nexport function isTimestamp(value: unknown): boolean {\n  const YEAR_2000 = 946684800000\n\n  if (typeof value === 'number') {\n    return (\n      value > YEAR_2000 &&\n      isFinite(value) &&\n      Math.floor(value) === value &&\n      !isNaN(new Date(value).valueOf())\n    )\n  }\n\n  if (typeof value === 'bigint') {\n    return isTimestamp(Number(value))\n  }\n\n  // try getting the primitive value if that is different. For example when having a LosslessNumber\n  try {\n    const valueOf = value ? value.valueOf() : value\n    if (valueOf !== value) {\n      return isTimestamp(valueOf)\n    }\n  } catch {\n    return false\n  }\n\n  return false\n}\n\n/**\n * Get the applied color given a color name or code\n * Returns the color if the input is a valid color, and returns null otherwise.\n *\n * Example output:\n *\n *     'rgba(255,0,0,0.7)' or 'rgb(255,0,0)'\n *\n * Source: https://stackoverflow.com/questions/6386090/validating-css-color-names/33184805\n */\nexport function getColorCSS(color: string): string | undefined {\n  colorTestDiv = colorTestDiv || window.document.createElement('div')\n\n  colorTestDiv.style.color = ''\n  colorTestDiv.style.color = color\n\n  const applied = colorTestDiv.style.color\n  return applied !== '' ? applied.replace(/\\s+/g, '').toLowerCase() : undefined\n}\nlet colorTestDiv: HTMLDivElement | undefined = undefined\n\n/**\n * Test if a string contains a valid color name or code.\n * Returns true if a valid color, false otherwise\n */\nexport function isColor(value: unknown): boolean {\n  const maxColorLength = 99\n  return typeof value === 'string' && value.length < maxColorLength && !!getColorCSS(value)\n}\n\n/**\n * Get the type of the value\n */\nexport function valueType(value: unknown, parser: JSONParser): string {\n  // primitive types\n  if (\n    typeof value === 'number' ||\n    typeof value === 'string' ||\n    typeof value === 'boolean' ||\n    typeof value === 'undefined'\n  ) {\n    return typeof value\n  }\n  if (typeof value === 'bigint') {\n    return 'number' // we return number here, not bigint: all numeric types should return the same name\n  }\n  if (value === null) {\n    return 'null'\n  }\n\n  if (Array.isArray(value)) {\n    return 'array'\n  }\n  if (isObject(value)) {\n    // plain object only\n    return 'object'\n  }\n\n  // unknown type (like a LosslessNumber). Try out what stringfying results in\n  const valueStr = parser.stringify(value)\n  if (valueStr && containsNumber(valueStr)) {\n    return 'number'\n  }\n  if (valueStr === 'true' || valueStr === 'false') {\n    return 'boolean'\n  }\n  if (valueStr === 'null') {\n    return 'null'\n  }\n\n  return 'unknown'\n}\n\n/**\n * Test whether a text contains a url (matches when a string starts\n * with 'http://*' or 'https://*' and has no whitespace characters)\n */\nconst isUrlRegex = /^https?:\\/\\/\\S+$/\nexport function isUrl(text: unknown): boolean {\n  return typeof text === 'string' && isUrlRegex.test(text)\n}\n\n/**\n * Convert contents of a string to the correct JSON type. This can be a string,\n * a number, a boolean, etc\n */\nexport function stringConvert(str: string, parser: JSONParser): unknown {\n  if (str === '') {\n    return ''\n  }\n\n  const strTrim = str.trim()\n\n  if (strTrim === 'null') {\n    return null\n  }\n\n  if (strTrim === 'true') {\n    return true\n  }\n\n  if (strTrim === 'false') {\n    return false\n  }\n\n  if (containsNumber(strTrim)) {\n    return parser.parse(strTrim)\n  }\n\n  return str\n}\n\n/**\n * Test whether a string contains a numeric, boolean, or null value.\n * Returns true when the string contains a number, boolean, or null.\n */\nexport function isStringContainingPrimitiveValue(str: unknown): boolean {\n  // note that we can safely use JSON parser here instead of the configured JSONParser,\n  // since we do not actually use the parsed number, just want to check that it is not a string\n  return typeof str === 'string' && typeof stringConvert(str, JSON) !== 'string'\n}\n\n/**\n * Test whether a string contains an integer number\n */\nexport function isInteger(value: string): boolean {\n  return INTEGER_REGEX.test(value)\n}\n\nconst INTEGER_REGEX = /^-?[0-9]+$/\n","import { isObject } from './typeUtils.js'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, parseJSONPointer } from 'immutable-json-patch'\nimport { isEqual } from 'lodash-es'\n\nconst MAX_ITEM_PATHS_COLLECTION = 10000\nconst ROOT_PATH: JSONPath = []\n\n/**\n * Comparator to sort an array in ascending order\n *\n * Usage:\n *     [4,2,5].sort(compareAsc)    // [2,4,5]\n */\nexport function compareAsc<T>(a: T, b: T): number {\n  return a > b ? 1 : a < b ? -1 : 0\n}\n\n/**\n * Comparator to sort an array in ascending order\n *\n * Usage:\n *     [4,2,5].sort(compareDesc)   // [5,4,2]\n */\nexport function compareDesc<T>(a: T, b: T): number {\n  return a > b ? -1 : a < b ? 1 : 0\n}\n\n/**\n * Test whether all items of an array are strictly equal\n */\nexport function strictShallowEqual<T>(a: Array<T>, b: Array<T>): boolean {\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function compareArrays<T>(a: Array<T>, b: Array<T>): number {\n  const minLength = Math.min(a.length, b.length)\n\n  for (let i = 0; i < minLength; i++) {\n    if (a[i] < b[i]) {\n      return -1\n    }\n\n    if (a[i] > b[i]) {\n      return 1\n    }\n  }\n\n  return a.length - b.length\n}\n\n/**\n * Get the paths of all nested properties in the items of an array\n * @param array\n * @param includeObjects If true, object and array paths are returned as well\n */\nexport function getNestedPaths(array: unknown, includeObjects = false): JSONPath[] {\n  const pointersMap: Record<string, boolean> = {}\n\n  if (!Array.isArray(array)) {\n    throw new TypeError('Array expected')\n  }\n\n  function recurseNestedPaths(obj: unknown, path: JSONPath) {\n    const isValue = !Array.isArray(obj) && !isObject(obj)\n\n    if (isValue || (includeObjects && path.length > 0)) {\n      pointersMap[compileJSONPointer(path)] = true\n    }\n\n    if (isObject(obj)) {\n      Object.keys(obj).forEach((key) => {\n        recurseNestedPaths(obj[key], path.concat(key))\n      })\n    }\n  }\n\n  const max = Math.min(array.length, MAX_ITEM_PATHS_COLLECTION)\n  for (let i = 0; i < max; i++) {\n    const item = array[i]\n    recurseNestedPaths(item, ROOT_PATH)\n  }\n\n  const pathsArray = Object.keys(pointersMap).sort()\n\n  return pathsArray.map(parseJSONPointer)\n}\n\n/**\n * Invoke the callback with\n * @param start   Included start index\n * @param end       Excluded end index. End must be larger or equal to start\n * @param iteratee\n */\n// TODO: write tests\nexport function forEachIndex(start: number, end: number, iteratee: (index: number) => void) {\n  if (end <= start) {\n    return\n  }\n\n  for (let index = start; index < end; index++) {\n    iteratee(index)\n  }\n}\n\n/**\n * Limit the number of items in an array\n */\n// TODO: write unit test\nexport function limit<T>(array: Array<T>, max: number): Array<T> {\n  return array.length > max ? array.slice(0, max) : array\n}\n\n/**\n * Convert an array into an object having the array indices as keys\n */\nexport function arrayToObject<T>(array: Array<T>): Record<number, T> {\n  return {\n    ...array\n  }\n}\n\n/**\n * Get the values of an object as an array\n */\nexport function objectToArray<T>(object: Record<string, T>): Array<T> {\n  return Object.values(object)\n}\n\n/**\n * Test whether an array starts with a sub array\n */\nexport function arrayStartsWith<T>(\n  array: T[],\n  searchArray: T[],\n  equal: (a: T, b: T) => boolean = isEqual\n): boolean {\n  for (let i = 0; i < searchArray.length; i++) {\n    if (!equal(array[i], searchArray[i])) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * Move a set of items inside an array\n */\nexport function moveItems<T>(array: T[], index: number, count: number, offset: number): T[] {\n  // TODO: check boundaries: index+offset >= 0, index+offset+count<array.length, index+count<array.length, etc\n  const copy = array.slice(0)\n  const moving: T[] = copy.splice(index, count)\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  copy.splice.apply(copy, [index + offset, 0, ...moving])\n  return copy\n}\n\n/**\n * Take samples out of a large array, equally spread from start till end\n */\nexport function forEachSample<T>(\n  array: T[],\n  maxSampleCount: number,\n  callback: (item: T, index: number, array: T[]) => void\n) {\n  if (array.length < maxSampleCount) {\n    array.forEach(callback)\n  } else {\n    const step = maxSampleCount > 1 ? (array.length - 1) / (maxSampleCount - 1) : array.length\n    for (let i = 0; i < maxSampleCount; i++) {\n      const index = Math.floor(i * step)\n      callback(array[index], index, array)\n    }\n  }\n}\n\nexport function insertItemsAt<T>(array: T[], index: number, items: T[]): T[] {\n  return array.slice(0, index).concat(items).concat(array.slice(index))\n}\n\n/**\n * Remove duplicate entries from an array, keeping the last item in case of a duplicate.\n * This is similar to the `uniqWith` function of Lodash, but that function keeps the *first* item in case of a duplicate.\n */\nexport function dedupeKeepLast<T>(array: T[], comparator: (a: T, b: T) => boolean = isEqual): T[] {\n  return array.filter((item, index) => {\n    for (let i = index + 1; i < array.length; i++) {\n      if (comparator(item, array[i])) {\n        return false\n      }\n    }\n\n    return true\n  })\n}\n","import type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer } from 'immutable-json-patch'\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport jsonSourceMap from 'json-source-map'\nimport { jsonrepair } from 'jsonrepair'\nimport { isObject, isObjectOrArray, valueType } from './typeUtils.js'\nimport { arrayToObject, objectToArray } from './arrayUtils.js'\nimport type {\n  Content,\n  JSONContent,\n  JSONParser,\n  ParseError,\n  TextContent,\n  TextLocation\n} from '../types'\nimport { int } from './numberUtils.js'\n\n/**\n * Parse the JSON. if this fails, try to repair and parse.\n * Throws an exception when the JSON is invalid and could not be parsed.\n */\nexport function parseAndRepair(jsonText: string, parser: JSONParser): unknown {\n  try {\n    return parser.parse(jsonText)\n  } catch {\n    // this can also throw\n    return parser.parse(jsonrepair(jsonText))\n  }\n}\n\n/**\n * Parse the JSON and if needed repair it.\n * When not valid, undefined is returned.\n */\nexport function parseAndRepairOrUndefined(\n  partialJson: string,\n  parser: JSONParser\n): unknown | undefined {\n  try {\n    return parseAndRepair(partialJson, parser)\n  } catch {\n    return undefined\n  }\n}\n\n// TODO: deduplicate the logic in repairPartialJson and parseAndRepairPartialJson ?\nexport function parsePartialJson(partialJson: string, parse: (text: string) => unknown): unknown {\n  // for now: dumb brute force approach: simply try out a few things...\n\n  // remove trailing comma\n  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '')\n\n  try {\n    return parse(partialJson)\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    return parse('{' + partialJson + '}')\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    return parse('[' + partialJson + ']')\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  throw new Error('Failed to parse partial JSON')\n}\n\n/**\n * Repair partial JSON\n */\nexport function repairPartialJson(partialJson: string): string {\n  // for now: dumb brute force approach: simply try out a few things...\n\n  // remove trailing comma\n  partialJson = partialJson.replace(END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX, '')\n\n  try {\n    return jsonrepair(partialJson)\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    const repaired = jsonrepair('[' + partialJson + ']')\n    return repaired.substring(1, repaired.length - 1) // remove the outer [...] again\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  try {\n    const repaired = jsonrepair('{' + partialJson + '}')\n    return repaired.substring(1, repaired.length - 1) // remove the outer {...} again\n  } catch {\n    // we ignore the error on purpose\n  }\n\n  throw new Error('Failed to repair partial JSON')\n}\n\n// test whether a string ends with a comma, followed by zero or more white space characters\nconst END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX = /,\\s*$/\n\n/**\n * Normalize a parse error message like\n *     \"Unexpected token i in JSON at position 4\"\n * or\n *     \"JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data\"\n * and return the line and column numbers in an object\n *\n * Note that the returned line and column number in the object are zero-based,\n * and in the message are one based (human-readable)\n */\nexport function normalizeJsonParseError(jsonText: string, parseErrorMessage: string): ParseError {\n  const positionMatch = POSITION_REGEX.exec(parseErrorMessage)\n\n  if (positionMatch) {\n    // a message from Chrome, like \"Unexpected token i in JSON at line 2 column 3\"\n    const position = int(positionMatch[2])\n\n    const line = countCharacterOccurrences(jsonText, '\\n', 0, position)\n    const lastIndex = jsonText.lastIndexOf('\\n', position)\n    const column = position - lastIndex - 1\n\n    return {\n      position,\n      line,\n      column,\n      message: parseErrorMessage.replace(POSITION_REGEX, () => {\n        return `line ${line + 1} column ${column + 1}`\n      })\n    }\n  } else {\n    // a message from Firefox, like \"JSON.parse: expected property name or '}' at line 2 column 3 of the JSON data\"\n    const lineMatch = LINE_REGEX.exec(parseErrorMessage)\n    const lineOneBased = lineMatch ? int(lineMatch[1]) : undefined\n    const line = lineOneBased !== undefined ? lineOneBased - 1 : undefined\n\n    const columnMatch = COLUMN_REGEX.exec(parseErrorMessage)\n    const columnOneBased = columnMatch ? int(columnMatch[1]) : undefined\n    const column = columnOneBased !== undefined ? columnOneBased - 1 : undefined\n\n    const position =\n      line !== undefined && column !== undefined\n        ? calculatePosition(jsonText, line, column)\n        : undefined\n\n    // line and column are one based in the message\n    return {\n      position,\n      line,\n      column,\n      message: parseErrorMessage.replace(/^JSON.parse: /, '').replace(/ of the JSON data$/, '')\n    }\n  }\n}\n\n/**\n * Calculate the position in the text based on a line and column number\n * @param text\n * @param line     Zero-based line number\n * @param column   Zero-based column number\n */\nexport function calculatePosition(text: string, line: number, column: number): number | undefined {\n  let index = text.indexOf('\\n')\n  let i = 1\n\n  while (i < line && index !== -1) {\n    index = text.indexOf('\\n', index + 1)\n    i++\n  }\n\n  return index !== -1\n    ? index + column + 1 // +1 for the return character itself\n    : undefined\n}\n\nexport function countCharacterOccurrences(\n  text: string,\n  character: string,\n  start = 0,\n  end = text.length\n) {\n  let count = 0\n\n  for (let i = start; i < end; i++) {\n    if (text.charAt(i) === character) {\n      count++\n    }\n  }\n\n  return count\n}\n\n/**\n * Find the text location of a JSON path\n */\n// TODO: write unit tests\nexport function findTextLocation(text: string, path: JSONPath): TextLocation {\n  try {\n    const jsmap = jsonSourceMap.parse(text)\n\n    const pointerName = compileJSONPointer(path)\n    const pointer = jsmap.pointers[pointerName]\n    if (pointer) {\n      return {\n        path,\n        line: pointer.key ? pointer.key.line : pointer.value ? pointer.value.line : 0,\n        column: pointer.key ? pointer.key.column : pointer.value ? pointer.value.column : 0,\n        from: pointer.key ? pointer.key.pos : pointer.value ? pointer.value.pos : 0,\n        to: pointer.keyEnd ? pointer.keyEnd.pos : pointer.valueEnd ? pointer.valueEnd.pos : 0\n      }\n    }\n  } catch (err) {\n    console.error(err)\n  }\n\n  return {\n    path,\n    line: 0,\n    column: 0,\n    from: 0,\n    to: 0\n  }\n}\n\n/**\n * Convert a JSON object, array, or value to another type\n * If it cannot be converted, an error is thrown\n */\nexport function convertValue(\n  value: unknown,\n  type: 'value' | 'object' | 'array',\n  parser: JSONParser\n): unknown {\n  // FIXME: improve the TypeScript here, there are a couple of conversions\n  if (type === 'array') {\n    if (Array.isArray(value)) {\n      // nothing to do\n      return value\n    }\n\n    if (isObject(value)) {\n      return objectToArray(value)\n    }\n\n    if (typeof value === 'string') {\n      try {\n        const parsedValue = parser.parse(value)\n\n        if (Array.isArray(parsedValue)) {\n          return parsedValue\n        }\n\n        if (isObject(parsedValue)) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          return objectToArray(parsedValue)\n        }\n      } catch {\n        //we could not parse the string, so we return the string as the first key of the array\n        return [value]\n      }\n    }\n\n    //all other cases, we return the value as the first key of the array, same as the parsing error under the string case\n    return [value]\n  }\n\n  if (type === 'object') {\n    if (Array.isArray(value)) {\n      return arrayToObject(value)\n    }\n\n    if (isObject(value)) {\n      // nothing to do\n      return value\n    }\n\n    if (typeof value === 'string') {\n      try {\n        const parsedValue = parser.parse(value)\n\n        if (isObject(parsedValue)) {\n          return parsedValue\n        }\n\n        if (Array.isArray(parsedValue)) {\n          return arrayToObject(parsedValue)\n        }\n      } catch {\n        //we could not parse the string, so we return the string as the first value of the object with key 'value'\n        return { value: value }\n      }\n    }\n\n    //all other cases, we return the value keyed under \"value\", same as the parsing error under the string case\n    return { value: value }\n  }\n\n  if (type === 'value') {\n    if (isObjectOrArray(value)) {\n      return parser.stringify(value)\n    }\n\n    // nothing to do\n    return value\n  }\n\n  throw new Error(`Cannot convert ${valueType(value, parser)} to ${type}`)\n}\n\n/**\n * Check whether provided value is valid a content type for JSONEditor\n * Returns a string with validation error message when there is an issue,\n * or null otherwise\n */\nexport function validateContentType(content: unknown): string | undefined {\n  if (!isObject(content)) {\n    return 'Content must be an object'\n  }\n\n  if (content.json !== undefined) {\n    if (content.text !== undefined) {\n      return 'Content must contain either a property \"json\" or a property \"text\" but not both'\n    } else {\n      return undefined\n    }\n  } else {\n    if (content.text === undefined) {\n      return 'Content must contain either a property \"json\" or a property \"text\"'\n    } else if (typeof content.text !== 'string') {\n      return (\n        'Content \"text\" property must be a string containing a JSON document. ' +\n        'Did you mean to use the \"json\" property instead?'\n      )\n    } else {\n      return undefined\n    }\n  }\n}\n\n/**\n * Check whether a value is Content (TextContent or JSONContent)\n */\nexport function isContent(content: unknown): content is Content {\n  return (\n    isObject(content) && (typeof content.json !== 'undefined' || typeof content.text === 'string')\n  )\n}\n\n/**\n * Check whether content contains text (and not JSON)\n */\nexport function isTextContent(content: unknown): content is TextContent {\n  return isObject(content) && typeof content.text === 'string'\n}\n\n/**\n * Check whether content contains json\n */\nexport function isJSONContent(content: unknown): content is JSONContent {\n  return isObject(content) && typeof content.json !== 'undefined'\n}\n\n/**\n * Convert Content into TextContent if it is JSONContent, else leave it as is\n */\nexport function toTextContent(\n  content: Content,\n  indentation: number | string | undefined = undefined,\n  parser: JSONParser = JSON\n): TextContent {\n  return isTextContent(content)\n    ? content\n    : { text: parser.stringify(content.json, null, indentation) as string }\n}\n\n/**\n * Convert Content into TextContent if it is JSONContent, else leave it as is\n * @throws {SyntaxError} Will throw a parse error when the text contents does not contain valid JSON\n */\nexport function toJSONContent(content: Content, parser: JSONParser = JSON): JSONContent {\n  return isJSONContent(content) ? content : { json: parser.parse(content.text) }\n}\n\n/**\n * Get the contents as Text. If the contents is JSON, the JSON will be parsed.\n */\nexport function getText(content: Content, indentation: number | string, parser: JSONParser) {\n  return toTextContent(content, indentation, parser).text\n}\n\n/**\n * Returns true when the (estimated) size of the contents exceeds the\n * provided maxSize.\n * @param content\n * @param maxSize  Maximum content size in bytes\n */\nexport function isLargeContent(content: Content, maxSize: number): boolean {\n  return estimateSerializedSize(content, maxSize) > maxSize\n}\n\n/**\n * A rough, fast estimation on whether a document is larger than given size\n * when serialized.\n *\n * maxSize is an optional max size in bytes. When reached, size estimation will\n * be cancelled. This is useful when you're only interested in knowing whether\n * the size exceeds a certain maximum size.\n */\nexport function estimateSerializedSize(content: Content, maxSize = Infinity): number {\n  if (isTextContent(content)) {\n    return content.text.length\n  }\n\n  const json = content.json\n\n  let estimatedSize = 0\n\n  function recurse(json: unknown) {\n    if (Array.isArray(json)) {\n      // open and close bracket, commas between items\n      estimatedSize += 2 + (json.length - 1)\n\n      if (estimatedSize > maxSize) {\n        return\n      }\n\n      for (let i = 0; i < json.length; i++) {\n        const item = json[i]\n\n        recurse(item)\n\n        if (estimatedSize > maxSize) {\n          return\n        }\n      }\n    } else if (isObject(json)) {\n      const keys = Object.keys(json)\n\n      // open and close brackets, separators between all keys and values, comma's between key/value pairs\n      estimatedSize += 2 + keys.length + (keys.length - 1)\n\n      for (let k = 0; k < keys.length; k++) {\n        const key = keys[k]\n        const value = json[key]\n\n        // key length and double quotes around it\n        estimatedSize += key.length + 2\n\n        recurse(value)\n      }\n    } else if (typeof json === 'string') {\n      estimatedSize += json.length + 2 // string length plus two for the double quote characters\n    } else {\n      // true, false, null, number\n      estimatedSize += String(json).length\n    }\n  }\n\n  recurse(json)\n\n  return estimatedSize\n}\n\nconst POSITION_REGEX = /(position|char) (\\d+)/\nconst LINE_REGEX = /line (\\d+)/\nconst COLUMN_REGEX = /column (\\d+)/\n\n/**\n * Check whether the actual functions of parse and stringify are strictly equal.\n * The object holding the functions may be a differing instance.\n */\nexport function isEqualParser(a: JSONParser, b: JSONParser): boolean {\n  return a.parse === b.parse && a.stringify === b.stringify\n}\n\n/**\n * Apply a fast and cheap heuristic to determine whether the content needs formatting (i.e. is compact).\n */\nexport function needsFormatting(jsonText: string): boolean {\n  const maxLength = 999\n  const head = jsonText.substring(0, maxLength).trim()\n  return !head.includes('\\n') && DELIMITER_WITHOUT_SPACING_REGEX.test(head)\n}\n\n// This regex matches cases of a comma or colon NOT followed by a whitespace\nconst DELIMITER_WITHOUT_SPACING_REGEX = /[,:]\\S/\n","import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\nimport type { SvelteComponent } from 'svelte'\nimport type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\nimport type { Action } from 'svelte/action'\n\nexport type TextContent = { text: string }\n\nexport type JSONContent = { json: unknown }\n\nexport type Content = JSONContent | TextContent\n\n// The `JSONParser` interface is compatible with `JSON`,\n// except that JSON.stringify is wrongly defined to return a string whilst it can return a string or undefined\n// see: https://stackoverflow.com/questions/74461780/is-the-official-type-definition-for-json-stringify-wrong\nexport interface JSONParser {\n  parse(\n    text: string,\n    reviver?: ((this: unknown, key: string, value: unknown) => unknown) | null\n  ): unknown\n\n  stringify(\n    value: unknown,\n    replacer?:\n      | ((this: unknown, key: string, value: unknown) => unknown)\n      | Array<number | string>\n      | null,\n    space?: string | number\n  ): string | undefined\n}\n\nexport interface JSONPathParser {\n  parse: (pathStr: string) => JSONPath\n  stringify: (path: JSONPath) => string\n}\n\nexport interface VisibleSection {\n  start: number\n  end: number\n}\n\nexport enum Mode {\n  text = 'text',\n  tree = 'tree',\n  table = 'table'\n}\n\nexport enum SelectionType {\n  after = 'after',\n  inside = 'inside',\n  key = 'key',\n  value = 'value',\n  multi = 'multi',\n  text = 'text' // in text mode\n}\n\nexport enum CaretType {\n  after = 'after',\n  key = 'key',\n  value = 'value',\n  inside = 'inside'\n}\n\nexport interface PathOption {\n  value: JSONPath\n  label: string\n}\n\nexport interface NumberOption {\n  value: 1 | -1\n  label: string\n}\n\nexport interface CaretPosition {\n  path: JSONPath\n  type: CaretType // TODO: refactor this to use SelectionType here, then we can simplify the util functions to turn this into a selection\n}\n\nexport interface ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, RecursiveState | undefined>\n}\n\nexport interface ArrayRecursiveState {\n  type: 'array'\n  items: Array<RecursiveState | undefined>\n}\n\nexport interface ValueRecursiveState {\n  type: 'value'\n}\n\nexport type RecursiveState = ObjectRecursiveState | ArrayRecursiveState | ValueRecursiveState\n\nexport interface RecursiveStateFactory {\n  createObjectDocumentState: () => ObjectRecursiveState\n  createArrayDocumentState: () => ArrayRecursiveState\n  createValueDocumentState: () => ValueRecursiveState\n}\n\nexport interface ObjectDocumentState extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, DocumentState | undefined>\n  expanded: boolean\n}\n\nexport interface ArrayDocumentState extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<DocumentState | undefined>\n  expanded: boolean\n  visibleSections: VisibleSection[]\n}\n\nexport interface ValueDocumentState extends ValueRecursiveState {\n  type: 'value'\n  enforceString?: boolean\n}\n\nexport type DocumentState = ObjectDocumentState | ArrayDocumentState | ValueDocumentState\n\nexport interface ObjectSearchResults extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, SearchResults | undefined>\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport interface ArraySearchResults extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<SearchResults | undefined>\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport interface ValueSearchResults extends ValueRecursiveState {\n  type: 'value'\n  searchResults?: ExtendedSearchResultItem[]\n}\n\nexport type SearchResults = ObjectSearchResults | ArraySearchResults | ValueSearchResults\n\nexport type WithSearchResults = SearchResults & {\n  searchResults: ExtendedSearchResultItem[]\n}\n\nexport interface ObjectValidationErrors extends ObjectRecursiveState {\n  type: 'object'\n  properties: Record<string, ValidationErrors | undefined>\n  validationError?: NestedValidationError\n}\n\nexport interface ArrayValidationErrors extends ArrayRecursiveState {\n  type: 'array'\n  items: Array<ValidationErrors | undefined>\n  validationError?: NestedValidationError\n}\n\nexport interface ValueValidationErrors extends ValueRecursiveState {\n  type: 'value'\n  validationError?: NestedValidationError\n}\n\nexport type ValidationErrors =\n  | ObjectValidationErrors\n  | ArrayValidationErrors\n  | ValueValidationErrors\n\nexport interface JSONPatchResult {\n  json: unknown\n  previousJson: unknown\n  undo: JSONPatchDocument\n  redo: JSONPatchDocument\n}\n\nexport type AfterPatchCallback = (\n  patchedJson: unknown,\n  patchedState: DocumentState | undefined,\n  patchedSelection: JSONSelection | undefined\n) =>\n  | {\n      json?: unknown\n      state?: DocumentState | undefined\n      selection?: JSONSelection | undefined\n      sortedColumn?: SortedColumn | undefined\n    }\n  | undefined\n\nexport interface MultiSelection {\n  type: SelectionType.multi\n  anchorPath: JSONPath\n  focusPath: JSONPath\n}\n\nexport interface AfterSelection {\n  type: SelectionType.after\n  path: JSONPath\n}\n\nexport interface InsideSelection {\n  type: SelectionType.inside\n  path: JSONPath\n}\n\nexport interface KeySelection {\n  type: SelectionType.key\n  path: JSONPath\n}\n\nexport interface EditKeySelection extends KeySelection {\n  type: SelectionType.key\n  path: JSONPath\n  edit: true\n  initialValue?: string\n}\n\nexport type ValueSelection = {\n  type: SelectionType.value\n  path: JSONPath\n}\n\nexport interface EditValueSelection extends ValueSelection {\n  type: SelectionType.value\n  path: JSONPath\n  edit: true\n  initialValue?: string\n}\n\nexport type JSONSelection =\n  | MultiSelection\n  | AfterSelection\n  | InsideSelection\n  | KeySelection\n  | EditKeySelection\n  | ValueSelection\n  | EditValueSelection\n\n// TextSelection is the result of EditorSelection.toJSON() from CodeMirror,\n// with an additional `type` property\nexport interface TextSelection {\n  type: SelectionType.text\n  ranges: { anchor: number; head: number }[]\n  main: number\n}\n\nexport type JSONEditorSelection = JSONSelection | TextSelection\n\nexport type ClipboardValues = Array<{ key: string; value: unknown }>\n\nexport interface MenuButton {\n  type: 'button'\n  onClick: (event: MouseEvent) => void\n  icon?: IconDefinition\n  text?: string\n  title?: string\n  className?: string\n  disabled?: boolean\n}\n\nexport interface MenuDropDownButton {\n  type: 'dropdown-button'\n  main: MenuButton\n  width?: string\n  items: MenuButton[]\n}\n\nexport interface MenuLabel {\n  type: 'label'\n  text: string\n}\n\nexport interface MenuSeparator {\n  type: 'separator'\n}\n\nexport interface MenuSpace {\n  type: 'space'\n}\n\nexport type MenuItem = MenuButton | MenuSeparator | MenuSpace\n\nexport interface ContextMenuColumn {\n  type: 'column'\n  items: Array<MenuButton | MenuDropDownButton | MenuLabel | MenuSeparator>\n}\nexport interface ContextMenuRow {\n  type: 'row'\n  items: Array<MenuButton | MenuDropDownButton | ContextMenuColumn>\n}\nexport type ContextMenuItem = MenuButton | MenuDropDownButton | MenuSeparator | ContextMenuRow\n\nexport interface MessageAction {\n  text: string\n  title: string\n  icon?: IconDefinition\n  onClick?: () => void\n  onMouseDown?: () => void\n  disabled?: boolean\n}\n\nexport enum ValidationSeverity {\n  info = 'info',\n  warning = 'warning',\n  error = 'error'\n}\n\nexport interface ValidationError {\n  path: JSONPath\n  message: string\n  severity: ValidationSeverity\n}\n\nexport interface NestedValidationError extends ValidationError {\n  isChildError?: boolean\n}\n\nexport type Validator = (json: unknown) => ValidationError[]\n\nexport interface ParseError {\n  position: number | undefined\n  line: number | undefined\n  column: number | undefined\n  message: string\n}\n\nexport interface ContentParseError {\n  parseError: ParseError\n  isRepairable: boolean\n}\n\nexport interface ContentValidationErrors {\n  validationErrors: ValidationError[]\n}\n\nexport type ContentErrors = ContentParseError | ContentValidationErrors\n\nexport interface RichValidationError extends ValidationError {\n  line: number | undefined\n  column: number | undefined\n  from: number | undefined\n  to: number | undefined\n  actions: Array<{ name: string; apply: () => void }> | undefined\n}\n\nexport interface TextLocation {\n  path: JSONPath\n  line: number\n  column: number\n  from: number\n  to: number\n}\n\nexport interface Section {\n  start: number // start included\n  end: number // end excluded\n}\n\nexport interface QueryLanguage {\n  id: string\n  name: string\n  description: string\n  createQuery: (json: unknown, queryOptions: QueryLanguageOptions) => string\n  executeQuery: (json: unknown, query: string, parser: JSONParser) => unknown\n}\n\nexport interface QueryLanguageOptions {\n  filter?: {\n    path?: JSONPath\n    relation?: '==' | '!=' | '<' | '<=' | '>' | '>='\n    value?: string\n  }\n  sort?: {\n    path?: JSONPath\n    direction?: 'asc' | 'desc'\n  }\n  projection?: {\n    paths?: JSONPath[]\n  }\n}\n\nexport type OnChangeQueryLanguage = (queryLanguageId: string) => void\nexport interface OnChangeStatus {\n  contentErrors: ContentErrors | undefined\n  patchResult: JSONPatchResult | undefined\n}\nexport type OnChange =\n  | ((content: Content, previousContent: Content, status: OnChangeStatus) => void)\n  | undefined\nexport type OnJSONSelect = (selection: JSONSelection) => void\nexport type OnSelect = (selection: JSONEditorSelection | undefined) => void\nexport type OnUndo = (item: HistoryItem | undefined) => void\nexport type OnRedo = (item: HistoryItem | undefined) => void\nexport type OnPatch = (\n  operations: JSONPatchDocument,\n  afterPatch?: AfterPatchCallback\n) => JSONPatchResult\nexport type OnChangeText = (updatedText: string, afterPatch?: AfterPatchCallback) => void\nexport type OnSort = (params: {\n  operations: JSONPatchDocument\n  rootPath: JSONPath\n  itemPath: JSONPath\n  direction: 1 | -1\n}) => void\nexport type OnFind = (findAndReplace: boolean) => void\nexport type OnPaste = (pastedText: string) => void\nexport type OnPasteJson = (pastedJson: PastedJson) => void\nexport type OnExpand = (relativePath: JSONPath) => boolean\nexport type OnRenderValue = (props: RenderValueProps) => RenderValueComponentDescription[]\nexport type OnClassName = (path: JSONPath, value: unknown) => string | undefined\nexport type OnChangeMode = (mode: Mode) => void\nexport type OnContextMenu = (contextMenuProps: AbsolutePopupOptions) => void\nexport type RenderMenuContext = {\n  mode: Mode\n  modal: boolean\n  readOnly: boolean\n}\nexport type OnRenderMenu = (items: MenuItem[], context: RenderMenuContext) => MenuItem[] | undefined\nexport type OnRenderMenuInternal = (items: MenuItem[]) => MenuItem[] | undefined\nexport type RenderContextMenuContext = RenderMenuContext & {\n  selection: JSONEditorSelection | undefined\n}\nexport type OnRenderContextMenu = (\n  items: ContextMenuItem[],\n  context: RenderContextMenuContext\n) => ContextMenuItem[] | false | undefined\nexport type OnRenderContextMenuInternal = (\n  items: ContextMenuItem[]\n) => ContextMenuItem[] | false | undefined\nexport type OnError = (error: Error) => void\nexport type OnFocus = () => void\nexport type OnBlur = () => void\nexport type OnSortModal = (props: SortModalCallback) => void\nexport type OnTransformModal = (props: TransformModalCallback) => void\nexport type OnJSONEditorModal = (props: JSONEditorModalCallback) => void\nexport type FindNextInside = (path: JSONPath) => JSONSelection | undefined\n\nexport interface SearchResultDetails {\n  items: ExtendedSearchResultItem[]\n  activeItem: ExtendedSearchResultItem | undefined\n  activeIndex: number | -1\n}\n\nexport enum SearchField {\n  key = 'key',\n  value = 'value'\n}\n\nexport interface SearchOptions {\n  maxResults?: number\n  columns?: JSONPath[]\n}\n\nexport interface SearchResultItem {\n  path: JSONPath\n  field: SearchField\n  fieldIndex: number\n  start: number\n  end: number\n}\n\nexport interface ExtendedSearchResultItem extends SearchResultItem {\n  active: boolean\n}\n\nexport type EscapeValue = (value: unknown) => string\n\nexport type UnescapeValue = (escapedValue: string) => string\n\nexport interface ValueNormalization {\n  escapeValue: EscapeValue\n  unescapeValue: UnescapeValue\n}\n\nexport type PastedJson = {\n  path: JSONPath\n  contents: unknown\n  onPasteAsJson: () => void\n}\n\nexport interface DragInsideProps {\n  json: unknown\n  selection: JSONSelection\n  deltaY: number\n  items: Array<{ path: JSONPath; height: number }>\n}\n\nexport type DragInsideAction =\n  | { beforePath: JSONPath; offset: number }\n  | { append: true; offset: number }\n\nexport interface RenderedItem {\n  path: JSONPath\n  height: number\n}\n\nexport interface TreeHistoryItem {\n  type: 'tree'\n  undo: {\n    patch: JSONPatchDocument | undefined\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    sortedColumn: SortedColumn | undefined\n    textIsRepaired: boolean\n  }\n  redo: {\n    patch: JSONPatchDocument | undefined\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    sortedColumn: SortedColumn | undefined\n    textIsRepaired: boolean\n  }\n}\n\nexport type TextChanges = Array<number | [number, ...string[]]>\n\nexport interface TextHistoryItem {\n  type: 'text'\n  undo: {\n    changes: TextChanges\n    selection: TextSelection\n  }\n  redo: {\n    changes: TextChanges\n    selection: TextSelection\n  }\n}\n\nexport interface ModeHistoryItem {\n  type: 'mode'\n  undo: {\n    mode: Mode\n    selection: undefined // selection can be restored used the corresponding sibling HistoryItem\n  }\n  redo: {\n    mode: Mode\n    selection: undefined // selection can be restored used the corresponding sibling HistoryItem\n  }\n}\n\nexport type HistoryItem = TreeHistoryItem | TextHistoryItem | ModeHistoryItem\n\nexport interface HistoryInstance<T> {\n  get: () => History<T>\n}\n\nexport interface History<T> {\n  canUndo: boolean\n  canRedo: boolean\n  items: () => T[]\n  add: (item: T) => void\n  clear: () => void\n  undo: () => T | undefined\n  redo: () => T | undefined\n}\n\nexport type ConvertType = 'value' | 'object' | 'array'\nexport type InsertType = ConvertType | 'structure'\n\nexport interface PopupEntry {\n  id: number\n  component: typeof SvelteComponent<Record<string, unknown>>\n  props: Record<string, unknown>\n  options: AbsolutePopupOptions\n}\n\nexport interface AbsolutePopupOptions {\n  anchor?: Element\n  position?: 'top' | 'left'\n  left?: number\n  top?: number\n  width?: number\n  height?: number\n  offsetTop?: number\n  offsetLeft?: number\n  showTip?: boolean\n  closeOnOuterClick?: boolean\n  onClose?: () => void\n}\n\nexport interface AbsolutePopupContext {\n  openAbsolutePopup: (\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ) => number\n  closeAbsolutePopup: (popupId: number | undefined) => void\n}\n\nexport interface JSONEditorPropsOptional {\n  content?: Content\n  selection?: JSONEditorSelection\n  readOnly?: boolean\n  indentation?: number | string\n  tabSize?: number\n  mode?: Mode\n  mainMenuBar?: boolean\n  navigationBar?: boolean\n  statusBar?: boolean\n  askToFormat?: boolean\n  escapeControlCharacters?: boolean\n  escapeUnicodeCharacters?: boolean\n  flattenColumns?: boolean\n  parser?: JSONParser\n  validator?: Validator | undefined\n  validationParser?: JSONParser\n  pathParser?: JSONPathParser\n\n  queryLanguages?: QueryLanguage[]\n  queryLanguageId?: string\n\n  onChangeQueryLanguage?: OnChangeQueryLanguage\n  onChange?: OnChange\n  onRenderValue?: OnRenderValue\n  onClassName?: OnClassName\n  onRenderMenu?: OnRenderMenu\n  onRenderContextMenu?: OnRenderContextMenu\n  onChangeMode?: OnChangeMode\n  onSelect?: OnSelect\n  onError?: OnError\n  onFocus?: OnFocus\n  onBlur?: OnBlur\n}\n\nexport interface JSONEditorModalProps {\n  content: Content\n  path: JSONPath\n  onPatch: OnPatch\n\n  readOnly: boolean\n  indentation: number | string\n  tabSize: number\n  mainMenuBar: boolean\n  navigationBar: boolean\n  statusBar: boolean\n  askToFormat: boolean\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n  flattenColumns: boolean\n  parser: JSONParser\n  validator: Validator | undefined\n  validationParser: JSONParser\n  pathParser: JSONPathParser\n\n  onRenderValue: OnRenderValue\n  onClassName: OnClassName\n  onRenderMenu: OnRenderMenu\n  onRenderContextMenu: OnRenderContextMenu\n  onSortModal: (props: SortModalCallback) => void\n  onTransformModal: (props: TransformModalCallback) => void\n  onClose: () => void\n}\n\nexport interface JSONEditorContext {\n  mode: Mode\n  readOnly: boolean\n  parser: JSONParser\n  normalization: ValueNormalization\n  getJson: () => unknown | undefined\n  getDocumentState: () => DocumentState | undefined\n  findElement: (path: JSONPath) => Element | undefined\n  findNextInside: FindNextInside\n  focus: () => void\n  onPatch: OnPatch\n  onSelect: OnJSONSelect\n  onFind: OnFind\n  onPasteJson: (newPastedJson: PastedJson) => void\n  onRenderValue: OnRenderValue\n}\n\nexport interface TreeModeContext extends JSONEditorContext {\n  getJson: () => unknown | undefined\n  getDocumentState: () => DocumentState | undefined\n  getSelection: () => JSONSelection | undefined\n  findElement: (path: JSONPath) => Element | undefined\n  onInsert: (type: InsertType) => void\n  onExpand: (path: JSONPath, expanded: boolean, recursive?: boolean) => void\n  onExpandSection: (path: JSONPath, section: Section) => void\n  onContextMenu: OnContextMenu\n  onClassName: OnClassName\n  onDrag: (event: MouseEvent) => void\n  onDragEnd: () => void\n}\n\nexport interface RenderValueProps extends Record<string, unknown> {\n  path: JSONPath\n  value: unknown\n  mode: Mode\n  readOnly: boolean\n  enforceString: boolean\n  selection: JSONSelection | undefined\n  searchResultItems: SearchResultItem[] | undefined\n  isEditing: boolean\n  parser: JSONParser\n  normalization: ValueNormalization\n  onPatch: OnPatch\n  onPasteJson: OnPasteJson\n  onSelect: OnJSONSelect\n  onFind: OnFind\n  findNextInside: FindNextInside\n  focus: () => void\n}\n\nexport type RenderValuePropsOptional = Partial<RenderValueProps>\n\nexport interface DraggingState {\n  initialTarget: Element\n  initialClientY: number\n  initialContentTop: number\n  selectionStartIndex: number\n  selectionItemsCount: number\n  items: RenderedItem[]\n  offset: number\n  didMoveItems: boolean\n}\n\nexport type RenderValueComponentDescription = SvelteComponentRenderer | SvelteActionRenderer\n\nexport interface SvelteComponentRenderer {\n  component: typeof SvelteComponent<RenderValuePropsOptional>\n  props: Record<string, unknown>\n}\n\nexport interface SvelteActionRenderer {\n  action: Action<HTMLElement, Record<string, unknown>>\n  props: Record<string, unknown>\n}\n\nexport interface TransformModalOptions {\n  id?: string\n  rootPath?: JSONPath\n  onTransform?: (state: {\n    operations: JSONPatchDocument\n    json: unknown\n    transformedJson: unknown\n  }) => void\n  onClose?: () => void\n}\n\nexport interface TransformModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  onTransform: (operations: JSONPatchDocument) => void\n  onClose: () => void\n}\n\nexport interface TransformModalProps extends TransformModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  indentation: number | string\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n  parser: JSONParser\n  parseMemoizeOne: JSONParser['parse']\n  validationParser: JSONParser\n  pathParser: JSONPathParser\n\n  queryLanguages: QueryLanguage[]\n  queryLanguageId: string\n  onChangeQueryLanguage: OnChangeQueryLanguage\n\n  onRenderValue: OnRenderValue\n  onRenderMenu: OnRenderMenuInternal\n  onRenderContextMenu: OnRenderContextMenuInternal\n  onClassName: OnClassName\n\n  onTransform: (operations: JSONPatchDocument) => void\n  onClose: () => void\n}\n\nexport interface SortModalCallback {\n  id: string\n  json: unknown\n  rootPath: JSONPath\n  onSort: OnSort\n  onClose: () => void\n}\n\nexport interface JSONRepairModalProps {\n  text: string\n  onParse: (text: string) => void\n  onRepair: (text: string) => string\n  onApply: (repairedText: string) => void\n  onClose: () => void\n}\n\nexport interface JSONEditorModalCallback {\n  content: Content\n  path: JSONPath\n  onPatch: OnPatch\n  onClose: () => void\n}\n\nexport enum SortDirection {\n  asc = 'asc',\n  desc = 'desc'\n}\n\nexport enum UpdateSelectionAfterChange {\n  no = 'no',\n  self = 'self',\n  nextInside = 'nextInside'\n}\n\nexport interface TableCellIndex {\n  rowIndex: number\n  columnIndex: number\n}\n\nexport interface SortedColumn {\n  path: JSONPath\n  sortDirection: SortDirection\n}\n\n// TODO: work out the JSONSchema type in detail.\n//  Ideally, we use use Schema from Ajv, but this interface isn't worked out either\nexport type JSONSchema = Record<string, unknown>\nexport type JSONSchemaDefinitions = Record<string, JSONSchema>\nexport type JSONSchemaEnum = Array<unknown>\n","import type { ValueNormalization } from '$lib/types.js'\nimport { SelectionType } from '$lib/types.js'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, parseJSONPointer } from 'immutable-json-patch'\nimport { map, minBy } from 'lodash-es'\n\n/**\n * Create serialization functions to escape and stringify text,\n * and the other way around: to parse and unescape text.\n */\nexport function createNormalizationFunctions({\n  escapeControlCharacters,\n  escapeUnicodeCharacters\n}: {\n  escapeControlCharacters: boolean\n  escapeUnicodeCharacters: boolean\n}): ValueNormalization {\n  if (escapeControlCharacters) {\n    if (escapeUnicodeCharacters) {\n      return normalizeControlAndUnicode\n    } else {\n      return normalizeControl\n    }\n  } else {\n    if (escapeUnicodeCharacters) {\n      return normalizeUnicode\n    } else {\n      return normalizeNothing\n    }\n  }\n}\n\nconst normalizeControlAndUnicode = {\n  escapeValue: (value: unknown) => jsonEscapeUnicode(jsonEscapeControl(String(value))),\n  unescapeValue: (value: string) => jsonUnescapeControl(jsonUnescapeUnicode(value))\n}\n\nconst normalizeControl = {\n  escapeValue: (value: unknown) => jsonEscapeControl(String(value)),\n  unescapeValue: (value: string) => jsonUnescapeControl(value)\n}\n\nconst normalizeUnicode = {\n  escapeValue: (value: unknown) => jsonEscapeUnicode(String(value)),\n  unescapeValue: (value: string) => jsonUnescapeUnicode(value)\n}\n\nconst normalizeNothing = {\n  escapeValue: (value: unknown) => String(value),\n  unescapeValue: (value: string) => value\n}\n\n/**\n * Source:  https://stackoverflow.com/questions/12271547/shouldnt-json-stringify-escape-unicode-characters\n */\nexport function jsonEscapeUnicode(value: string): string {\n  return value.replace(/[^\\x20-\\x7F]/g, (x) => {\n    if (x === '\\b' || x === '\\f' || x === '\\n' || x === '\\r' || x === '\\t') {\n      return x\n    }\n\n    return '\\\\u' + ('000' + x.codePointAt(0)?.toString(16)).slice(-4)\n  })\n}\n\nexport function jsonUnescapeUnicode(value: string): string {\n  return value.replace(/\\\\u[a-fA-F0-9]{4}/g, (x) => {\n    try {\n      const unescaped: string = JSON.parse('\"' + x + '\"')\n      // the resolved character can be a control character like \" or \\n,\n      // that would result in invalid JSON, so we need to keep that escaped\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return controlCharacters[unescaped] || unescaped\n    } catch {\n      return x\n    }\n  })\n}\n\nconst controlCharacters = {\n  '\"': '\\\\\"',\n  '\\\\': '\\\\\\\\',\n  // escaped forward slash '\\/' is the same as '/', we can't escape/unescape it\n  '\\b': '\\\\b',\n  '\\f': '\\\\f',\n  '\\n': '\\\\n',\n  '\\r': '\\\\r',\n  '\\t': '\\\\t'\n  // unicode is handled separately\n}\n\nconst escapedControlCharacters = {\n  '\\\\\"': '\"',\n  '\\\\\\\\': '\\\\',\n  // escaped forward slash '\\/' is the same as '/', we can't escape/unescape it\n  '\\\\/': '/',\n  '\\\\b': '\\b',\n  '\\\\f': '\\f',\n  '\\\\n': '\\n',\n  '\\\\r': '\\r',\n  '\\\\t': '\\t'\n  // unicode is handled separately\n}\n\nexport function jsonEscapeControl(value: string): string {\n  return value.replace(/[\"\\b\\f\\n\\r\\t\\\\]/g, (x) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return controlCharacters[x] || x\n  })\n}\n\nexport function jsonUnescapeControl(value: string): string {\n  return value.replace(/\\\\[\"bfnrt\\\\]/g, (x) => {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    return escapedControlCharacters[x] || x\n  })\n}\n\nexport function addNewLineSuffix(value: unknown): string {\n  if (typeof value !== 'string') {\n    return String(value)\n  }\n\n  if (value.endsWith('\\n')) {\n    // DOM innerText strips the last \\n, therefore we add an extra \\n here\n    return value + '\\n'\n  }\n\n  return value\n}\n\n/**\n * Remove a newline suffix from text returned by element.innerText, it adds\n * one return too much.\n */\nexport function removeNewLineSuffix(text: string): string {\n  return text.replace(/\\n$/, '')\n}\n\n// regular expression matching one or multiple return characters with all their\n// enclosing white spaces\nexport function removeReturnsAndSurroundingWhitespace(text: string): string {\n  return text.replace(/(\\b|^)\\s*(\\b|$)/g, (match) => {\n    return /\\n/.exec(match) ? '' : match\n  })\n}\n\nexport function isChildOfNodeName(element: Element, nodeName: string): boolean {\n  return isChildOf(element, (e) => e.nodeName.toUpperCase() === nodeName.toUpperCase())\n}\n\nexport function isChildOfAttribute(element: Element, name: string, value: string): boolean {\n  return isChildOf(element, (e) => hasAttribute(e, name, value))\n}\n\n// test whether a DOM element is a content editable div\nexport function isContentEditableDiv(element: HTMLElement): boolean {\n  return element.nodeName === 'DIV' && element.contentEditable === 'true'\n}\n\n// test whether a DOM element is an \"input\" with type \"text\"\nexport function isTextInput(element: HTMLInputElement): boolean {\n  return (\n    element.nodeName === 'INPUT' &&\n    element.type !== undefined &&\n    element.type.toLowerCase() === 'text'\n  )\n}\n\nfunction hasAttribute(element: Element, name: string, value: string): boolean {\n  return typeof element.getAttribute === 'function' && element.getAttribute(name) === value\n}\n\n/**\n * Test if the element or one of its parents has a certain predicate\n * Can be use for example to check whether the element or it's parent has\n * a specific attribute or nodeName.\n */\nexport function isChildOf(element: Element, predicate: (element: Element) => boolean): boolean {\n  return !!findParent(element, predicate)\n}\n\n/**\n * Test if the element or one of its parents has a certain predicate\n * Can be use for example to check whether the element or it's parent has\n * a specific attribute or nodeName.\n * @param {HTMLElement} element\n * @param {function (element: HTMLElement) : boolean} predicate\n * @returns {HTMLElement | undefined}\n */\nexport function findParent(\n  element: Element,\n  predicate: (element: Element) => boolean\n): Element | undefined {\n  let e: Element | undefined = element\n\n  while (e && !predicate(e)) {\n    e = e.parentNode as Element\n  }\n\n  return e\n}\n\n/**\n * Set the cursor to the end of a content editable div\n * Source: https://stackoverflow.com/questions/13513329/set-cursor-to-the-end-of-contenteditable-div\n * @param {HTMLElement} element\n */\nexport function setCursorToEnd(element: HTMLElement) {\n  if (element.firstChild == null) {\n    element.focus()\n    return\n  }\n\n  const range = document.createRange()\n  const selection = window.getSelection()\n  range.setStart(element, 1)\n  range.collapse(true)\n  selection?.removeAllRanges()\n  selection?.addRange(range)\n}\n\n/**\n * Gets a DOM element's Window.  This is normally just the global `window`\n * variable, but if we opened a child window, it may be different.\n */\nexport function getWindow(element: Element): Window | undefined {\n  return element?.ownerDocument?.defaultView ?? undefined\n}\n\nexport function activeElementIsChildOf(element: Element) {\n  const window = getWindow(element)\n  const activeElement = window?.document.activeElement\n  return activeElement ? isChildOf(activeElement, (e) => e === element) : false\n}\n\n/**\n * Traverse over the parents of the element until a node is found with the\n * searched for node name. If the element itself contains the nodeName, the\n * element itself will be returned\n */\nexport function findParentWithNodeName(element: Element, nodeName: string): Element | undefined {\n  return findParent(element, (e) => e.nodeName === nodeName)\n}\n\nexport function getSelectionTypeFromTarget(target: Element): SelectionType {\n  if (isChildOfAttribute(target, 'data-type', 'selectable-key')) {\n    return SelectionType.key\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'selectable-value')) {\n    return SelectionType.value\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-inside')) {\n    return SelectionType.inside\n  }\n\n  if (isChildOfAttribute(target, 'data-type', 'insert-selection-area-after')) {\n    return SelectionType.after\n  }\n\n  return SelectionType.multi\n}\n\n/**\n * Encode a path into a string that can be used as attribute in HTML\n */\nexport function encodeDataPath(path: JSONPath): string {\n  return encodeURIComponent(compileJSONPointer(path))\n}\n\n/**\n * Decode a path that was stringified for use as an HTML attribute\n */\nexport function decodeDataPath(pathStr: string): JSONPath {\n  return parseJSONPointer(decodeURIComponent(pathStr))\n}\n\n/**\n * Find the data path of the given element. Traverses the parent nodes until find\n */\nexport function getDataPathFromTarget(target: Element): JSONPath | undefined {\n  const parent = findParent(target, (element) => {\n    return element?.hasAttribute ? element.hasAttribute('data-path') : false\n  })\n\n  const dataPath = parent?.getAttribute('data-path') ?? undefined\n  return dataPath ? decodeDataPath(dataPath) : undefined\n}\n\n/**\n * Find the nearest element in a given context menu with buttons or inputs\n */\n// TODO: unit test\nexport function findNearestElement<T extends Element>({\n  allElements,\n  currentElement,\n  direction,\n  hasPrio = () => true,\n  margin = 10\n}: {\n  allElements: T[]\n  currentElement: T\n  direction: 'Up' | 'Down' | 'Left' | 'Right'\n  margin?: number\n  hasPrio?: (element: T) => boolean\n}): T | undefined {\n  const all = map(allElements.filter(isVisible), calculateCenter)\n  const current = calculateCenter(currentElement)\n\n  interface CenterLocation {\n    x: number\n    y: number\n    rect: DOMRect\n    element: T\n  }\n\n  function isVisible(element: T): boolean {\n    const rect = element.getBoundingClientRect()\n    return rect.width > 0 && rect.height > 0\n  }\n\n  function calculateCenter(element: T): CenterLocation {\n    const rect = element.getBoundingClientRect()\n    return {\n      x: rect.left + rect.width / 2,\n      y: rect.top + rect.height / 2,\n      rect,\n      element\n    }\n  }\n\n  const isOnSameRow = (a: CenterLocation, b: CenterLocation) => Math.abs(a.y - b.y) < margin\n  const isLeft = (a: CenterLocation, b: CenterLocation) => a.rect.left + margin < b.rect.left\n  const isRight = (a: CenterLocation, b: CenterLocation) => a.rect.right > b.rect.right + margin\n  const isAbove = (a: CenterLocation, b: CenterLocation) => a.y + margin < b.y\n  const isBelow = (a: CenterLocation, b: CenterLocation) => a.y > b.y + margin\n\n  function distance(a: CenterLocation, b: CenterLocation, weightY = 1): number {\n    const diffX = a.x - b.x\n    const diffY = (a.y - b.y) * weightY\n    return Math.sqrt(diffX * diffX + diffY * diffY)\n  }\n  const distanceToCurrent = (candidate: CenterLocation) => distance(candidate, current)\n  const distanceToCurrentWeighted = (candidate: CenterLocation) => distance(candidate, current, 10)\n\n  if (direction === 'Left' || direction === 'Right') {\n    // First we find the first button left from the current button on the same row\n    // if not found, search the closest button left/right from current button\n    const candidatesLeft =\n      direction === 'Left'\n        ? all.filter((button) => isLeft(button, current))\n        : all.filter((button) => isRight(button, current))\n    const candidatesLeftOnRow = candidatesLeft.filter((button) => isOnSameRow(button, current))\n    const nearest =\n      minBy(candidatesLeftOnRow, distanceToCurrent) ||\n      minBy(candidatesLeft, distanceToCurrentWeighted)\n\n    return nearest?.element\n  }\n\n  if (direction === 'Up' || direction === 'Down') {\n    // first we only search through the prio buttons\n    // if there were no matching prio buttons, search all matching buttons\n    const candidates =\n      direction === 'Up'\n        ? all.filter((button) => isAbove(button, current))\n        : all.filter((button) => isBelow(button, current))\n    const prioCandidates = candidates.filter((button) => hasPrio(button.element))\n    const nearest = minBy(prioCandidates, distanceToCurrent) || minBy(candidates, distanceToCurrent)\n\n    return nearest?.element\n  }\n\n  return undefined\n}\n","declare global {\n  // extend with the userAgentData: NavigatorUAData property (currently experimental)\n  // see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/userAgentData\n  interface Navigator {\n    userAgentData?: {\n      platform: string\n    }\n  }\n}\n\nexport function isMacDevice() {\n  return (\n    typeof navigator !== 'undefined' &&\n    (navigator?.platform?.toUpperCase().includes('MAC') ??\n      navigator?.userAgentData?.platform?.toUpperCase().includes('MAC') ??\n      false)\n  )\n}\n","// inspiration: https://github.com/andrepolischuk/keycomb\n\nimport { isMacDevice } from './navigatorUtils.js'\n\n// KeyComboEvent is a subset of KeyboardEvent\nexport interface KeyComboEvent {\n  ctrlKey: boolean\n  metaKey: boolean\n  altKey: boolean\n  shiftKey: boolean\n  key: string\n}\n\n/**\n * Get the active key combination from a keyboard event.\n * For example returns \"Ctrl+Shift+ArrowUp\" or \"Ctrl+A\"\n *\n * Returns the same output on both Windows and Mac:\n * meta keys \"Ctrl\" (\"Command\" on Mac), and \"Alt\" (\"Alt\" or \"Option\" on Mac)\n * So pressing \"Command\" and \"A\"on Mac will return \"Ctrl+A\"\n */\nexport function keyComboFromEvent(\n  event: KeyComboEvent,\n  separator = '+',\n  isMac = isMacDevice\n): string {\n  const combi = []\n\n  if (isCtrlKeyDown(event, isMac)) {\n    // on Mac this is called Command or Cmd\n    combi.push('Ctrl')\n  }\n  if (event.altKey) {\n    // on Mac this is called Option\n    combi.push('Alt')\n  }\n  if (event.shiftKey) {\n    combi.push('Shift')\n  }\n\n  const keyName = event.key.length === 1 ? event.key.toUpperCase() : event.key\n  if (!(keyName in metaKeys)) {\n    // prevent output like 'Ctrl+Ctrl'\n    combi.push(keyName)\n  }\n\n  return combi.join(separator)\n}\n\n/**\n * Test whether the Ctrl key (windows, linux) or Command key (mac) is down\n */\nexport function isCtrlKeyDown(\n  event: { ctrlKey: boolean; metaKey: boolean },\n  isMac = isMacDevice\n): boolean {\n  // metaKey is the Command key ⌘ on a Mac (but the Windows Key ⊞ on Windows)\n  return event.ctrlKey || (event.metaKey && isMac())\n}\n\nconst metaKeys = {\n  Ctrl: true,\n  Command: true,\n  Control: true,\n  Alt: true,\n  Option: true,\n  Shift: true\n}\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<script lang=\"ts\">\n  import type { AbsolutePopupOptions, PopupEntry } from '$lib/types.js'\n  import { onMount } from 'svelte'\n  import { isChildOf } from '$lib/utils/domUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n\n  export let popup: PopupEntry\n  export let closeAbsolutePopup: (popupId: number) => void\n\n  let refRootPopup: HTMLDivElement\n  let refHiddenInput: HTMLInputElement\n\n  onMount(focus)\n\n  function closeWhenOutside(event: Event) {\n    if (\n      popup.options &&\n      popup.options.closeOnOuterClick &&\n      !isChildOf(event.target as HTMLElement, (e) => e === refRootPopup)\n    ) {\n      closeAbsolutePopup(popup.id)\n    }\n  }\n\n  function handleWindowMouseDown(event: Event) {\n    closeWhenOutside(event)\n  }\n\n  function handleMouseDownInside(event: Event) {\n    event.stopPropagation()\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    if (combo === 'Escape') {\n      event.preventDefault()\n      event.stopPropagation()\n      closeAbsolutePopup(popup.id)\n    }\n  }\n\n  function handleScrollWheel(event: Event) {\n    closeWhenOutside(event)\n  }\n\n  function calculateStyle(refRootPopup: HTMLDivElement, options: AbsolutePopupOptions) {\n    function calculatePosition() {\n      if (options.anchor) {\n        const { anchor, width = 0, height = 0, offsetTop = 0, offsetLeft = 0, position } = options\n        const { left, top, bottom, right } = anchor.getBoundingClientRect()\n\n        const positionAbove =\n          position === 'top' || (top + height > window.innerHeight && top > height)\n        const positionLeft =\n          position === 'left' || (left + width > window.innerWidth && left > width)\n\n        return {\n          left: positionLeft ? right - offsetLeft : left + offsetLeft,\n          top: positionAbove ? top - offsetTop : bottom + offsetTop,\n          positionAbove,\n          positionLeft\n        }\n      } else if (typeof options.left === 'number' && typeof options.top === 'number') {\n        const { left, top, width = 0, height = 0 } = options\n\n        const positionAbove = top + height > window.innerHeight && top > height\n        const positionLeft = left + width > window.innerWidth && left > width\n\n        return {\n          left,\n          top,\n          positionAbove,\n          positionLeft\n        }\n      } else {\n        throw new Error('Invalid config: pass either \"left\" and \"top\", or pass \"anchor\"')\n      }\n    }\n\n    const rootRect = refRootPopup.getBoundingClientRect()\n    const { left, top, positionAbove, positionLeft } = calculatePosition()\n\n    const verticalStyling = positionAbove\n      ? `bottom: ${rootRect.top - top}px;`\n      : `top: ${top - rootRect.top}px;`\n\n    const horizontalStyling = positionLeft\n      ? `right: ${rootRect.left - left}px;`\n      : `left: ${left - rootRect.left}px;`\n\n    return verticalStyling + horizontalStyling\n  }\n\n  function focus() {\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n    }\n  }\n</script>\n\n<svelte:window\n  on:mousedown|capture={handleWindowMouseDown}\n  on:keydown|capture={handleKeyDown}\n  on:wheel|capture={handleScrollWheel}\n/>\n\n<div\n  role=\"none\"\n  bind:this={refRootPopup}\n  class=\"jse-absolute-popup\"\n  on:mousedown={handleMouseDownInside}\n  on:keydown={handleKeyDown}\n>\n  {#if refRootPopup}\n    <div class=\"jse-absolute-popup-content\" style={calculateStyle(refRootPopup, popup.options)}>\n      <input\n        type=\"text\"\n        readonly\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n      />\n      <svelte:component this={popup.component} {...popup.props} />\n    </div>\n  {/if}\n</div>\n\n<style src=\"./AbsolutePopupEntry.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { createDebug } from '$lib/utils/debug.js'\n  import { setContext, type SvelteComponent } from 'svelte'\n  import type { AbsolutePopupOptions, PopupEntry, AbsolutePopupContext } from '$lib/types'\n  import { uniqueId } from '$lib/utils/uniqueId.js'\n  import AbsolutePopupEntry from './AbsolutePopupEntry.svelte'\n\n  const debug = createDebug('jsoneditor:AbsolutePopup')\n\n  let popups: PopupEntry[] = []\n\n  function openAbsolutePopup(\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ): number {\n    debug('open...', props, options)\n\n    const popup: PopupEntry = {\n      id: uniqueId(),\n      component: component,\n      props: props || {},\n      options: options || {}\n    }\n\n    popups = [...popups, popup]\n\n    return popup.id\n  }\n\n  function closeAbsolutePopup(popupId: number | undefined) {\n    const popupIndex = popups.findIndex((popup) => popup.id === popupId)\n\n    if (popupIndex !== -1) {\n      const popup = popups[popupIndex]\n      if (popup.options.onClose) {\n        popup.options.onClose()\n      }\n\n      popups = popups.filter((popup) => popup.id !== popupId)\n    }\n  }\n\n  $: debug('popups', popups)\n\n  setContext<AbsolutePopupContext>('absolute-popup', { openAbsolutePopup, closeAbsolutePopup })\n</script>\n\n{#each popups as popup}\n  <AbsolutePopupEntry {popup} {closeAbsolutePopup} />\n{/each}\n\n<slot />\n","/**\n * Find a unique name. Suffix the name with ' (copy)', '(copy 2)', etc\n * until a unique name is found\n * @param name    Proposed name\n * @param keys    Array with existing keys\n */\nexport function findUniqueName(name: string, keys: string[]): string {\n  const keysSet = new Set(keys)\n\n  // remove any \" (copy)\" or \" (copy 2)\" suffix from the name\n  const nameWithoutCopySuffix = name.replace(/ \\(copy( \\d+)?\\)$/, '')\n\n  let validName = name\n  let i = 1\n\n  while (keysSet.has(validName)) {\n    const copy = 'copy' + (i > 1 ? ' ' + i : '')\n    validName = `${nameWithoutCopySuffix} (${copy})`\n    i++\n  }\n\n  return validName\n}\n\n/**\n * Transform a text into lower case with the first character upper case\n */\nexport function toCapital(text: string): string {\n  return text && text.length > 0 ? text[0].toUpperCase() + text.substring(1).toLowerCase() : text\n}\n\nexport function compareStrings(a: string, b: string): -1 | 0 | 1 {\n  return a < b ? -1 : a > b ? 1 : 0\n}\n\n/**\n * Duplicate a piece of text\n */\nexport function duplicateInText(text: string, anchorOffset: number, focusOffset: number): string {\n  const startOffset = Math.min(anchorOffset, focusOffset)\n  const endOffset = Math.max(anchorOffset, focusOffset)\n\n  return (\n    text.slice(0, endOffset) +\n    text.slice(startOffset, endOffset) + // the duplicated piece of the text\n    text.slice(endOffset)\n  )\n}\n\n/**\n * Truncate a text to a maximum length.\n * When truncated, the text will pe appended with ellipsis '...'\n * @param text Text to be truncated\n * @param maxLength Maximum allowed length for the text including ellipsis\n */\nexport function truncate(text: string, maxLength: number): string {\n  const ellipsis = '...'\n  const maxTextLength = maxLength - ellipsis.length\n\n  return text.length > maxLength ? text.substring(0, maxTextLength) + ellipsis : text\n}\n\n/**\n * Cast contents of a string to the correct type.\n * This can be a string, a number, a boolean, null, undefined, etc\n * @param str\n * @return parsed string\n */\nexport function parseString(str: string): string | number | boolean | null | undefined {\n  if (str === '') {\n    return ''\n  }\n\n  const lower = str.toLowerCase()\n  if (lower === 'null') {\n    return null\n  }\n  if (lower === 'true') {\n    return true\n  }\n  if (lower === 'false') {\n    return false\n  }\n  if (lower === 'undefined') {\n    return undefined\n  }\n\n  const num = Number(str) // will nicely fail with '123ab'\n  const numFloat = parseFloat(str) // will nicely fail with '  '\n  if (!isNaN(num) && !isNaN(numFloat)) {\n    return num\n  }\n\n  return str\n}\n","import { jsonquery, type JSONQuery, parse, stringify } from '@jsonquerylang/jsonquery'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://jsonquerylang.org\" target=\"_blank\" \n  rel=\"noopener noreferrer\">JSON Query</a> function to filter, sort, or transform the data.\n  You can use functions like <code>get</code>, <code>filter</code>,\n  <code>sort</code>, <code>pick</code>, <code>groupBy</code>, <code>uniq</code>, etcetera. \n  Example query: <code>filter(.age >= 18)</code>\n</p>\n`\n\nexport const jsonQueryLanguage: QueryLanguage = {\n  id: 'jsonquery',\n  name: 'JSONQuery',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(_json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryFunctions: JSONQuery[] = []\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    queryFunctions.push([\n      'filter',\n      [\n        getOperatorName(filter.relation),\n        getter(filter.path),\n        parseString(filter.value) as JSONQuery\n      ]\n    ])\n  }\n\n  if (sort && sort.path && sort.direction) {\n    queryFunctions.push(['sort', getter(sort.path), sort.direction === 'desc' ? 'desc' : 'asc'])\n  }\n\n  if (projection && projection.paths) {\n    if (projection.paths.length > 1) {\n      queryFunctions.push(['pick', ...projection.paths.map(getter)])\n    } else {\n      queryFunctions.push(['map', getter(projection.paths[0])])\n    }\n  }\n\n  return stringify(['pipe', ...queryFunctions])\n}\n\nfunction getter(path: JSONPath): ['get', ...path: JSONPath] {\n  return ['get', ...path]\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  return query.trim() !== '' ? jsonquery(json, query) : json\n}\n\nfunction getOperatorName(operator: string): string {\n  // a trick to get the name of the operator by parsing the operator in a temporary query\n  return (parse(`1 ${operator} 1`) as [string, number, number])[0]\n}\n","<g>\n  {@html raw}\n</g>\n\n<script lang=\"ts\">\n  import type { IconData } from '../Icon.svelte';\n\n  let cursor = 0xd4937;\n  function getId() {\n    cursor += 1;\n    return `fa-${cursor.toString(16)}`;\n  }\n\n  let raw = '';\n\n  export let data: IconData;\n\n  function getRaw(data: IconData) {\n    if (!data || !data.raw) {\n      return '';\n    }\n    let rawData = data.raw;\n    const ids: Record<string, string> = {};\n    rawData = rawData.replace(/\\s(?:xml:)?id=[\"']?([^\"')\\s]+)/g, (match, id) => {\n      const uniqueId = getId();\n      ids[id] = uniqueId;\n      return ` id=\"${uniqueId}\"`;\n    });\n\n    rawData = rawData.replace(\n      /#(?:([^'\")\\s]+)|xpointer\\(id\\((['\"]?)([^')]+)\\2\\)\\))/g,\n      (match, rawId, _, pointerId) => {\n        const id = rawId || pointerId;\n        if (!id || !ids[id]) {\n          return match;\n        }\n        return `#${ids[id]}`;\n      }\n    );\n    return rawData;\n  }\n\n  $: raw = getRaw(data);\n</script>\n","<Svg\n  {label}\n  {width}\n  {height}\n  {box}\n  style={combinedStyle}\n  {spin}\n  {flip}\n  {inverse}\n  {pulse}\n  class={className}\n  {...$$restProps}\n>\n  <slot>\n    {#each iconData?.paths || [] as path}\n      <path {...path} />\n    {/each}\n    {#each iconData?.polygons || [] as polygon}\n      <polygon {...polygon} />\n    {/each}\n    {#if iconData?.raw}\n      <Raw bind:data={iconData} />\n    {/if}\n  </slot>\n</Svg>\n\n<script context=\"module\" lang=\"ts\">\n  export interface FaIconDefinition {\n    prefix: string;\n    iconName: string;\n    icon: [\n      number, // width\n      number, // height\n      string[], // ligatures\n      string, // unicode\n      string | string[] // svgPathData\n    ];\n  }\n\n  export interface IconPath {\n    id?: string;\n    d: string;\n    style?: string;\n    stroke?: string;\n  }\n\n  export interface IconPolygon {\n    points: string;\n    style?: string;\n  }\n\n  export interface IconData {\n    width: number;\n    height: number;\n    paths?: IconPath[];\n    polygons?: IconPolygon[];\n    raw?: string;\n  }\n\n  export type IconType = Record<string, IconData> | FaIconDefinition;\n</script>\n\n<script lang=\"ts\">\n  import Raw from './svg/Raw.svelte';\n  import Svg from './svg/Svg.svelte';\n\n  let className = '';\n\n  export let data: IconType;\n  let iconData: IconData | undefined;\n  export let scale = 1;\n  export let spin = false;\n  export let inverse = false;\n  export let pulse = false;\n  export let flip: 'horizontal' | 'vertical' | undefined = undefined;\n  export let label: string = '';\n  export let style: string = '';\n  export { className as class };\n\n  // internal\n  let childrenHeight = 0;\n  let childrenWidth = 0;\n  let outerScale = 1;\n\n  let width: number = 10;\n  let height: number = 10;\n  let combinedStyle: string;\n  let box: string;\n\n  function normaliseData(data: IconType): IconData | undefined {\n    let name: string;\n    let iconData: IconData;\n    if (!data) {\n      return undefined;\n    } else if ('definition' in data) {\n      console.error(\n        \"`import faIconName from '@fortawesome/package-name/faIconName` not supported - Please use `import { faIconName } from '@fortawesome/package-name/faIconName'` instead\"\n      );\n      return undefined;\n    } else if ('iconName' in data && 'icon' in data) {\n      name = data.iconName as string;\n      // fontawesome v5/6 icon imported with:\n      // import { iconName } from '@fortawesome/packagename/iconName';\n      // import { iconName } from '@fortawesome/packagename';\n      const [width, height, , , path] = data.icon as Exclude<IconType['icon'], IconData>;\n      const paths = Array.isArray(path) ? path : [path];\n      iconData = {\n        width,\n        height,\n        paths: paths.map((path) => {\n          return { d: path };\n        })\n      };\n    } else {\n      // inbuilt icons\n      name = Object.keys(data)[0];\n      iconData = data[name];\n    }\n    return iconData;\n  }\n\n  function normalisedScale() {\n    let numScale = 1;\n    if (typeof scale !== 'undefined') {\n      numScale = Number(scale);\n    }\n    if (isNaN(numScale) || numScale <= 0) {\n      console.warn('Invalid prop: prop \"scale\" should be a number over 0.');\n      return outerScale;\n    }\n    return numScale * outerScale;\n  }\n\n  function calculateBox() {\n    if (iconData) {\n      return `0 0 ${iconData.width} ${iconData.height}`;\n    }\n    return `0 0 ${width} ${height}`;\n  }\n\n  function calculateRatio() {\n    if (!iconData) {\n      return 1;\n    }\n    return Math.max(iconData.width, iconData.height) / 16;\n  }\n\n  function calculateWidth() {\n    if (childrenWidth) {\n      return childrenWidth;\n    }\n    if (iconData) {\n      return (iconData.width / calculateRatio()) * normalisedScale();\n    }\n    return 0;\n  }\n\n  function calculateHeight() {\n    if (childrenHeight) {\n      return childrenHeight;\n    }\n    if (iconData) {\n      return (iconData.height / calculateRatio()) * normalisedScale();\n    }\n    return 0;\n  }\n\n  function calculateStyle() {\n    let combined = '';\n    if (style !== null) {\n      combined += style;\n    }\n    let size = normalisedScale();\n    if (size === 1) {\n      if (combined.length === 0) {\n        return '';\n      }\n      return combined;\n    }\n    if (combined !== '' && !combined.endsWith(';')) {\n      combined += '; ';\n    }\n    return `${combined}font-size: ${size}em`;\n  }\n\n  $: {\n    iconData = normaliseData(data);\n    style;\n    scale;\n    width = calculateWidth();\n    height = calculateHeight();\n    combinedStyle = calculateStyle();\n    box = calculateBox();\n  }\n</script>\n\n<svelte:options namespace=\"svg\" />\n","<svg\n  version=\"1.1\"\n  class=\"fa-icon {className}\"\n  class:fa-spin={spin}\n  class:fa-pulse={pulse}\n  class:fa-inverse={inverse}\n  class:fa-flip-horizontal={flip === 'horizontal'}\n  class:fa-flip-vertical={flip === 'vertical'}\n  {width}\n  {height}\n  aria-label={label}\n  role={label ? 'img' : 'presentation'}\n  viewBox={box}\n  {style}\n  {...$$restProps}\n>\n  <slot />\n</svg>\n\n<style>\n  .fa-icon {\n    display: inline-block;\n    fill: currentColor;\n  }\n  .fa-flip-horizontal {\n    transform: scale(-1, 1);\n  }\n  .fa-flip-vertical {\n    transform: scale(1, -1);\n  }\n  .fa-spin {\n    animation: fa-spin 1s 0s infinite linear;\n  }\n  .fa-inverse {\n    color: #fff;\n  }\n  .fa-pulse {\n    animation: fa-spin 1s infinite steps(8);\n  }\n  @keyframes fa-spin {\n    0% {\n      transform: rotate(0deg);\n    }\n    100% {\n      transform: rotate(360deg);\n    }\n  }\n</style>\n\n<script lang=\"ts\">\n  let className: string = '';\n\n  export { className as class };\n\n  export let width: number;\n  export let height: number;\n  export let box: string = '0 0 0 0';\n\n  export let spin = false;\n  export let inverse = false;\n  export let pulse = false;\n  export let flip: string = 'none';\n\n  // optionals\n  export let style: string = '';\n  export let label: string = '';\n</script>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCheckSquare, faSquare } from '@fortawesome/free-regular-svg-icons'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import Icon from 'svelte-awesome'\n  import type { OnPatch } from '$lib/types.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let readOnly: boolean\n  export let onPatch: OnPatch\n  export let focus: () => void\n\n  function toggleBooleanValue(event: MouseEvent) {\n    event.stopPropagation()\n\n    if (readOnly) {\n      return\n    }\n\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: !value\n      }\n    ])\n\n    focus()\n  }\n</script>\n\n<div\n  role=\"checkbox\"\n  tabindex=\"-1\"\n  aria-checked={value === true}\n  class=\"jse-boolean-toggle\"\n  class:jse-readonly={readOnly}\n  on:mousedown={toggleBooleanValue}\n  title={!readOnly ? 'Click to toggle this boolean value' : `Boolean value ${value}`}\n>\n  <Icon data={value === true ? faCheckSquare : faSquare} />\n</div>\n\n<style src=\"./BooleanToggle.scss\"></style>\n","<script lang=\"ts\">\n  import { onDestroy, onMount } from 'svelte'\n\n  export let color: string\n  export let onChange: (newColor: string) => void\n  export let showOnTop: boolean\n\n  let ref: HTMLElement | undefined\n  let destroyColorPicker = () => {}\n\n  onMount(async () => {\n    // Dynamically import VanillaPicker, because it requires `document` to be defined,\n    // and that is not supported server side\n    const VanillaPicker = (await import('vanilla-picker'))?.default\n\n    const colorPicker = new VanillaPicker({\n      parent: ref,\n      color,\n      popup: showOnTop ? 'top' : 'bottom',\n      onDone: function (color) {\n        const alpha = color.rgba[3]\n        const hex =\n          alpha === 1\n            ? color.hex.substring(0, 7) // return #RRGGBB\n            : color.hex // return #RRGGBBAA\n        onChange(hex)\n      }\n    })\n\n    colorPicker.show()\n\n    destroyColorPicker = () => {\n      colorPicker.destroy()\n    }\n  })\n\n  onDestroy(() => {\n    destroyColorPicker()\n  })\n</script>\n\n<div class=\"jse-color-picker-popup\" bind:this={ref}></div>\n\n<style src=\"./ColorPickerPopup.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getColorCSS } from '$lib/utils/typeUtils.js'\n  import { getWindow } from '$lib/utils/domUtils.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { getContext } from 'svelte'\n  import ColorPickerPopup from '../../../components/controls/ColorPickerPopup.svelte'\n  import type { AbsolutePopupContext, OnPatch } from '$lib/types.js'\n\n  const { openAbsolutePopup } = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let value: string\n  export let readOnly: boolean\n  export let onPatch: OnPatch\n  export let focus: () => void\n\n  $: color = getColorCSS(value)\n  $: title = !readOnly ? 'Click to open a color picker' : `Color ${value}`\n\n  function onChange(color: string) {\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: color\n      }\n    ])\n\n    onClose()\n  }\n\n  function onClose() {\n    focus()\n  }\n\n  function openColorPicker(event: MouseEvent) {\n    if (readOnly) {\n      return\n    }\n\n    // estimate of the color picker height\n    // we'll render the color picker on top\n    // when there is not enough space below, and there is enough space above\n    const height = 300\n\n    const target = event.target as Element\n    const top = target.getBoundingClientRect().top\n    const windowHeight = getWindow(target)?.innerHeight ?? 0\n    const showOnTop = windowHeight - top < height && top > height\n\n    const props = {\n      color: value,\n      onChange,\n      showOnTop\n    }\n\n    openAbsolutePopup(ColorPickerPopup, props, {\n      anchor: target,\n      closeOnOuterClick: true,\n      onClose,\n      offsetTop: 18,\n      offsetLeft: -8,\n      height\n    })\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-color-picker-button\"\n  class:jse-readonly={readOnly}\n  style=\"background: {color}\"\n  {title}\n  aria-label={title}\n  on:click={openColorPicker}\n></button>\n\n<style src=\"./ColorPicker.scss\"></style>\n","import type { Section } from './types'\nimport { SortDirection } from './types.js'\n\nexport const SCROLL_DURATION = 300 // ms\nexport const DEBOUNCE_DELAY = 300 // ms\nexport const TEXT_MODE_ONCHANGE_DELAY = 300 // ms\nexport const AUTO_SCROLL_INTERVAL = 50 // ms\nexport const AUTO_SCROLL_SPEED_SLOW = 200 // pixels per second\nexport const AUTO_SCROLL_SPEED_NORMAL = 400 // pixels per second\nexport const AUTO_SCROLL_SPEED_FAST = 1200 // pixels per second\nexport const MAX_SEARCH_RESULTS = 1000\nexport const ARRAY_SECTION_SIZE = 100\nexport const MAX_VALIDATION_ERRORS = 100\nexport const MAX_CHARACTERS_TEXT_PREVIEW = 20000\nexport const MAX_INLINE_OBJECT_CHARS = 50\nexport const MAX_HEADER_NAME_CHARACTERS = 50\nexport const DEFAULT_VISIBLE_SECTIONS: Section[] = [{ start: 0, end: ARRAY_SECTION_SIZE }]\nexport const MAX_VALIDATABLE_SIZE = 100 * 1024 * 1024 // 1 MB\nexport const MAX_AUTO_REPAIRABLE_SIZE = 1024 * 1024 // 1 MB\nexport const MAX_DOCUMENT_SIZE_TEXT_MODE = 10 * 1024 * 1024 // 10 MB\nexport const MAX_DOCUMENT_SIZE_EXPAND_ALL = 10 * 1024 // 10 KB\n\nexport const INSERT_EXPLANATION =\n  'Insert or paste contents, ' +\n  'enter [ insert a new array, ' +\n  'enter { to insert a new object, ' +\n  'or start typing to insert a new value'\n\nexport const CONTEXT_MENU_EXPLANATION =\n  'Open context menu ' +\n  '(Click here, ' +\n  'right click on the selection, ' +\n  'or use the context menu button or Ctrl+Q)'\n\nexport const HOVER_INSERT_INSIDE = 'hover-insert-inside'\nexport const HOVER_INSERT_AFTER = 'hover-insert-after'\nexport const HOVER_COLLECTION = 'hover-collection'\n\nexport const JSON_STATUS_VALID = 'valid'\nexport const JSON_STATUS_REPAIRABLE = 'repairable'\nexport const JSON_STATUS_INVALID = 'invalid'\n\n// TODO: can we dynamically calculate the size?\nexport const CONTEXT_MENU_HEIGHT = (40 + 2) * 8 // px\nexport const CONTEXT_MENU_WIDTH = 260 // px\nexport const SEARCH_BOX_HEIGHT = 100 // px for search and replace\n\nexport const SORT_DIRECTION_NAMES = {\n  [SortDirection.asc]: 'ascending',\n  [SortDirection.desc]: 'descending'\n}\n","import { sortBy } from 'lodash-es'\nimport { ARRAY_SECTION_SIZE } from '../constants.js'\nimport type { Section } from '$lib/types.js'\n\n/**\n * Create sections that can be expanded.\n * Used to display a button like \"Show items 100-200\"\n */\nexport function getExpandItemsSections(startIndex: number, endIndex: number): Section[] {\n  // expand the start of the section\n  const section1 = {\n    start: startIndex,\n    end: Math.min(nextRoundNumber(startIndex), endIndex)\n  }\n\n  // expand the middle of the section\n  const start2 = Math.max(currentRoundNumber((startIndex + endIndex) / 2), startIndex)\n  const section2 = {\n    start: start2,\n    end: Math.min(nextRoundNumber(start2), endIndex)\n  }\n\n  // expand the end of the section\n  const currentIndex = currentRoundNumber(endIndex)\n  const previousIndex = currentIndex === endIndex ? currentIndex - ARRAY_SECTION_SIZE : currentIndex\n  const section3 = {\n    start: Math.max(previousIndex, startIndex),\n    end: endIndex\n  }\n\n  const sections = [section1]\n\n  const showSection2 = section2.start >= section1.end && section2.end <= section3.start\n  if (showSection2) {\n    sections.push(section2)\n  }\n\n  const showSection3 = section3.start >= (showSection2 ? section2.end : section1.end)\n  if (showSection3) {\n    sections.push(section3)\n  }\n\n  return sections\n}\n\n/**\n * Sort and merge a list with sections\n */\nexport function mergeSections(sections: Section[]): Section[] {\n  const sortedSections = sortBy(sections, (section) => section.start)\n\n  const mergedSections = [sortedSections[0]]\n\n  for (let sortedIndex = 0; sortedIndex < sortedSections.length; sortedIndex++) {\n    const mergedIndex = mergedSections.length - 1\n    const previous = mergedSections[mergedIndex]\n    const current = sortedSections[sortedIndex]\n\n    if (current.start <= previous.end) {\n      // there is overlap -> replace the previous item\n      mergedSections[mergedIndex] = {\n        start: Math.min(previous.start, current.start),\n        end: Math.max(previous.end, current.end)\n      }\n    } else {\n      // no overlap, just add the item\n      mergedSections.push(current)\n    }\n  }\n\n  return mergedSections\n}\n\n// TODO: write unit test\nexport function inVisibleSection(sections: Section[], index: number): boolean {\n  return sections.some((section) => {\n    return index >= section.start && index < section.end\n  })\n}\n\nexport function nextRoundNumber(index: number): number {\n  return currentRoundNumber(index) + ARRAY_SECTION_SIZE\n}\n\nexport function currentRoundNumber(index: number): number {\n  return Math.floor(index / ARRAY_SECTION_SIZE) * ARRAY_SECTION_SIZE\n}\n","import type {\n  ContentParseError,\n  ContentValidationErrors,\n  ContextMenuColumn,\n  ContextMenuRow,\n  MenuButton,\n  MenuDropDownButton,\n  MenuLabel,\n  MenuSeparator,\n  MenuSpace,\n  ValidationError,\n  NestedValidationError,\n  SvelteActionRenderer,\n  SvelteComponentRenderer,\n  RecursiveState,\n  ArrayRecursiveState,\n  ObjectRecursiveState,\n  ValueRecursiveState,\n  SearchResults,\n  WithSearchResults,\n  TreeHistoryItem,\n  HistoryItem,\n  TextHistoryItem,\n  ModeHistoryItem\n} from './types.js'\nimport { isObject } from '$lib/utils/typeUtils.js'\n\nexport function isMenuSpace(item: unknown): item is MenuSpace {\n  // checking the .space property is for backward compatibility\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'space' || item['space'] === true : false\n}\n\nexport function isMenuSeparator(item: unknown): item is MenuSeparator {\n  // checking the .separator property is for backward compatibility\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'separator' || item['separator'] === true : false\n}\n\nexport function isMenuLabel(item: unknown): item is MenuLabel {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'label' && typeof item['text'] === 'string' : false\n}\n\nexport function isMenuButton(item: unknown): item is MenuButton {\n  // for backward compatibility, we only check .onClick here and not item['type'] === 'button'\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? typeof item['onClick'] === 'function' : false\n}\n\nexport function isMenuDropDownButton(item: unknown): item is MenuDropDownButton {\n  return item\n    ? // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      item['type'] === 'dropdown-button' &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        isMenuButton(item['main']) &&\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        Array.isArray(item['items'])\n    : false\n}\n\nexport function isContextMenuRow(item: unknown): item is ContextMenuRow {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'row' && Array.isArray(item['items']) : false\n}\n\nexport function isContextMenuColumn(item: unknown): item is ContextMenuColumn {\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  return item ? item['type'] === 'column' && Array.isArray(item['items']) : false\n}\n\nexport function isContentParseError(contentErrors: unknown): contentErrors is ContentParseError {\n  return isObject(contentErrors) && isObject(contentErrors['parseError'])\n}\n\nexport function isContentValidationErrors(\n  contentErrors: unknown\n): contentErrors is ContentValidationErrors {\n  return isObject(contentErrors) && Array.isArray(contentErrors['validationErrors'])\n}\n\nexport function isValidationError(value: unknown): value is ValidationError {\n  return (\n    isObject(value) &&\n    Array.isArray(value.path) &&\n    typeof value.message === 'string' &&\n    'severity' in value\n  )\n}\n\nexport function isNestedValidationError(value: unknown): value is NestedValidationError {\n  return isObject(value) && isValidationError(value) && typeof value.isChildError === 'boolean'\n}\n\nexport function isSvelteComponentRenderer(value: unknown): value is SvelteComponentRenderer {\n  return isObject(value) && 'component' in value && isObject(value.props)\n}\n\nexport function isSvelteActionRenderer(value: unknown): value is SvelteActionRenderer {\n  return isObject(value) && typeof value.action === 'function' && isObject(value.props)\n}\n\nexport function isObjectRecursiveState(\n  state: RecursiveState | undefined\n): state is ObjectRecursiveState {\n  return state !== undefined && state.type === 'object'\n}\n\nexport function isArrayRecursiveState(\n  state: RecursiveState | undefined\n): state is ArrayRecursiveState {\n  return state !== undefined && state.type === 'array'\n}\n\nexport function isValueRecursiveState(\n  state: RecursiveState | undefined\n): state is ValueRecursiveState {\n  return state !== undefined && state.type === 'value'\n}\n\nexport function isExpandableState(\n  state: RecursiveState | undefined\n): state is ObjectRecursiveState | ArrayRecursiveState {\n  return isObjectRecursiveState(state) || isArrayRecursiveState(state)\n}\n\nexport function hasSearchResults(state: SearchResults | undefined): state is WithSearchResults {\n  return (\n    state !== undefined &&\n    Array.isArray((state as unknown as Record<string, unknown>).searchResults)\n  )\n}\n\nexport function isTreeHistoryItem(\n  historyItem: HistoryItem | undefined\n): historyItem is TreeHistoryItem {\n  return historyItem ? historyItem.type === 'tree' : false\n}\n\nexport function isTextHistoryItem(\n  historyItem: HistoryItem | undefined\n): historyItem is TextHistoryItem {\n  return historyItem ? historyItem.type === 'text' : false\n}\n\nexport function isModeHistoryItem(\n  historyItem: HistoryItem | undefined\n): historyItem is ModeHistoryItem {\n  return historyItem ? historyItem.type === 'mode' : false\n}\n","import {\n  compileJSONPointer,\n  deleteIn,\n  existsIn,\n  getIn,\n  immutableJSONPatch,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchAdd,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  isJSONPatchRemove,\n  isJSONPatchReplace,\n  type JSONPatchAdd,\n  type JSONPatchCopy,\n  type JSONPatchDocument,\n  type JSONPatchMove,\n  type JSONPatchOperation,\n  type JSONPatchRemove,\n  type JSONPath,\n  parsePath,\n  setIn,\n  updateIn\n} from 'immutable-json-patch'\nimport { initial, last } from 'lodash-es'\nimport { DEFAULT_VISIBLE_SECTIONS, MAX_DOCUMENT_SIZE_EXPAND_ALL } from '../constants.js'\nimport { forEachIndex, insertItemsAt, strictShallowEqual } from '../utils/arrayUtils.js'\nimport { isObject, isStringContainingPrimitiveValue } from '../utils/typeUtils.js'\nimport {\n  currentRoundNumber,\n  inVisibleSection,\n  mergeSections,\n  nextRoundNumber\n} from './expandItemsSections.js'\nimport type {\n  ArrayDocumentState,\n  CaretPosition,\n  DocumentState,\n  ObjectDocumentState,\n  OnExpand,\n  ArrayRecursiveState,\n  RecursiveState,\n  RecursiveStateFactory,\n  Section,\n  ValueDocumentState,\n  VisibleSection\n} from '$lib/types'\nimport { CaretType } from '$lib/types.js'\nimport { int } from '../utils/numberUtils.js'\nimport { isLargeContent } from '$lib/utils/jsonUtils.js'\nimport {\n  isArrayRecursiveState,\n  isExpandableState,\n  isObjectRecursiveState,\n  isValueRecursiveState\n} from '$lib/typeguards.js'\n\nexport type CreateRecursiveStateProps = {\n  json: unknown | undefined\n  factory: RecursiveStateFactory\n}\n\nexport function createRecursiveState({\n  json,\n  factory\n}: CreateRecursiveStateProps): RecursiveState | undefined {\n  return Array.isArray(json)\n    ? factory.createArrayDocumentState()\n    : isObject(json)\n      ? factory.createObjectDocumentState()\n      : json !== undefined\n        ? factory.createValueDocumentState()\n        : undefined\n}\n\nexport type CreateDocumentStateProps = {\n  json: unknown | undefined\n  expand?: OnExpand\n}\n\nexport function createDocumentState({\n  json,\n  expand\n}: CreateDocumentStateProps): DocumentState | undefined {\n  const documentState: DocumentState | undefined = createRecursiveState({\n    json,\n    factory: documentStateFactory\n  }) as DocumentState\n\n  return expand && documentState ? expandPath(json, documentState, [], expand) : documentState\n}\n\nexport function createArrayDocumentState({ expanded } = { expanded: false }): ArrayDocumentState {\n  return { type: 'array', expanded, visibleSections: DEFAULT_VISIBLE_SECTIONS, items: [] }\n}\n\nexport function createObjectDocumentState({ expanded } = { expanded: false }): ObjectDocumentState {\n  return { type: 'object', expanded, properties: {} }\n}\n\nexport function createValueDocumentState(): ValueDocumentState {\n  return { type: 'value' }\n}\n\nexport const documentStateFactory: RecursiveStateFactory = {\n  createObjectDocumentState,\n  createArrayDocumentState,\n  createValueDocumentState\n}\n\nexport function ensureRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath,\n  {\n    createObjectDocumentState,\n    createArrayDocumentState,\n    createValueDocumentState\n  }: RecursiveStateFactory\n): T {\n  function recurse(value: unknown, state: T | undefined, path: JSONPath): T {\n    if (Array.isArray(value)) {\n      const arrayState: ArrayRecursiveState = isArrayRecursiveState(state)\n        ? state\n        : createArrayDocumentState()\n      if (path.length === 0) {\n        return arrayState as T\n      }\n\n      const index = int(path[0])\n      const itemState = recurse(value[index], arrayState.items[index] as T, path.slice(1))\n      return setIn(arrayState, ['items', path[0]], itemState)\n    }\n\n    if (isObject(value)) {\n      const objectState = isObjectRecursiveState(state) ? state : createObjectDocumentState()\n      if (path.length === 0) {\n        return objectState as T\n      }\n\n      const key = path[0]\n      const itemState = recurse(value[key], objectState.properties[key] as T, path.slice(1))\n      return setIn(objectState, ['properties', key], itemState)\n    }\n\n    return isValueRecursiveState(state) ? state : (createValueDocumentState() as T)\n  }\n\n  return recurse(json, documentState, path)\n}\n\nexport function syncDocumentState(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath = []\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (nestedJson, nestedState) => {\n      if (nestedJson === undefined || nestedState === undefined) {\n        return undefined\n      }\n\n      if (Array.isArray(nestedJson)) {\n        if (isArrayRecursiveState(nestedState)) {\n          return nestedState\n        }\n\n        const expanded = isExpandableState(nestedState) ? nestedState.expanded : false\n        return createArrayDocumentState({ expanded })\n      }\n\n      if (isObject(nestedJson)) {\n        if (isObjectRecursiveState(nestedState)) {\n          return nestedState\n        }\n\n        const expanded = isExpandableState(nestedState) ? nestedState.expanded : false\n        return createObjectDocumentState({ expanded })\n      }\n\n      // json is of type value\n      if (isValueRecursiveState(nestedState)) {\n        return nestedState\n      }\n\n      // type of state does not match the actual type of the json\n      return undefined\n    },\n    () => true\n  )\n}\n\nfunction _transformDocumentState(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: (\n    nestedJson: unknown,\n    nestedState: DocumentState | undefined,\n    path: JSONPath\n  ) => DocumentState | undefined,\n  recurse: (nestedState: DocumentState | undefined) => boolean\n): DocumentState | undefined {\n  const updatedState = callback(json, documentState, path)\n\n  if (Array.isArray(json) && isArrayRecursiveState(updatedState) && recurse(updatedState)) {\n    const items: (DocumentState | undefined)[] = []\n\n    forEachVisibleIndex(json, updatedState.visibleSections, (index) => {\n      const itemPath = path.concat(String(index))\n      const value = json[index]\n      const item = updatedState.items[index]\n      const updatedItem = _transformDocumentState(value, item, itemPath, callback, recurse)\n      if (updatedItem !== undefined) {\n        items[index] = updatedItem\n      }\n    })\n\n    const changed = !strictShallowEqual(items, updatedState.items)\n\n    return changed ? { ...updatedState, items } : updatedState\n  }\n\n  if (isObject(json) && isObjectRecursiveState(updatedState) && recurse(updatedState)) {\n    const properties: ObjectDocumentState['properties'] = {}\n    Object.keys(json).forEach((key) => {\n      const propPath = path.concat(key)\n      const value = json[key]\n      const prop = updatedState.properties[key]\n      const updatedProp = _transformDocumentState(value, prop, propPath, callback, recurse)\n      if (updatedProp !== undefined) {\n        properties[key] = updatedProp\n      }\n    })\n\n    const changed = !strictShallowEqual(\n      Object.values(properties),\n      Object.values(updatedState.properties)\n    )\n\n    return changed ? { ...updatedState, properties } : updatedState\n  }\n\n  return updatedState\n}\n\n/**\n * Invoke a callback function for every visible item in the array\n */\nexport function forEachVisibleIndex(\n  jsonArray: Array<unknown>,\n  visibleSections: VisibleSection[],\n  callback: (index: number) => void\n) {\n  visibleSections.forEach(({ start, end }) => {\n    forEachIndex(start, Math.min(jsonArray.length, end), callback)\n  })\n}\n\nexport function expandVisibleSection(state: ArrayDocumentState, index: number): ArrayDocumentState {\n  if (inVisibleSection(state.visibleSections, index)) {\n    return state\n  }\n\n  const start = currentRoundNumber(index)\n  const end = nextRoundNumber(start)\n  const newVisibleSection = { start, end }\n\n  return {\n    ...state,\n    visibleSections: mergeSections(state.visibleSections.concat(newVisibleSection))\n  }\n}\n\nexport function toRecursiveStatePath(json: unknown, path: JSONPath): JSONPath {\n  let value = json\n  const recursiveStatePath: JSONPath = []\n\n  let i = 0\n  while (i < path.length) {\n    if (Array.isArray(value)) {\n      const index = path[i]\n      recursiveStatePath.push('items', index)\n      value = value[int(index)]\n    } else if (isObject(value)) {\n      const key = path[i]\n      recursiveStatePath.push('properties', key)\n      value = (value as Record<string, unknown>)[key]\n    } else {\n      throw new Error(`Cannot convert path: Object or Array expected at index ${i}`)\n    }\n\n    i++\n  }\n\n  return recursiveStatePath\n}\n\n/**\n * Expand all nodes along the given path, and expand invisible array sections if needed.\n * Then, optionally expand child nodes according to the provided callback.\n */\nexport function expandPath(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: OnExpand\n): DocumentState | undefined {\n  let updatedState = documentState\n\n  // Step 1: expand all nodes along the path, and update visibleSections if needed\n  for (let i = 0; i < path.length; i++) {\n    const partialPath = path.slice(0, i)\n\n    updatedState = updateInDocumentState(json, updatedState, partialPath, (_, nestedState) => {\n      const updatedState =\n        isExpandableState(nestedState) && !nestedState.expanded\n          ? { ...nestedState, expanded: true }\n          : nestedState\n\n      if (isArrayRecursiveState(updatedState)) {\n        const index = int(path[i])\n        return expandVisibleSection(updatedState, index)\n      }\n\n      return updatedState\n    })\n  }\n\n  // Step 2: recursively expand child nodes tested with the callback\n  return updateInDocumentState(json, updatedState, path, (nestedValue, nestedState) => {\n    const relativePath: JSONPath = []\n    return _expandRecursively(nestedValue, nestedState, relativePath, callback)\n  })\n}\n\nfunction _expandRecursively(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  callback: OnExpand\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (nestedJson, nestedState, nestedPath) => {\n      if (Array.isArray(nestedJson) && callback(nestedPath)) {\n        return isArrayRecursiveState(nestedState)\n          ? nestedState.expanded\n            ? nestedState\n            : { ...nestedState, expanded: true }\n          : createArrayDocumentState({ expanded: true })\n      }\n\n      if (isObject(nestedJson) && callback(nestedPath)) {\n        return isObjectRecursiveState(nestedState)\n          ? nestedState.expanded\n            ? nestedState\n            : { ...nestedState, expanded: true }\n          : createObjectDocumentState({ expanded: true })\n      }\n\n      return nestedState\n    },\n    (nestedState) => isExpandableState(nestedState) && nestedState.expanded\n  )\n}\n\nexport function collapsePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  recursive: boolean\n): DocumentState | undefined {\n  return updateInDocumentState(json, documentState, path, (nestedJson, nestedState) => {\n    return recursive ? _collapseRecursively(nestedJson, nestedState, path) : _collapse(nestedState)\n  })\n}\n\nfunction _collapse<T extends DocumentState | undefined>(documentState: T): T {\n  if (isArrayRecursiveState(documentState) && documentState.expanded) {\n    return { ...documentState, expanded: false, visibleSections: DEFAULT_VISIBLE_SECTIONS }\n  }\n\n  if (isObjectRecursiveState(documentState) && documentState.expanded) {\n    return { ...documentState, expanded: false }\n  }\n\n  return documentState\n}\n\nfunction _collapseRecursively(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): DocumentState | undefined {\n  return _transformDocumentState(\n    json,\n    documentState,\n    path,\n    (_, nestedState) => _collapse(nestedState),\n    () => true\n  )\n}\n\n/**\n * Expand a section of items in an array\n */\nexport function expandSection(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  section: Section\n): DocumentState | undefined {\n  return updateInDocumentState(json, documentState, path, (_value, state) => {\n    if (!isArrayRecursiveState(state)) {\n      return state\n    }\n\n    const visibleSections = mergeSections(state.visibleSections.concat(section))\n\n    return { ...state, visibleSections }\n  })\n}\n\nexport function syncKeys(actualKeys: string[], prevKeys?: string[]): string[] {\n  if (!prevKeys) {\n    return actualKeys\n  }\n\n  // copy the keys that still exist\n  const actualKeysSet = new Set(actualKeys)\n  const keys = prevKeys.filter((key) => actualKeysSet.has(key))\n\n  // add new keys\n  const keysSet = new Set(keys)\n  actualKeys.filter((key) => !keysSet.has(key)).forEach((key) => keys.push(key))\n\n  return keys\n}\n\n/**\n * Apply patch operations to both json and state\n */\nexport function documentStatePatch(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operations: JSONPatchDocument\n): { json: unknown; documentState: DocumentState | undefined } {\n  const initial = { json, documentState }\n\n  const result = operations.reduce((current, operation) => {\n    return {\n      json: immutableJSONPatch(current.json, [operation]),\n      documentState: _documentStatePatch(current.json, current.documentState, operation)\n    }\n  }, initial)\n\n  return {\n    json: result.json,\n    documentState: syncDocumentState(result.json, result.documentState) // sync to clean up leftover state\n  }\n}\n\nfunction _documentStatePatch(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchOperation\n): DocumentState | undefined {\n  if (isJSONPatchAdd(operation)) {\n    return documentStateAdd(json, documentState, operation, undefined)\n  }\n\n  if (isJSONPatchRemove(operation)) {\n    return documentStateRemove(json, documentState, operation)\n  }\n\n  if (isJSONPatchReplace(operation)) {\n    const path = parsePath(json, operation.path)\n    const enforceString = getEnforceString(json, documentState, path)\n    if (enforceString) {\n      // ensure the enforceString setting is not lost when for example changing \"123\"\n      // into \"abc\" and later back to \"123\", so we now make it explicit.\n      return setInDocumentState(json, documentState, path, { type: 'value', enforceString })\n    }\n\n    // nothing special to do (all is handled by syncDocumentState)\n    return documentState\n  }\n\n  if (isJSONPatchCopy(operation) || isJSONPatchMove(operation)) {\n    return documentStateMoveOrCopy(json, documentState, operation)\n  }\n\n  return documentState\n}\n\nexport function getInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath\n): T | undefined {\n  try {\n    return getIn(documentState, toRecursiveStatePath(json, path))\n  } catch {\n    return undefined\n  }\n}\n\nexport function setInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  recursiveState: T | undefined,\n  path: JSONPath,\n  value: unknown,\n  factory: RecursiveStateFactory\n): T | undefined {\n  const ensuredState = ensureRecursiveState(json, recursiveState, path, factory)\n  return setIn(ensuredState, toRecursiveStatePath(json, path), value)\n}\n\nexport function updateInRecursiveState<T extends RecursiveState>(\n  json: unknown,\n  documentState: T | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: T) => T | undefined,\n  factory: RecursiveStateFactory\n): T {\n  const ensuredState: T = ensureRecursiveState(json, documentState, path, factory)\n  return updateIn(ensuredState, toRecursiveStatePath(json, path), (nestedState: T) => {\n    const value = getIn(json, path)\n    return transform(value, nestedState)\n  })\n}\n\nexport function setInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath,\n  value: unknown\n): T | undefined {\n  return setInRecursiveState(json, documentState, path, value, documentStateFactory)\n}\n\nexport function updateInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: T) => T | undefined\n): T {\n  return updateInRecursiveState(json, documentState, path, transform, documentStateFactory)\n}\n\nexport function deleteInDocumentState<T extends RecursiveState>(\n  json: unknown | undefined,\n  documentState: T | undefined,\n  path: JSONPath\n): T | undefined {\n  const recursivePath = toRecursiveStatePath(json, path)\n\n  return existsIn(documentState, recursivePath)\n    ? deleteIn(documentState, toRecursiveStatePath(json, path))\n    : documentState\n}\n\nexport function documentStateAdd(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchAdd,\n  stateValue: DocumentState | undefined\n): DocumentState | undefined {\n  const path = parsePath(json, operation.path)\n  const parentPath = initial(path)\n\n  let updatedState = documentState\n\n  updatedState = updateInDocumentState(json, updatedState, parentPath, (_parent, arrayState) => {\n    if (!isArrayRecursiveState(arrayState)) {\n      return arrayState\n    }\n\n    const index = int(last(path) as string)\n    const { items, visibleSections } = arrayState\n    return {\n      ...arrayState,\n      items:\n        index < items.length\n          ? insertItemsAt(items, index, stateValue !== undefined ? [stateValue] : Array(1))\n          : items,\n      visibleSections: shiftVisibleSections(visibleSections, index, 1)\n    }\n  })\n\n  // object property added, nothing to do\n  return setInDocumentState(json, updatedState, path, stateValue)\n}\n\nexport function documentStateRemove(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchRemove\n): DocumentState | undefined {\n  const path = parsePath(json, operation.path)\n  const parentPath = initial(path)\n  const parent = getIn(json, parentPath)\n\n  if (Array.isArray(parent)) {\n    return updateInDocumentState(json, documentState, parentPath, (_parent, arrayState) => {\n      if (!isArrayRecursiveState(arrayState)) {\n        return arrayState\n      }\n\n      const index = int(last(path) as string)\n      const { items, visibleSections } = arrayState\n\n      return {\n        ...arrayState,\n        items: items.slice(0, index).concat(items.slice(index + 1)),\n        visibleSections: shiftVisibleSections(visibleSections, index, -1)\n      }\n    })\n  }\n\n  return deleteInDocumentState(json, documentState, path)\n}\n\nexport function documentStateMoveOrCopy(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  operation: JSONPatchCopy | JSONPatchMove\n): DocumentState | undefined {\n  if (isJSONPatchMove(operation) && operation.from === operation.path) {\n    // nothing to do\n    return documentState\n  }\n\n  let updatedState = documentState\n\n  // get the state that we will move or copy\n  const from = parsePath(json, operation.from)\n  const stateValue = getInRecursiveState(json, updatedState, from)\n\n  if (isJSONPatchMove(operation)) {\n    updatedState = documentStateRemove(json, updatedState, {\n      op: 'remove',\n      path: operation.from\n    })\n  }\n\n  updatedState = documentStateAdd(\n    json,\n    updatedState,\n    {\n      op: 'add',\n      path: operation.path,\n      value: null // note that the value is not actually used, so we just use null instead of getting the actual value from the json\n    },\n    stateValue\n  )\n\n  return updatedState\n}\n\n/**\n * Shift visible sections in an Array with a specified offset\n */\nexport function shiftVisibleSections(\n  visibleSections: VisibleSection[],\n  index: number,\n  offset: number\n): VisibleSection[] {\n  const shiftedSections = visibleSections.map((section) => {\n    return {\n      start: section.start > index ? section.start + offset : section.start,\n      end: section.end > index ? section.end + offset : section.end\n    }\n  })\n\n  return mergeAdjacentSections(shiftedSections)\n}\n\n// merge adjacent sections like [{start:0, end:100}, {start:100, end:200}] into [{start:0, end:200}]\nfunction mergeAdjacentSections(visibleSections: VisibleSection[]): VisibleSection[] {\n  const merged = visibleSections.slice(0)\n\n  let i = 1\n  while (i < merged.length) {\n    if (merged[i - 1].end === merged[i].start) {\n      merged[i - 1] = {\n        start: merged[i - 1].start,\n        end: merged[i].end\n      }\n      merged.splice(i)\n    }\n    i++\n  }\n\n  return merged\n}\n\nexport function getEnforceString(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): boolean {\n  const value = getIn(json, path)\n  const nestedState = getInRecursiveState(json, documentState, path)\n  const enforceString = isValueRecursiveState(nestedState) ? nestedState.enforceString : undefined\n\n  if (typeof enforceString === 'boolean') {\n    return enforceString\n  }\n\n  return isStringContainingPrimitiveValue(value)\n}\n\nexport function getNextKeys(keys: string[], key: string, includeKey = false): string[] {\n  const index = keys.indexOf(key)\n  if (index !== -1) {\n    return includeKey ? keys.slice(index) : keys.slice(index + 1)\n  } else {\n    // a new key, that doesn't have next keys\n    return []\n  }\n}\n\n/**\n * Get all paths which are visible and rendered\n */\n// TODO: create memoized version of getVisiblePaths which remembers just the previous result if json and state are the same\nexport function getVisiblePaths(\n  json: unknown,\n  documentState: DocumentState | undefined\n): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  function _recurse(value: unknown, state: DocumentState | undefined, path: JSONPath) {\n    paths.push(path)\n\n    if (isJSONArray(value) && isArrayRecursiveState(state) && state.expanded) {\n      forEachVisibleIndex(value, state.visibleSections, (index) => {\n        _recurse(value[index], state.items[index], path.concat(String(index)))\n      })\n    }\n\n    if (isJSONObject(value) && isObjectRecursiveState(state) && state.expanded) {\n      Object.keys(value).forEach((key) => {\n        _recurse(value[key], state.properties[key], path.concat(key))\n      })\n    }\n  }\n\n  _recurse(json, documentState, [])\n\n  return paths\n}\n\n/**\n * Get all caret position which are visible and rendered:\n * before a node, at a key, at a value, appending an object/array\n */\n// TODO: create memoized version of getVisibleCaretPositions which remembers just the previous result if json and state are the same\nexport function getVisibleCaretPositions(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  includeInside = true\n): CaretPosition[] {\n  const paths: CaretPosition[] = []\n\n  function _recurse(value: unknown, path: JSONPath) {\n    paths.push({ path, type: CaretType.value })\n\n    const valueState = getInRecursiveState(json, documentState, path)\n    if (value && isExpandableState(valueState) && valueState.expanded) {\n      if (includeInside) {\n        paths.push({ path, type: CaretType.inside })\n      }\n\n      if (isJSONArray(value)) {\n        const visibleSections = isArrayRecursiveState(valueState)\n          ? valueState.visibleSections\n          : DEFAULT_VISIBLE_SECTIONS\n        forEachVisibleIndex(value, visibleSections, (index) => {\n          const itemPath = path.concat(String(index))\n\n          _recurse(value[index], itemPath)\n\n          if (includeInside) {\n            paths.push({ path: itemPath, type: CaretType.after })\n          }\n        })\n      }\n\n      if (isJSONObject(value)) {\n        const keys = Object.keys(value)\n        keys.forEach((key) => {\n          const propertyPath = path.concat(key)\n\n          paths.push({ path: propertyPath, type: CaretType.key })\n\n          _recurse(value[key], propertyPath)\n\n          if (includeInside) {\n            paths.push({ path: propertyPath, type: CaretType.after })\n          }\n        })\n      }\n    }\n  }\n\n  _recurse(json, [])\n\n  return paths\n}\n\n/**\n * Find the previous visible path.\n * This can be the last child of the previous object or array, or the parent of a first entry.\n */\n// TODO: write tests for getPreviousVisiblePath\nexport function getPreviousVisiblePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONPath | undefined {\n  const visiblePaths = getVisiblePaths(json, documentState)\n  const visiblePathPointers = visiblePaths.map(compileJSONPointer)\n  const pathPointer = compileJSONPointer(path)\n  const index = visiblePathPointers.indexOf(pathPointer)\n\n  if (index !== -1 && index > 0) {\n    return visiblePaths[index - 1]\n  }\n\n  return undefined\n}\n\n/**\n * Find the next visible path.\n * This can be the next parent entry.\n */\n// TODO: write tests for getNextVisiblePath\nexport function getNextVisiblePath(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONPath | undefined {\n  const visiblePaths = getVisiblePaths(json, documentState)\n  const visiblePathPointers = visiblePaths.map(compileJSONPointer)\n  const index = visiblePathPointers.indexOf(compileJSONPointer(path))\n\n  if (index !== -1 && index < visiblePaths.length - 1) {\n    return visiblePaths[index + 1]\n  }\n\n  return undefined\n}\n\n/**\n * Expand recursively when the expanded contents is small enough,\n * else expand in a minimalistic way\n */\nexport function expandSmart(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath,\n  maxSize: number = MAX_DOCUMENT_SIZE_EXPAND_ALL\n): DocumentState | undefined {\n  const nestedJson = getIn(json, path)\n  const callback = isLargeContent({ json: nestedJson }, maxSize) ? expandMinimal : expandAll\n\n  return expandPath(json, documentState, path, callback)\n}\n\nexport function expandSmartIfCollapsed(\n  json: unknown | undefined,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n) {\n  const nestedState = getInRecursiveState(json, documentState, path)\n  const isExpanded = isExpandableState(nestedState) ? nestedState.expanded : false\n\n  return isExpanded ? documentState : expandSmart(json, documentState, path)\n}\n\n/**\n * Expand the root array or object, and in case of an array, expand the first array item\n */\nexport function expandMinimal(relativePath: JSONPath): boolean {\n  // first item of an array\n  return relativePath.length === 0 ? true : relativePath.length === 1 && relativePath[0] === '0'\n}\n\n/**\n * Expand the root array or object\n */\nexport function expandSelf(relativePath: JSONPath): boolean {\n  return relativePath.length === 0\n}\n\nexport function expandAll(): boolean {\n  return true\n}\n\nexport function expandNone(): boolean {\n  return false\n}\n","import {\n  getIn,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  type JSONPatchDocument,\n  type JSONPatchOperation,\n  type JSONPath,\n  parsePath\n} from 'immutable-json-patch'\nimport { first, initial, isEmpty, isEqual, last } from 'lodash-es'\nimport { isObjectOrArray } from '$lib/utils/typeUtils.js'\nimport {\n  collapsePath,\n  getNextVisiblePath,\n  getPreviousVisiblePath,\n  getVisibleCaretPositions,\n  getVisiblePaths\n} from './documentState.js'\nimport type {\n  AfterSelection,\n  CaretPosition,\n  DocumentState,\n  EditKeySelection,\n  EditValueSelection,\n  InsideSelection,\n  JSONEditorSelection,\n  JSONParser,\n  JSONSelection,\n  KeySelection,\n  MultiSelection,\n  TextSelection,\n  ValueSelection\n} from '../types.js'\nimport { CaretType, SelectionType } from '$lib/types.js'\nimport { int } from '$lib/utils/numberUtils.js'\n\nexport function isAfterSelection(\n  selection: JSONEditorSelection | undefined\n): selection is AfterSelection {\n  return (selection && selection.type === SelectionType.after) || false\n}\n\nexport function isInsideSelection(\n  selection: JSONEditorSelection | undefined\n): selection is InsideSelection {\n  return (selection && selection.type === SelectionType.inside) || false\n}\n\nexport function isKeySelection(\n  selection: JSONEditorSelection | undefined\n): selection is KeySelection {\n  return (selection && selection.type === SelectionType.key) || false\n}\n\nexport function isValueSelection(\n  selection: JSONEditorSelection | undefined\n): selection is ValueSelection {\n  return (selection && selection.type === SelectionType.value) || false\n}\n\nexport function isMultiSelection(\n  selection: JSONEditorSelection | undefined\n): selection is MultiSelection {\n  return (selection && selection.type === SelectionType.multi) || false\n}\n\nexport function isMultiSelectionWithOneItem(\n  selection: JSONEditorSelection | undefined\n): selection is MultiSelection {\n  return isMultiSelection(selection) && isEqual(selection.focusPath, selection.anchorPath)\n}\n\nexport function isJSONSelection(\n  selection: JSONEditorSelection | undefined\n): selection is JSONSelection {\n  return (\n    isMultiSelection(selection) ||\n    isAfterSelection(selection) ||\n    isInsideSelection(selection) ||\n    isKeySelection(selection) ||\n    isValueSelection(selection)\n  )\n}\n\nexport function isTextSelection(\n  selection: JSONEditorSelection | undefined\n): selection is TextSelection {\n  return (selection && selection.type === SelectionType.text) || false\n}\n\n/**\n * Expand a selection start and end into an array containing all paths\n * between (and including) start and end\n */\nexport function getSelectionPaths(json: unknown, selection: JSONSelection): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  iterateOverSelection(json, selection, (path) => {\n    paths.push(path)\n  })\n\n  return paths\n}\n\n/**\n * Expand a selection start and end into an array containing all paths\n * between (and including) start and end.\n *\n * The function iterates always from start to end, independent of the order\n * of focusPath and anchorPath.\n *\n * When the callback returns something other than undefined, the iteration is\n * canceled and the value returned by the callback is returned by iterateOverSelection.\n */\nexport function iterateOverSelection<T>(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  callback: (path: JSONPath) => void | undefined | T\n): void | undefined | T {\n  if (!selection) {\n    return undefined\n  }\n\n  const anchorPath = getAnchorPath(selection)\n  const focusPath = getFocusPath(selection)\n\n  if (isEqual(anchorPath, focusPath)) {\n    // just a single node\n    return callback(anchorPath)\n  } else {\n    // multiple nodes\n    if (json === undefined) {\n      return undefined\n    }\n\n    const sharedPath = findSharedPath(anchorPath, focusPath)\n\n    if (anchorPath.length === sharedPath.length || focusPath.length === sharedPath.length) {\n      // a parent and a child, like ['arr', 1] and ['arr']\n      return callback(sharedPath)\n    }\n\n    const selection = createMultiSelection(anchorPath, focusPath)\n    const startPath = getStartPath(json, selection)\n    const endPath = getEndPath(json, selection)\n\n    const startIndex = getChildIndex(json, selection, startPath)\n    const endIndex = getChildIndex(json, selection, endPath)\n\n    if (startIndex === -1 || endIndex === -1) {\n      return undefined\n    }\n\n    const value = getIn(json, sharedPath)\n\n    if (isJSONObject(value)) {\n      const keys = Object.keys(value)\n\n      for (let i = startIndex; i <= endIndex; i++) {\n        const value = callback(sharedPath.concat(keys[i]))\n        if (value !== undefined) {\n          return value\n        }\n      }\n\n      return undefined\n    }\n\n    if (isJSONArray(value)) {\n      for (let i = startIndex; i <= endIndex; i++) {\n        const value = callback(sharedPath.concat(String(i)))\n        if (value !== undefined) {\n          return value\n        }\n      }\n\n      return undefined\n    }\n  }\n\n  throw new Error('Failed to create selection')\n}\n\nexport function getParentPath(selection: JSONSelection): JSONPath {\n  if (isInsideSelection(selection)) {\n    return selection.path\n  } else {\n    return initial(getFocusPath(selection))\n  }\n}\n\nexport function getStartPath(json: unknown, selection: JSONSelection): JSONPath {\n  if (!isMultiSelection(selection)) {\n    return selection.path\n  }\n\n  const anchorIndex = getChildIndex(json, selection, selection.anchorPath)\n  const focusIndex = getChildIndex(json, selection, selection.focusPath)\n\n  return focusIndex < anchorIndex ? selection.focusPath : selection.anchorPath\n}\n\nexport function getEndPath(json: unknown, selection: JSONSelection): JSONPath {\n  if (!isMultiSelection(selection)) {\n    return selection.path\n  }\n\n  const anchorIndex = getChildIndex(json, selection, selection.anchorPath)\n  const focusIndex = getChildIndex(json, selection, selection.focusPath)\n\n  return focusIndex > anchorIndex ? selection.focusPath : selection.anchorPath\n}\n\n// TODO: write unit test\nexport function isSelectionInsidePath(selection: JSONSelection, path: JSONPath): boolean {\n  return (\n    pathStartsWith(getFocusPath(selection), path) &&\n    (getFocusPath(selection).length > path.length || isInsideSelection(selection))\n  )\n}\n\nexport function getSelectionUp(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const focusPath = keepAnchorPath ? getFocusPath(selection) : getStartPath(json, selection)\n  const previousPath = getPreviousVisiblePath(json, documentState, focusPath)\n\n  if (keepAnchorPath) {\n    // create a multi-selection with multiple nodes\n    if (isInsideSelection(selection) || isAfterSelection(selection)) {\n      return previousPath !== undefined ? createMultiSelection(focusPath, focusPath) : undefined\n    }\n\n    return previousPath !== undefined\n      ? createMultiSelection(getAnchorPath(selection), previousPath)\n      : undefined\n  }\n\n  if (isAfterSelection(selection)) {\n    // select the node itself, not the previous node,\n    // FIXME: when after an expanded object/array, should go to the last item inside the object/array\n    return createValueSelection(focusPath)\n  }\n\n  if (isInsideSelection(selection)) {\n    // select the node itself, not the previous node,\n    return createValueSelection(focusPath)\n  }\n\n  if (isKeySelection(selection)) {\n    if (previousPath === undefined || previousPath.length === 0) {\n      return undefined\n    }\n\n    const parentPath = initial(previousPath)\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent) || isEmpty(previousPath)) {\n      // switch to value selection: array has no keys, and root object also not\n      return createValueSelection(previousPath)\n    } else {\n      return createKeySelection(previousPath)\n    }\n  }\n\n  if (isValueSelection(selection)) {\n    return previousPath !== undefined ? createValueSelection(previousPath) : undefined\n  }\n\n  if (previousPath !== undefined) {\n    return createValueSelection(previousPath)\n  }\n\n  return undefined\n}\n\nexport function getSelectionDown(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n  const focusPath = keepAnchorPath ? getFocusPath(selection) : getEndPath(json, selection)\n\n  // if the focusPath is an Array or object, we must not step into it but\n  // over it, we pass state with this array/object collapsed\n  const collapsedState = isObjectOrArray(getIn(json, focusPath))\n    ? collapsePath(json, documentState, focusPath, true)\n    : documentState\n\n  const nextPath = getNextVisiblePath(json, documentState, focusPath)\n  const nextPathAfter = getNextVisiblePath(json, collapsedState, focusPath)\n\n  if (keepAnchorPath) {\n    // create a multi-selection with multiple nodes\n    if (isInsideSelection(selection)) {\n      return nextPath !== undefined ? createMultiSelection(nextPath, nextPath) : undefined\n    }\n\n    if (isAfterSelection(selection)) {\n      return nextPathAfter !== undefined\n        ? createMultiSelection(nextPathAfter, nextPathAfter)\n        : undefined\n    }\n\n    return nextPathAfter !== undefined\n      ? createMultiSelection(getAnchorPath(selection), nextPathAfter)\n      : undefined\n  }\n\n  if (isAfterSelection(selection)) {\n    return nextPathAfter !== undefined ? createValueSelection(nextPathAfter) : undefined\n  }\n\n  if (isInsideSelection(selection)) {\n    return nextPath !== undefined ? createValueSelection(nextPath) : undefined\n  }\n\n  if (isValueSelection(selection)) {\n    return nextPath !== undefined ? createValueSelection(nextPath) : undefined\n  }\n\n  if (isKeySelection(selection)) {\n    if (nextPath === undefined || nextPath.length === 0) {\n      return undefined\n    }\n\n    const parentPath = initial(nextPath) // not nextPathAfter!\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent)) {\n      // switch to value selection: array has no keys\n      return createValueSelection(nextPath)\n    } else {\n      return createKeySelection(nextPath)\n    }\n  }\n\n  if (isMultiSelection(selection)) {\n    return nextPathAfter !== undefined\n      ? createValueSelection(nextPathAfter)\n      : nextPath !== undefined\n        ? createValueSelection(nextPath)\n        : undefined\n  }\n\n  return undefined\n}\n\n/**\n * Get the next selection for a value inside the current object/array\n * If there is no next value, select AFTER.\n * Only applicable for ValueSelection\n */\nexport function getSelectionNextInside(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  path: JSONPath\n): JSONSelection | undefined {\n  // TODO: write unit tests for getSelectionNextInside\n  const parentPath = initial(path)\n  const childPath = [last(path) as string]\n\n  const parent: unknown | undefined = getIn(json, parentPath)\n  const nextPathInside = parent ? getNextVisiblePath(parent, documentState, childPath) : undefined\n\n  if (nextPathInside) {\n    return createValueSelection(parentPath.concat(nextPathInside))\n  } else {\n    return createAfterSelection(path)\n  }\n}\n\n/**\n * Find the caret position and its siblings for a given selection\n */\n// TODO: unit test\nexport function findCaretAndSiblings(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  includeInside: boolean\n): {\n  next: CaretPosition | undefined\n  caret: CaretPosition | undefined\n  previous: CaretPosition | undefined\n} {\n  if (!selection) {\n    return { caret: undefined, previous: undefined, next: undefined }\n  }\n  const visibleCaretPositions = getVisibleCaretPositions(json, documentState, includeInside)\n\n  const index = visibleCaretPositions.findIndex((caret) => {\n    return (\n      isEqual(caret.path, getFocusPath(selection)) && String(caret.type) === String(selection.type)\n    )\n  })\n\n  return {\n    caret: index !== -1 ? visibleCaretPositions[index] : undefined,\n\n    previous: index !== -1 && index > 0 ? visibleCaretPositions[index - 1] : undefined,\n\n    next:\n      index !== -1 && index < visibleCaretPositions.length - 1\n        ? visibleCaretPositions[index + 1]\n        : undefined\n  }\n}\n\nexport function getSelectionLeft(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false,\n  includeInside = true\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const { caret, previous } = findCaretAndSiblings(json, documentState, selection, includeInside)\n\n  if (keepAnchorPath) {\n    if (!isMultiSelection(selection)) {\n      return createMultiSelection(selection.path, selection.path)\n    }\n\n    return undefined\n  }\n\n  if (caret && previous) {\n    return fromCaretPosition(previous)\n  }\n\n  const parentPath = initial(getFocusPath(selection))\n  const parent = getIn(json, parentPath)\n\n  if (isValueSelection(selection) && Array.isArray(parent)) {\n    return createMultiSelection(selection.path, selection.path)\n  }\n\n  if (isMultiSelection(selection) && !Array.isArray(parent)) {\n    return createKeySelection(selection.focusPath)\n  }\n\n  return undefined\n}\n\nexport function getSelectionRight(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  selection: JSONSelection | undefined,\n  keepAnchorPath = false,\n  includeInside = true\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  const { caret, next } = findCaretAndSiblings(json, documentState, selection, includeInside)\n\n  if (keepAnchorPath) {\n    if (!isMultiSelection(selection)) {\n      return createMultiSelection(selection.path, selection.path)\n    }\n\n    return undefined\n  }\n\n  if (caret && next) {\n    return fromCaretPosition(next)\n  }\n\n  if (isMultiSelection(selection)) {\n    return createValueSelection(selection.focusPath)\n  }\n\n  return undefined\n}\n\n/**\n * Get a proper initial selection based on what is visible\n */\nexport function getInitialSelection(\n  json: unknown,\n  documentState: DocumentState | undefined\n): JSONSelection {\n  const visiblePaths = getVisiblePaths(json, documentState)\n\n  // find the first, deepest nested entry (normally a value, not an Object/Array)\n  let index = 0\n  while (\n    index < visiblePaths.length - 1 &&\n    visiblePaths[index + 1].length > visiblePaths[index].length\n  ) {\n    index++\n  }\n\n  const path = visiblePaths[index]\n  return path === undefined || path.length === 0 || Array.isArray(getIn(json, initial(path)))\n    ? createValueSelection(path) // Array items and root object/array do not have a key, so select value in that case\n    : createKeySelection(path)\n}\n\nexport function createSelectionFromOperations(\n  json: unknown,\n  operations: JSONPatchDocument\n): JSONSelection | undefined {\n  if (operations.length === 1) {\n    const operation = first(operations) as JSONPatchOperation\n    if (operation.op === 'replace') {\n      // a replaced value\n      const path = parsePath(json, operation.path)\n\n      return createValueSelection(path)\n    }\n  }\n\n  if (!isEmpty(operations) && operations.every((operation) => operation.op === 'move')) {\n    const firstOp = first(operations)\n    const otherOps = operations.slice(1)\n\n    if (\n      (isJSONPatchCopy(firstOp) || isJSONPatchMove(firstOp)) &&\n      firstOp.from !== firstOp.path &&\n      otherOps.every((op) => (isJSONPatchCopy(op) || isJSONPatchMove(op)) && op.from === op.path)\n    ) {\n      // a renamed key\n      const path = parsePath(json, firstOp.path)\n\n      return createKeySelection(path)\n    }\n  }\n\n  const paths = operations\n    .filter((operation) => {\n      return (\n        operation.op !== 'test' &&\n        operation.op !== 'remove' &&\n        (operation.op !== 'move' || operation.from !== operation.path) &&\n        typeof operation.path === 'string'\n      )\n    })\n    .map((operation) => parsePath(json, operation.path))\n\n  if (isEmpty(paths)) {\n    return undefined\n  }\n\n  // TODO: make this function robust against operations which do not have consecutive paths or have wrongly ordered paths\n\n  return {\n    type: SelectionType.multi,\n    anchorPath: first(paths) as JSONPath,\n    focusPath: last(paths) as JSONPath\n  }\n}\n\n/**\n * Find the common path of two paths.\n * For example findCommonRoot(['arr', '1', 'name'], ['arr', '1', 'address', 'contact']) returns ['arr', '1']\n */\n// TODO: write unit tests for findSharedPath\nexport function findSharedPath(path1: JSONPath, path2: JSONPath): JSONPath {\n  let i = 0\n  while (i < path1.length && i < path2.length && path1[i] === path2[i]) {\n    i++\n  }\n\n  return path1.slice(0, i)\n}\n\nexport function singleItemSelected(selection: JSONSelection | undefined): boolean {\n  return (\n    isKeySelection(selection) ||\n    isValueSelection(selection) ||\n    isMultiSelectionWithOneItem(selection)\n  )\n}\n\nexport function findRootPath(json: unknown, selection: JSONSelection): JSONPath {\n  return singleItemSelected(selection) && isObjectOrArray(getIn(json, getFocusPath(selection)))\n    ? getFocusPath(selection)\n    : initial(getFocusPath(selection)) // the parent path of the paths\n}\n\nexport function pathStartsWith(path: JSONPath, parentPath: JSONPath): boolean {\n  if (path.length < parentPath.length) {\n    return false\n  }\n\n  for (let i = 0; i < parentPath.length; i++) {\n    if (path[i] !== parentPath[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n// TODO: write unit tests\nexport function removeEditModeFromSelection(\n  selection: JSONSelection | undefined\n): JSONSelection | undefined {\n  if (isEditingSelection(selection)) {\n    const { type, path } = selection\n    return { type, path } as KeySelection | ValueSelection\n  }\n\n  return selection\n}\n\nexport function createKeySelection(path: JSONPath): KeySelection {\n  return { type: SelectionType.key, path }\n}\n\nexport function createEditKeySelection(path: JSONPath, initialValue?: string): EditKeySelection {\n  return { type: SelectionType.key, path, edit: true, initialValue }\n}\n\nexport function createValueSelection(path: JSONPath): ValueSelection {\n  return { type: SelectionType.value, path }\n}\n\nexport function createEditValueSelection(\n  path: JSONPath,\n  initialValue?: string\n): EditValueSelection {\n  return { type: SelectionType.value, path, edit: true, initialValue }\n}\n\nexport function createInsideSelection(path: JSONPath): InsideSelection {\n  return {\n    type: SelectionType.inside,\n    path\n  }\n}\n\nexport function createAfterSelection(path: JSONPath): AfterSelection {\n  return {\n    type: SelectionType.after,\n    path\n  }\n}\n\nexport function createMultiSelection(anchorPath: JSONPath, focusPath: JSONPath): MultiSelection {\n  // normalize the paths to both be a child of a shared parent\n  const sharedPath = findSharedPath(anchorPath, focusPath)\n  const isParent = anchorPath.length > sharedPath.length && focusPath.length > sharedPath.length\n\n  return {\n    type: SelectionType.multi,\n    anchorPath: isParent ? sharedPath.concat(anchorPath[sharedPath.length]) : sharedPath,\n    focusPath: isParent ? sharedPath.concat(focusPath[sharedPath.length]) : sharedPath\n  }\n}\n\n/**\n * Turn selected contents into plain text partial JSON, usable for copying to\n * clipboard for example.\n */\nexport function selectionToPartialJson(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  indentation: number | string | undefined,\n  parser: JSONParser\n): string | undefined {\n  if (isKeySelection(selection)) {\n    return String(last(selection.path))\n  }\n\n  if (isValueSelection(selection)) {\n    const value = getIn(json, selection.path)\n    return typeof value === 'string' ? value : parser.stringify(value, null, indentation) // TODO: customizable indentation?\n  }\n\n  if (isMultiSelection(selection)) {\n    if (isEmpty(selection.focusPath)) {\n      // root object -> does not have a parent key/index\n      return parser.stringify(json, null, indentation)\n    }\n\n    const parentPath = getParentPath(selection)\n    const parent = getIn(json, parentPath)\n    if (Array.isArray(parent)) {\n      if (isMultiSelectionWithOneItem(selection)) {\n        // do not suffix a single selected array item with a comma\n        const item = getIn(json, selection.focusPath)\n        return parser.stringify(item, null, indentation)\n      } else {\n        return getSelectionPaths(json, selection)\n          .map((path) => {\n            const item = getIn(json, path)\n            return `${parser.stringify(item, null, indentation)},`\n          })\n          .join('\\n')\n      }\n    } else {\n      // parent is Object\n      return getSelectionPaths(json, selection)\n        .map((path) => {\n          const key = last(path)\n          const value = getIn(json, path)\n          return `${parser.stringify(key)}: ${parser.stringify(value, null, indentation)},`\n        })\n        .join('\\n')\n    }\n  }\n\n  return undefined\n}\n\nexport function isEditingSelection(\n  selection: JSONSelection | undefined\n): selection is EditKeySelection | EditValueSelection {\n  return (\n    (isKeySelection(selection) || isValueSelection(selection)) &&\n    (selection as Record<string, unknown>).edit === true\n  )\n}\n\n/**\n * Create a selection which selects the root of the document\n */\n// TODO: write unit tests\nexport function selectAll(): JSONSelection {\n  return createValueSelection([])\n}\n\n// TODO: write unit tests\nexport function hasSelectionContents(selection: JSONSelection | undefined): boolean {\n  return isKeySelection(selection) || isValueSelection(selection) || isMultiSelection(selection)\n}\n\n/**\n * Test whether the current selection can be converted.\n * That is the case when the selection is a key/value, or a multi selection with only one path\n */\nexport function canConvert(selection: JSONSelection | undefined): boolean {\n  return (\n    isKeySelection(selection) ||\n    isValueSelection(selection) ||\n    isMultiSelectionWithOneItem(selection)\n  )\n}\n\n// TODO: unit test\n// eslint-disable-next-line consistent-return\nexport function fromCaretPosition(caretPosition: CaretPosition): JSONSelection {\n  switch (caretPosition.type) {\n    case CaretType.key:\n      return createKeySelection(caretPosition.path)\n    case CaretType.value:\n      return createValueSelection(caretPosition.path)\n    case CaretType.after:\n      return createAfterSelection(caretPosition.path)\n    case CaretType.inside:\n      return createInsideSelection(caretPosition.path)\n  }\n}\n\n// TODO: unit test\n// eslint-disable-next-line consistent-return\nexport function fromSelectionType(selectionType: SelectionType, path: JSONPath): JSONSelection {\n  switch (selectionType) {\n    case SelectionType.key:\n      return createKeySelection(path)\n    case SelectionType.value:\n      return createValueSelection(path)\n    case SelectionType.after:\n      return createAfterSelection(path)\n    case SelectionType.inside:\n      return createInsideSelection(path)\n    case SelectionType.multi:\n    case SelectionType.text: // type `text` is not applicable, but we need to handle all types\n      return createMultiSelection(path, path)\n  }\n}\n\nexport function selectionIfOverlapping(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  path: JSONPath\n): JSONSelection | undefined {\n  if (!selection) {\n    return undefined\n  }\n\n  if (pathInSelection(json, selection, path)) {\n    return selection\n  }\n\n  const sharedPath = isMultiSelection(selection) ? initial(selection.focusPath) : selection.path\n  if (pathStartsWith(sharedPath, path)) {\n    return selection\n  }\n\n  return undefined\n}\n\nexport function pathInSelection(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  path: JSONPath\n): boolean {\n  if (json === undefined || !selection) {\n    return false\n  }\n\n  if (isKeySelection(selection) || isInsideSelection(selection) || isAfterSelection(selection)) {\n    return isEqual(selection.path, path)\n  }\n\n  if (isValueSelection(selection)) {\n    return pathStartsWith(path, selection.path)\n  }\n\n  if (isMultiSelection(selection)) {\n    const startPath = getStartPath(json, selection)\n    const endPath = getEndPath(json, selection)\n    const parentPath = initial(selection.focusPath)\n\n    if (!pathStartsWith(path, parentPath) || path.length <= parentPath.length) {\n      return false\n    }\n\n    const startIndex = getChildIndex(json, selection, startPath)\n    const endIndex = getChildIndex(json, selection, endPath)\n    const pathIndex = getChildIndex(json, selection, path)\n    return pathIndex !== -1 && pathIndex >= startIndex && pathIndex <= endIndex\n  }\n\n  return false\n}\n\nfunction getChildIndex(json: unknown, selection: MultiSelection, path: JSONPath): number {\n  const parentPath = initial(selection.focusPath)\n  if (!pathStartsWith(path, parentPath) || path.length <= parentPath.length) {\n    return -1\n  }\n\n  const key = path[parentPath.length]\n  const parent = getIn(json, parentPath)\n\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    return keys.indexOf(key)\n  }\n\n  if (isJSONArray(parent)) {\n    const index = int(key)\n    if (index < parent.length) {\n      return index\n    }\n  }\n\n  return -1\n}\n\n// TODO: write some unit tests\nexport function getFocusPath(selection: JSONSelection): JSONPath {\n  return isMultiSelection(selection) ? selection.focusPath : selection.path\n}\n\n// TODO: write some unit tests\nexport function getAnchorPath(selection: JSONSelection): JSONPath {\n  return isMultiSelection(selection) ? selection.anchorPath : selection.path\n}\n","/**\n * A simplified version of https://github.com/JedWatson/classnames\n *\n * Example usage:\n *\n *     classnames('primary-button', { selected: true }, 'left')\n *\n */\nexport function classnames(...args: Array<string | Record<string, boolean> | undefined>): string {\n  const classes = []\n\n  for (const arg of args) {\n    if (typeof arg === 'string') {\n      classes.push(arg)\n    }\n\n    if (arg && typeof arg === 'object') {\n      for (const key in arg) {\n        if (Object.hasOwnProperty.call(arg, key) && arg[key]) {\n          classes.push(key)\n        }\n      }\n    }\n  }\n\n  return classes.join(' ')\n}\n","import { isUrl, valueType } from '$lib/utils/typeUtils.js'\nimport { type JSONParser, Mode } from '$lib/types.js'\nimport { classnames } from '$lib/utils/cssUtils.js'\n\nexport function getValueClass(value: unknown, mode: Mode, parser: JSONParser): string {\n  const type = valueType(value, parser)\n\n  return classnames('jse-value', 'jse-' + type, {\n    'jse-url': isUrl(value),\n    'jse-empty': typeof value === 'string' && value.length === 0,\n    'jse-table-cell': mode === Mode.table\n  })\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onDestroy, onMount } from 'svelte'\n  import { addNewLineSuffix, removeNewLineSuffix, setCursorToEnd } from '$lib/utils/domUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { noop } from 'lodash-es'\n  import type { OnFind, OnPaste } from '$lib/types'\n  import { UpdateSelectionAfterChange } from '$lib/types'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  const debug = createDebug('jsoneditor:EditableDiv')\n\n  export let value: string\n  export let initialValue: string | undefined\n  export let shortText = false\n  export let label: string\n  export let onChange: (newValue: string, updateSelection: UpdateSelectionAfterChange) => void\n  export let onCancel: () => void\n  export let onFind: OnFind\n  export let onPaste: OnPaste = noop\n  export let onValueClass: (value: string) => string = () => ''\n\n  let domValue: HTMLDivElement | undefined\n  let valueClass: string\n  $: valueClass = onValueClass(value)\n  let closed = false\n\n  onMount(() => {\n    debug('onMount', { value, initialValue })\n    setDomValue(initialValue !== undefined ? initialValue : value)\n\n    // focus\n    if (domValue) {\n      setCursorToEnd(domValue)\n    }\n  })\n\n  onDestroy(() => {\n    const newValue = getDomValue()\n\n    debug('onDestroy', { closed, value, newValue })\n\n    if (!closed && newValue !== value) {\n      onChange(newValue, UpdateSelectionAfterChange.no)\n    }\n  })\n\n  function getDomValue(): string {\n    if (!domValue) {\n      return ''\n    }\n    return removeNewLineSuffix(domValue.innerText)\n  }\n\n  function setDomValue(updatedValue: string) {\n    if (!domValue) {\n      return\n    }\n    domValue.innerText = addNewLineSuffix(updatedValue)\n  }\n\n  function handleValueInput() {\n    const newValue = getDomValue()\n\n    if (newValue === '') {\n      // immediately update to clean up any left over <br/>\n      setDomValue('')\n    }\n\n    // update class\n    valueClass = onValueClass(newValue)\n  }\n\n  function handleCancel() {\n    // cancel changes (needed to prevent triggering a change onDestroy)\n    closed = true\n\n    onCancel()\n  }\n\n  function handleValueKeyDown(event: KeyboardEvent) {\n    event.stopPropagation()\n\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Escape') {\n      event.preventDefault()\n\n      handleCancel()\n    }\n\n    if (combo === 'Enter' || combo === 'Tab') {\n      // apply changes\n      event.preventDefault()\n\n      closed = true\n\n      const newValue = getDomValue()\n      onChange(newValue, UpdateSelectionAfterChange.nextInside)\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      onFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      onFind(true)\n    }\n  }\n\n  function handleValuePaste(event: ClipboardEvent) {\n    event.stopPropagation()\n\n    if (!onPaste || !event.clipboardData) {\n      return\n    }\n\n    const clipboardText = event.clipboardData.getData('text/plain')\n    onPaste(clipboardText)\n  }\n\n  function handleBlur() {\n    const hasFocus = document.hasFocus()\n    const newValue = getDomValue()\n\n    debug('handleBlur', { hasFocus, closed, value, newValue })\n\n    // we only want to close the editable div when the focus did go to another\n    // element on the same page, but not when the user switches to another\n    // application or browser tab to copy/paste something whilst still editing\n    // the value, hence the check for document.hasFocus()\n    if (document.hasFocus() && !closed) {\n      closed = true\n      if (newValue !== value) {\n        onChange(newValue, UpdateSelectionAfterChange.self)\n      } else {\n        // Note that we do not fire an onCancel here: a blur action\n        // is caused by the user clicking somewhere else. If we apply\n        // onCancel now, we would override the selection that the user\n        // wants by clicking somewhere else in the editor (since `blur`\n        // is occurring *after* `mousedown`).\n      }\n    }\n  }\n</script>\n\n<div\n  role=\"textbox\"\n  aria-label={label}\n  tabindex=\"0\"\n  class={classnames('jse-editable-div', valueClass, { 'jse-short-text': shortText })}\n  contenteditable=\"true\"\n  spellcheck=\"false\"\n  on:input={handleValueInput}\n  on:keydown={handleValueKeyDown}\n  on:paste={handleValuePaste}\n  on:blur={handleBlur}\n  bind:this={domValue}\n></div>\n\n<style src=\"./EditableDiv.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { isObjectOrArray, stringConvert } from '$lib/utils/typeUtils.js'\n  import { createValueSelection, getFocusPath, isEditingSelection } from '$lib/logic/selection.js'\n  import { getValueClass } from '$lib/plugins/value/components/utils/getValueClass.js'\n  import EditableDiv from '../../../components/controls/EditableDiv.svelte'\n  import {\n    type FindNextInside,\n    type JSONParser,\n    type JSONSelection,\n    Mode,\n    type OnFind,\n    type OnJSONSelect,\n    type OnPasteJson,\n    type OnPatch,\n    UpdateSelectionAfterChange,\n    type ValueNormalization\n  } from '$lib/types.js'\n  import { isEqual } from 'lodash-es'\n  import { expandSmart } from '$lib/logic/documentState'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let selection: JSONSelection | undefined\n  export let mode: Mode\n  export let parser: JSONParser\n  export let normalization: ValueNormalization\n  export let enforceString: boolean\n  export let onPatch: OnPatch\n  export let onPasteJson: OnPasteJson\n  export let onSelect: OnJSONSelect\n  export let onFind: OnFind\n  export let focus: () => void\n  export let findNextInside: FindNextInside\n\n  function convert(value: string): unknown {\n    return enforceString ? value : stringConvert(value, parser)\n  }\n\n  function handleChangeValue(newValue: string, updateSelection: UpdateSelectionAfterChange) {\n    onPatch(\n      [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: convert(normalization.unescapeValue(newValue))\n        }\n      ],\n      (_, patchedState, patchedSelection) => {\n        // Leave the selection as is when it is no longer the path that we were editing here\n        // This happens for example when the user clicks or double-clicks on another value\n        // whilst editing a value\n        if (patchedSelection && !isEqual(path, getFocusPath(patchedSelection))) {\n          return undefined\n        }\n\n        const selection =\n          updateSelection === UpdateSelectionAfterChange.nextInside\n            ? findNextInside(path)\n            : createValueSelection(path)\n\n        return {\n          state: patchedState,\n          selection\n        }\n      }\n    )\n\n    focus()\n  }\n\n  function handleCancelChange() {\n    onSelect(createValueSelection(path))\n    focus()\n  }\n\n  function handlePaste(pastedText: string): void {\n    try {\n      const pastedJson = parser.parse(pastedText)\n      if (isObjectOrArray(pastedJson)) {\n        onPasteJson({\n          path,\n          contents: pastedJson,\n          onPasteAsJson: () => {\n            // exit edit mode\n            handleCancelChange()\n\n            // replace the value with the JSON object/array\n            const operations: JSONPatchDocument = [\n              {\n                op: 'replace',\n                path: compileJSONPointer(path),\n                value: pastedJson\n              }\n            ]\n\n            onPatch(operations, (patchedJson, patchedState) => ({\n              state: expandSmart(patchedJson, patchedState, path)\n            }))\n          }\n        })\n      }\n    } catch {\n      // silently ignore: thee pasted text is no valid JSON object or array,\n      // no need to do anything\n    }\n  }\n\n  function handleOnValueClass(value: string): string {\n    return getValueClass(convert(normalization.unescapeValue(value)), mode, parser)\n  }\n</script>\n\n<EditableDiv\n  value={normalization.escapeValue(value)}\n  initialValue={isEditingSelection(selection) ? selection.initialValue : undefined}\n  label=\"Edit value\"\n  onChange={handleChangeValue}\n  onCancel={handleCancelChange}\n  onPaste={handlePaste}\n  {onFind}\n  onValueClass={handleOnValueClass}\n/>\n","import { cloneDeepWith, first, initial, isEmpty, last, times } from 'lodash-es'\nimport {\n  compileJSONPointer,\n  existsIn,\n  getIn,\n  isJSONArray,\n  isJSONObject,\n  isJSONPatchMove,\n  isJSONPatchRemove,\n  isJSONPatchReplace,\n  type JSONPatchAdd,\n  type JSONPatchCopy,\n  type JSONPatchDocument,\n  type JSONPatchOperation,\n  type JSONPath,\n  parseJSONPointer,\n  revertJSONPatch\n} from 'immutable-json-patch'\nimport { parseAndRepair, parseAndRepairOrUndefined, parsePartialJson } from '../utils/jsonUtils.js'\nimport { findUniqueName } from '../utils/stringUtils.js'\nimport { isObject, isObjectOrArray } from '../utils/typeUtils.js'\nimport { getNextKeys } from './documentState.js'\nimport {\n  createAfterSelection,\n  createInsideSelection,\n  createSelectionFromOperations,\n  createValueSelection,\n  getEndPath,\n  getFocusPath,\n  getParentPath,\n  getSelectionPaths,\n  getStartPath,\n  isAfterSelection,\n  isInsideSelection,\n  isKeySelection,\n  isMultiSelection,\n  isValueSelection,\n  pathStartsWith\n} from './selection.js'\nimport type { ClipboardValues, DragInsideAction, JSONParser, JSONSelection } from '$lib/types'\nimport { int } from '../utils/numberUtils.js'\nimport { dedupeKeepLast } from '$lib/utils/arrayUtils'\n\n/**\n * Create a JSONPatch for an insert operation.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\n// TODO: write tests\nexport function insertBefore(\n  json: unknown,\n  path: JSONPath,\n  values: ClipboardValues\n): JSONPatchDocument {\n  const parentPath = initial(path)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    // the path is parsed from a JSONPatch operation,\n    // so array indices are a string which we have to parse into a number\n    const offset = int(last(path) as string)\n    return values.map((entry, index) => ({\n      op: 'add',\n      path: compileJSONPointer(parentPath.concat(String(offset + index))),\n      value: entry.value\n    }))\n  } else if (isJSONObject(parent)) {\n    // 'object'\n    const afterKey = last(path)\n    const keys = Object.keys(parent)\n    const nextKeys = afterKey !== undefined ? getNextKeys(keys, afterKey, true) : []\n\n    return [\n      // insert new values\n      ...values.map((entry) => {\n        const newProp = findUniqueName(entry.key, keys)\n        return {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(newProp)),\n          value: entry.value\n        } as JSONPatchAdd\n      }),\n\n      // move all lower down keys so the inserted key will maintain its position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create insert operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for an append operation. The values will be appended\n * to the end of the array or object.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\nexport function append(json: unknown, path: JSONPath, values: ClipboardValues): JSONPatchDocument {\n  const parent = getIn(json, path)\n\n  if (Array.isArray(parent)) {\n    const offset = parent.length\n    return values.map((entry, index) => ({\n      op: 'add',\n      path: compileJSONPointer(path.concat(String(offset + index))),\n      value: entry.value\n    }))\n  } else {\n    // 'object'\n    return values.map((entry) => {\n      const newProp = findUniqueName(entry.key, Object.keys(parent as Record<string, unknown>))\n      return {\n        op: 'add',\n        path: compileJSONPointer(path.concat(newProp)),\n        value: entry.value\n      }\n    })\n  }\n}\n\n/**\n * Rename an object key\n * Not applicable to arrays\n */\nexport function rename(\n  parentPath: JSONPath,\n  keys: string[],\n  oldKey: string,\n  newKey: string\n): JSONPatchDocument {\n  const filteredKeys = keys.filter((key) => key !== oldKey)\n  const newKeyUnique = findUniqueName(newKey, filteredKeys)\n  const nextKeys = getNextKeys(keys, oldKey, false)\n\n  return [\n    // rename a key\n    {\n      op: 'move',\n      from: compileJSONPointer(parentPath.concat(oldKey)),\n      path: compileJSONPointer(parentPath.concat(newKeyUnique))\n    },\n\n    // move all lower down keys so the renamed key will maintain it's position\n    ...nextKeys.map((key) => moveDown(parentPath, key))\n  ]\n}\n\n/**\n * Create a JSONPatch for an insert operation.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the inserted node in case of duplicating\n * and object property\n */\nexport function replace(\n  json: unknown,\n  paths: JSONPath[],\n  values: ClipboardValues\n): JSONPatchDocument {\n  const firstPath = first(paths)\n  const parentPath = initial(firstPath)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    const firstPath = first(paths)\n    const offset = firstPath ? int(last(firstPath) as string) : 0\n\n    return [\n      // remove operations\n      ...removeAll(paths),\n\n      // insert operations\n      ...values.map((entry, index) => {\n        const operation: JSONPatchOperation = {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(String(index + offset))),\n          value: entry.value\n        }\n\n        return operation\n      })\n    ]\n  } else if (isJSONObject(parent)) {\n    // parent is Object\n    // if we're going to replace an existing object with key \"a\" with a new\n    // key \"a\", we must not create a new unique name \"a (copy)\".\n    const lastPath = last(paths)\n    const parentPath = initial(lastPath)\n    const beforeKey = last(lastPath)\n    const keys: string[] = Object.keys(parent)\n    const nextKeys = beforeKey !== undefined ? getNextKeys(keys, beforeKey, false) : []\n    const removeKeys = new Set(paths.map((path) => last(path)))\n    const filteredKeys = keys.filter((key) => !removeKeys.has(key))\n\n    return [\n      // remove operations\n      ...removeAll(paths),\n\n      // insert operations\n      ...values.map((entry) => {\n        const newProp = findUniqueName(entry.key, filteredKeys)\n        return {\n          op: 'add',\n          path: compileJSONPointer(parentPath.concat(newProp)),\n          value: entry.value\n        } as JSONPatchAdd\n      }),\n\n      // move down operations\n      // move all lower down keys so the renamed key will maintain its position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create replace operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for a duplicate action.\n *\n * This function needs the current data in order to be able to determine\n * a unique property name for the duplicated node in case of duplicating\n * and object property\n */\nexport function duplicate(json: unknown, paths: JSONPath[]): JSONPatchDocument {\n  // FIXME: here we assume paths is sorted correctly, that's a dangerous assumption\n  const lastPath = last(paths)\n\n  if (isEmpty(lastPath)) {\n    throw new Error('Cannot duplicate root object')\n  }\n\n  const parentPath = initial(lastPath)\n  const beforeKey = last(lastPath)\n  const parent = getIn(json, parentPath)\n\n  if (isJSONArray(parent)) {\n    const lastPath = last(paths)\n    const offset = lastPath ? int(last(lastPath) as string) + 1 : 0\n\n    return [\n      // copy operations\n      ...paths.map((path, index) => {\n        const operation: JSONPatchOperation = {\n          op: 'copy',\n          from: compileJSONPointer(path),\n          path: compileJSONPointer(parentPath.concat(String(index + offset)))\n        }\n\n        return operation\n      })\n    ]\n  } else if (isJSONObject(parent)) {\n    // 'object'\n    const keys = Object.keys(parent)\n    const nextKeys = beforeKey !== undefined ? getNextKeys(keys, beforeKey, false) : []\n\n    return [\n      // copy operations\n      ...paths.map((path) => {\n        const prop = last(path) as string\n        const newProp = findUniqueName(prop, keys)\n\n        return {\n          op: 'copy',\n          from: compileJSONPointer(path),\n          path: compileJSONPointer(parentPath.concat(newProp))\n        } as JSONPatchCopy\n      }),\n\n      // move down operations\n      // move all lower down keys so the renamed key will maintain it's position\n      ...nextKeys.map((key) => moveDown(parentPath, key))\n    ]\n  } else {\n    throw new Error('Cannot create duplicate operations: parent must be an Object or Array')\n  }\n}\n\n/**\n * Create a JSONPatch for an extract action.\n */\n// TODO: write unit tests\nexport function extract(json: unknown, selection: JSONSelection): JSONPatchDocument {\n  if (isValueSelection(selection)) {\n    return [\n      {\n        op: 'move',\n        from: compileJSONPointer(selection.path),\n        path: ''\n      }\n    ]\n  }\n\n  if (isMultiSelection(selection)) {\n    const parentPath = initial(selection.focusPath)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const value = getSelectionPaths(json, selection).map((path) => {\n        const index = int(last(path) as string)\n        return parent[index]\n      })\n\n      return [\n        {\n          op: 'replace',\n          path: '',\n          value\n        }\n      ]\n    } else if (isJSONObject(parent)) {\n      // object\n      const value: Record<string, unknown> = {}\n      getSelectionPaths(json, selection).forEach((path) => {\n        const key = String(last(path))\n        value[key] = parent[key]\n      })\n\n      return [\n        {\n          op: 'replace',\n          path: '',\n          value\n        }\n      ]\n    }\n  } else {\n    throw new Error('Cannot create extract operations: parent must be an Object or Array')\n  }\n\n  // this should never happen\n  throw new Error('Cannot extract: unsupported type of selection ' + JSON.stringify(selection))\n}\n\n// TODO: write unit tests\nexport function insert(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  clipboardText: string,\n  parser: JSONParser\n): JSONPatchDocument {\n  if (isKeySelection(selection)) {\n    // rename key\n    const clipboard = parseAndRepairOrUndefined(clipboardText, parser)\n    const parentPath = initial(selection.path)\n    const parent = getIn(json, parentPath)\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const oldKey = last(selection.path) as string\n    const newKey = typeof clipboard === 'string' ? clipboard : clipboardText\n\n    return rename(parentPath, keys, oldKey, newKey)\n  }\n\n  if (\n    isValueSelection(selection) ||\n    (isMultiSelection(selection) && isEmpty(selection.focusPath)) // root selected\n  ) {\n    // replace selected value (new value can be primitive or an array/object with contents)\n    try {\n      return [\n        {\n          op: 'replace',\n          path: compileJSONPointer(getFocusPath(selection)),\n          value: parsePartialJson(clipboardText, (text) => parseAndRepair(text, parser))\n        }\n      ]\n    } catch {\n      // parsing failed -> just paste the raw text as value\n      return [\n        {\n          op: 'replace',\n          path: compileJSONPointer(getFocusPath(selection)),\n          value: clipboardText\n        }\n      ]\n    }\n  }\n\n  if (isMultiSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n\n    return replace(json, getSelectionPaths(json, selection), newValues)\n  }\n\n  if (isAfterSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n    const path = selection.path\n    const parentPath = initial(path)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const index = int(last(path) as string)\n      const nextItemPath = parentPath.concat(String(index + 1))\n\n      return insertBefore(json, nextItemPath, newValues)\n    } else if (isJSONObject(parent)) {\n      // value is an Object\n      const key = String(last(path))\n      const keys: string[] = Object.keys(parent)\n      if (isEmpty(keys) || last(keys) === key) {\n        return append(json, parentPath, newValues)\n      } else {\n        const index = keys.indexOf(key)\n        const nextKey = keys[index + 1]\n        const nextKeyPath = parentPath.concat(nextKey)\n\n        return insertBefore(json, nextKeyPath, newValues)\n      }\n    } else {\n      throw new Error('Cannot create insert operations: parent must be an Object or Array')\n    }\n  }\n\n  if (isInsideSelection(selection)) {\n    const newValues = clipboardToValues(clipboardText, parser)\n    const path = selection.path\n    const value = getIn(json, path)\n\n    if (isJSONArray(value)) {\n      const firstItemPath = path.concat('0')\n      return insertBefore(json, firstItemPath, newValues)\n    } else if (isJSONObject(value)) {\n      // value is an Object\n      const keys = Object.keys(value)\n      if (isEmpty(keys)) {\n        return append(json, path, newValues)\n      } else {\n        const firstKey = first(keys) as string\n        const firstKeyPath = path.concat(firstKey)\n\n        return insertBefore(json, firstKeyPath, newValues)\n      }\n    } else {\n      throw new Error('Cannot create insert operations: parent must be an Object or Array')\n    }\n  }\n\n  // this should never happen\n  throw new Error('Cannot insert: unsupported type of selection ' + JSON.stringify(selection))\n}\n\nexport function moveInsideParent(\n  json: unknown,\n  selection: JSONSelection | undefined,\n  dragInsideAction: DragInsideAction\n): JSONPatchDocument {\n  if (!selection) {\n    return []\n  }\n\n  const beforePath = 'beforePath' in dragInsideAction ? dragInsideAction['beforePath'] : undefined\n  const append = 'append' in dragInsideAction ? dragInsideAction['append'] : undefined\n\n  const parentPath = initial(getFocusPath(selection))\n  const parent = getIn(json, parentPath)\n\n  if (\n    !append &&\n    !(beforePath && pathStartsWith(beforePath, parentPath) && beforePath.length > parentPath.length)\n  ) {\n    return []\n  }\n\n  const startPath = getStartPath(json, selection)\n  const endPath = getEndPath(json, selection)\n  const startKey = last(startPath) as string\n  const endKey = last(endPath) as string\n  const toKey: string | undefined = beforePath ? beforePath[parentPath.length] : undefined\n\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    const startIndex = keys.indexOf(startKey)\n    const endIndex = keys.indexOf(endKey)\n    const toIndex = append ? keys.length : toKey !== undefined ? keys.indexOf(toKey) : -1\n\n    if (startIndex !== -1 && endIndex !== -1 && toIndex !== -1) {\n      if (toIndex > startIndex) {\n        // moving down\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        return [...keys.slice(startIndex, endIndex + 1), ...keys.slice(toIndex, keys.length)].map(\n          (key) => moveDown(parentPath, key)\n        )\n      } else {\n        // moving up\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        return [...keys.slice(toIndex, startIndex), ...keys.slice(endIndex + 1, keys.length)].map(\n          (key) => moveDown(parentPath, key)\n        )\n      }\n    }\n  } else if (isJSONArray(parent)) {\n    // array\n    const startIndex = int(startKey)\n    const endIndex = int(endKey)\n    const toIndex = toKey !== undefined ? int(toKey) : parent.length\n    const count = endIndex - startIndex + 1\n\n    if (toIndex < startIndex) {\n      // move up\n      return times(count, (offset) => {\n        return {\n          op: 'move',\n          from: compileJSONPointer(parentPath.concat(String(startIndex + offset))),\n          path: compileJSONPointer(parentPath.concat(String(toIndex + offset)))\n        }\n      })\n    } else {\n      // move down\n      return times(count, () => {\n        return {\n          op: 'move',\n          from: compileJSONPointer(parentPath.concat(String(startIndex))),\n          path: compileJSONPointer(parentPath.concat(String(toIndex)))\n        }\n      })\n    }\n  } else {\n    throw new Error('Cannot create move operations: parent must be an Object or Array')\n  }\n\n  return []\n}\n\nexport function createNewValue(\n  json: unknown | undefined,\n  selection: JSONSelection | undefined,\n  valueType: 'object' | 'array' | 'structure' | 'value'\n): unknown {\n  if (valueType === 'object') {\n    return {}\n  }\n\n  if (valueType === 'array') {\n    return []\n  }\n\n  if (valueType === 'structure' && json !== undefined) {\n    const parentPath = selection ? getParentPath(selection) : []\n    const parent = getIn(json, parentPath)\n\n    if (Array.isArray(parent) && !isEmpty(parent)) {\n      const jsonExample = first(parent)\n      if (isObjectOrArray(jsonExample)) {\n        return cloneDeepWith(jsonExample, (value) => {\n          return Array.isArray(value)\n            ? []\n            : isObject(value)\n              ? undefined // leave object as is, will recurse into it\n              : ''\n        })\n      } else {\n        // just a primitive value\n        return ''\n      }\n    }\n  }\n\n  // type === value,\n  // or type === structure but the parent is no array or an array containing\n  // primitive values (and no objects having any structure).\n  return ''\n}\n\n/**\n * Create a JSONPatch for a remove operation\n */\nexport function remove(path: JSONPath): JSONPatchDocument {\n  return [\n    {\n      op: 'remove',\n      path: compileJSONPointer(path)\n    }\n  ]\n}\n\n/**\n * Create a JSONPatch for a multiple remove operation\n */\nexport function removeAll(paths: JSONPath[]): JSONPatchDocument {\n  return paths\n    .map((path) => {\n      const operation: JSONPatchOperation = {\n        op: 'remove',\n        path: compileJSONPointer(path)\n      }\n\n      return operation\n    })\n    .reverse() // reverse is needed for arrays: delete the last index first\n}\n\n// helper function to move a key down in an object,\n// so another key can get positioned before the moved down keys\nfunction moveDown(parentPath: JSONPath, key: string): JSONPatchOperation {\n  return {\n    op: 'move',\n    from: compileJSONPointer(parentPath.concat(key)),\n    path: compileJSONPointer(parentPath.concat(key))\n  }\n}\n\nexport function clipboardToValues(clipboardText: string, parser: JSONParser): ClipboardValues {\n  const textIsObject = /^\\s*{/.test(clipboardText)\n  const textIsArray = /^\\s*\\[/.test(clipboardText)\n\n  const clipboardOriginal = parseAndRepairOrUndefined(clipboardText, parser)\n  const clipboardRepaired =\n    clipboardOriginal !== undefined\n      ? clipboardOriginal\n      : parsePartialJson(clipboardText, (text) => parseAndRepair(text, parser))\n\n  if (\n    (textIsObject && isObject(clipboardRepaired)) ||\n    (textIsArray && Array.isArray(clipboardRepaired))\n  ) {\n    return [{ key: 'New item', value: clipboardRepaired }]\n  }\n\n  if (Array.isArray(clipboardRepaired)) {\n    return clipboardRepaired.map((value, index) => {\n      return { key: 'New item ' + index, value }\n    })\n  }\n\n  if (isObject(clipboardRepaired)) {\n    return Object.keys(clipboardRepaired).map((key) => {\n      return { key, value: clipboardRepaired[key] }\n    })\n  }\n\n  // regular value\n  return [{ key: 'New item', value: clipboardRepaired }]\n}\n\n// TODO: write unit tests\nexport function createRemoveOperations(\n  json: unknown,\n  selection: JSONSelection\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  if (isKeySelection(selection)) {\n    // FIXME: DOESN'T work yet\n    const parentPath = initial(selection.path)\n    const parent = getIn(json, parentPath)\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const oldKey = last(selection.path) as string\n    const newKey = ''\n\n    const operations = rename(parentPath, keys, oldKey, newKey)\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return { operations, newSelection }\n  }\n\n  if (isValueSelection(selection)) {\n    const operations: JSONPatchDocument = [\n      {\n        op: 'replace',\n        path: compileJSONPointer(selection.path),\n        value: ''\n      }\n    ]\n\n    return { operations, newSelection: selection }\n  }\n\n  if (isMultiSelection(selection)) {\n    const paths = getSelectionPaths(json, selection)\n    const operations = removeAll(paths)\n    const lastPath = last(paths)\n\n    if (isEmpty(lastPath)) {\n      // there is no parent, this is the root document\n      const operations: JSONPatchDocument = [{ op: 'replace', path: '', value: '' }]\n\n      const newSelection = createValueSelection([])\n\n      return { operations, newSelection }\n    }\n\n    const parentPath = initial(lastPath)\n    const parent = getIn(json, parentPath)\n\n    if (isJSONArray(parent)) {\n      const firstPath = first(paths)\n      const index = int(last(firstPath) as string)\n      const newSelection =\n        index === 0\n          ? createInsideSelection(parentPath)\n          : createAfterSelection(parentPath.concat(String(index - 1)))\n\n      return { operations, newSelection }\n    } else if (isJSONObject(parent)) {\n      // parent is object\n      const keys = Object.keys(parent)\n      const firstPath = first(paths)\n      const key = last(firstPath) as string\n      const index = keys.indexOf(key)\n      const previousKey = keys[index - 1]\n      const newSelection =\n        index === 0\n          ? createInsideSelection(parentPath)\n          : createAfterSelection(parentPath.concat(previousKey))\n\n      return { operations, newSelection }\n    } else {\n      throw new Error('Cannot create remove operations: parent must be an Object or Array')\n    }\n  }\n\n  // this should never happen\n  throw new Error('Cannot remove: unsupported type of selection ' + JSON.stringify(selection))\n}\n\nexport function revertJSONPatchWithMoveOperations(\n  json: unknown,\n  operations: JSONPatchDocument\n): JSONPatchDocument {\n  return dedupeKeepLast(\n    revertJSONPatch(json, operations, {\n      before: (json, operation, revertOperations) => {\n        if (isJSONPatchRemove(operation)) {\n          const path = parseJSONPointer(operation.path)\n          return {\n            revertOperations: [...revertOperations, ...createRevertMoveOperations(json, path)]\n          }\n        }\n\n        if (isJSONPatchMove(operation)) {\n          const from = parseJSONPointer(operation.from)\n          return {\n            revertOperations:\n              operation.from === operation.path\n                ? [operation, ...createRevertMoveOperations(json, from)] // move in-place (just for re-ordering object keys)\n                : [...revertOperations, ...createRevertMoveOperations(json, from)]\n          }\n        }\n\n        return { document: json }\n      }\n    })\n  )\n}\n\nfunction createRevertMoveOperations(json: unknown, path: JSONPath): JSONPatchOperation[] {\n  const parentPath = initial(path)\n  const afterKey = last(path) as string\n  const parent = getIn(json, parentPath)\n  if (isJSONObject(parent)) {\n    const keys = Object.keys(parent)\n    const nextKeys = getNextKeys(keys, afterKey, false)\n\n    // move all lower down keys so the inserted key will maintain its position\n    return nextKeys.map((key) => moveDown(parentPath, key))\n  }\n\n  return []\n}\n\n/**\n * Add operations to create parent objects when missing before replacing a nested value\n */\nexport function createNestedValueOperations(operations: JSONPatchOperation[], json: unknown) {\n  return operations.flatMap((operation) => {\n    if (isJSONPatchReplace(operation)) {\n      const path = parseJSONPointer(operation.path)\n      if (path.length > 0) {\n        const extendedOperations: JSONPatchOperation[] = [operation]\n\n        let parentPath = initial(path)\n        while (parentPath.length > 0 && !existsIn(json, parentPath)) {\n          extendedOperations.unshift({\n            op: 'add',\n            path: compileJSONPointer(parentPath),\n            value: {}\n          })\n\n          parentPath = initial(parentPath)\n        }\n\n        return extendedOperations\n      }\n    }\n\n    return operation\n  })\n}\n","import type { JSONPatchDocument, JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport { compileJSONPointer, getIn, isJSONArray, isJSONObject } from 'immutable-json-patch'\nimport { forEachRight, initial, isEqual, last } from 'lodash-es'\nimport { getEnforceString, updateInRecursiveState } from './documentState.js'\nimport { createSelectionFromOperations } from './selection.js'\nimport { rename } from './operations.js'\nimport { stringConvert } from '../utils/typeUtils.js'\nimport type {\n  DocumentState,\n  ExtendedSearchResultItem,\n  JSONParser,\n  JSONSelection,\n  SearchOptions,\n  SearchResultDetails,\n  SearchResultItem,\n  SearchResults,\n  RecursiveStateFactory\n} from '$lib/types'\nimport { SearchField } from '$lib/types.js'\nimport {\n  hasSearchResults,\n  isArrayRecursiveState,\n  isObjectRecursiveState\n} from 'svelte-jsoneditor/typeguards.js'\n\n// TODO: comment\n// TODO: unit test\nexport function updateSearchResult(\n  newResultItems: SearchResultItem[],\n  previousResult: SearchResultDetails | undefined\n): SearchResultDetails {\n  const activePath = previousResult?.activeItem\n    ? getSearchResultPath(previousResult.activeItem)\n    : undefined\n\n  const matchingActiveIndex = newResultItems.findIndex((item) => {\n    return isEqual(activePath, getSearchResultPath(item))\n  })\n\n  const activeIndex =\n    matchingActiveIndex !== -1\n      ? matchingActiveIndex\n      : previousResult?.activeIndex !== undefined &&\n          previousResult?.activeIndex < newResultItems.length\n        ? previousResult?.activeIndex\n        : newResultItems.length > 0\n          ? 0\n          : -1\n\n  const items: ExtendedSearchResultItem[] = newResultItems.map((item, index) => {\n    return { ...item, active: index === activeIndex }\n  })\n\n  const activeItem = items[activeIndex]\n\n  return {\n    items,\n    activeItem,\n    activeIndex\n  }\n}\n\n// TODO: unit test\nexport function searchNext(searchResult: SearchResultDetails): SearchResultDetails {\n  const nextActiveIndex =\n    searchResult.activeIndex < searchResult.items.length - 1\n      ? searchResult.activeIndex + 1\n      : searchResult.items.length > 0\n        ? 0\n        : -1\n\n  const nextActiveItem = searchResult.items[nextActiveIndex]\n\n  const items: ExtendedSearchResultItem[] = searchResult.items.map((item, index) => {\n    return { ...item, active: index === nextActiveIndex }\n  })\n\n  return {\n    ...searchResult,\n    items,\n    activeItem: nextActiveItem,\n    activeIndex: nextActiveIndex\n  }\n}\n\n// TODO: unit test\nexport function searchPrevious(searchResult: SearchResultDetails): SearchResultDetails {\n  const previousActiveIndex =\n    searchResult.activeIndex > 0 ? searchResult.activeIndex - 1 : searchResult.items.length - 1\n\n  const previousActiveItem = searchResult.items[previousActiveIndex]\n\n  const items: ExtendedSearchResultItem[] = searchResult.items.map((item, index) => {\n    return { ...item, active: index === previousActiveIndex }\n  })\n\n  return {\n    ...searchResult,\n    items,\n    activeItem: previousActiveItem,\n    activeIndex: previousActiveIndex\n  }\n}\n\n// TODO: comment\nexport function search(\n  searchText: string,\n  json: unknown,\n  options: SearchOptions = {}\n): SearchResultItem[] {\n  const searchTextLowerCase = searchText.toLowerCase()\n  const maxResults = options?.maxResults ?? Infinity\n  const columns = options?.columns\n  const results: SearchResultItem[] = []\n  const path: JSONPath = [] // we reuse the same Array recursively, this is *much* faster than creating a new path every time\n\n  function onMatch(match: SearchResultItem) {\n    if (results.length >= maxResults) {\n      return\n    }\n\n    results.push(match)\n  }\n\n  function searchRecursive(searchTextLowerCase: string, value: unknown) {\n    if (isJSONArray(value)) {\n      const level = path.length\n      path.push('0')\n\n      for (let i = 0; i < value.length; i++) {\n        path[level] = String(i)\n\n        searchRecursive(searchTextLowerCase, value[i])\n\n        if (results.length >= maxResults) {\n          return\n        }\n      }\n\n      path.pop()\n    } else if (isJSONObject(value)) {\n      const keys = Object.keys(value)\n      const level = path.length\n\n      path.push('')\n\n      for (const key of keys) {\n        path[level] = key\n\n        findCaseInsensitiveMatches(key, searchTextLowerCase, path, SearchField.key, onMatch)\n\n        searchRecursive(searchTextLowerCase, value[key])\n\n        if (results.length >= maxResults) {\n          return\n        }\n      }\n\n      path.pop()\n    } else {\n      // type is a value\n      findCaseInsensitiveMatches(\n        String(value),\n        searchTextLowerCase,\n        path,\n        SearchField.value,\n        onMatch\n      )\n    }\n  }\n\n  if (searchText === '') {\n    return []\n  } else if (columns) {\n    if (!Array.isArray(json)) {\n      throw new Error('json must be an Array when option columns is defined')\n    }\n\n    for (let i = 0; i < json.length; i++) {\n      path[0] = String(i)\n\n      const item = json[i]\n\n      for (let c = 0; c < columns.length; c++) {\n        const column = columns[c]\n\n        if (column.length === 1) {\n          path[1] = column[0]\n        } else {\n          for (let p = 0; p < column.length; p++) {\n            path[p + 1] = column[p]\n          }\n        }\n        while (path.length > column.length + 1) {\n          path.pop()\n        }\n\n        const value = getIn(item, column)\n\n        searchRecursive(searchTextLowerCase, value)\n      }\n\n      if (results.length >= maxResults) {\n        break\n      }\n    }\n\n    return results\n  } else {\n    searchRecursive(searchTextLowerCase, json)\n    return results\n  }\n}\n\n/**\n * Do a case-insensitive search for a search text in a text\n */\nexport function findCaseInsensitiveMatches(\n  text: string,\n  searchTextLowerCase: string,\n  path: JSONPath,\n  field: SearchField,\n  onMatch: (searchResultItem: SearchResultItem) => void\n): void {\n  const textLower = text.toLowerCase()\n\n  let fieldIndex = 0\n  let position = -1\n  let index = -1\n\n  do {\n    index = textLower.indexOf(searchTextLowerCase, position)\n\n    if (index !== -1) {\n      position = index + searchTextLowerCase.length\n\n      onMatch({\n        path: path.slice(0), // path may be mutated in a later stage, therefore we store a copy\n        field,\n        fieldIndex,\n        start: index,\n        end: position\n      })\n\n      fieldIndex++\n    }\n  } while (index !== -1)\n}\n\n/**\n * Replace a search result item with a replacement text\n */\nexport function replaceText(text: string, replacementText: string, start: number, end: number) {\n  return text.substring(0, start) + replacementText + text.substring(end)\n}\n\n/**\n * Replace all matches with a replacement text\n */\nexport function replaceAllText(\n  text: string,\n  replacementText: string,\n  occurrences: Array<{ start: number; end: number }>\n): string {\n  let updatedText = text\n\n  forEachRight(occurrences, (occurrence) => {\n    updatedText = replaceText(updatedText, replacementText, occurrence.start, occurrence.end)\n  })\n\n  return updatedText\n}\n\nexport function createSearchAndReplaceOperations(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  replacementText: string,\n  searchResultItem: SearchResultItem,\n  parser: JSONParser\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  const { field, path, start, end } = searchResultItem\n\n  if (field === SearchField.key) {\n    // replace a key\n    const parentPath = initial(path)\n    const parent = getIn(json, parentPath)\n    const oldKey = last(path) as string\n    const keys = Object.keys(parent as Record<string, unknown>)\n    const newKey = replaceText(oldKey, replacementText, start, end)\n\n    const operations = rename(parentPath, keys, oldKey, newKey)\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return {\n      newSelection,\n      operations\n    }\n  } else if (field === SearchField.value) {\n    // replace a value\n    const currentValue: unknown | undefined = getIn(json, path)\n    if (currentValue === undefined) {\n      throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`)\n    }\n    const currentValueText = typeof currentValue === 'string' ? currentValue : String(currentValue)\n\n    const enforceString = getEnforceString(json, documentState, path)\n    const value = replaceText(currentValueText, replacementText, start, end)\n\n    const operations: JSONPatchOperation[] = [\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: enforceString ? value : stringConvert(value, parser)\n      }\n    ]\n\n    const newSelection = createSelectionFromOperations(json, operations)\n\n    return {\n      newSelection,\n      operations\n    }\n  } else {\n    throw new Error(`Cannot replace: unknown type of search result field ${field}`)\n  }\n}\n\nexport function createSearchAndReplaceAllOperations(\n  json: unknown,\n  documentState: DocumentState | undefined,\n  searchText: string,\n  replacementText: string,\n  parser: JSONParser\n): { newSelection: JSONSelection | undefined; operations: JSONPatchDocument } {\n  // TODO: to improve performance, we could reuse existing search results (except when hitting a maxResult limit)\n  const searchResultItems = search(searchText, json, { maxResults: Infinity })\n\n  interface Match {\n    path: JSONPath\n    field: string\n    items: SearchResultItem[]\n  }\n\n  // step 1: deduplicate matches inside the same field/value\n  // (filter, map, and group)\n  const deduplicatedMatches: Match[] = []\n  for (let i = 0; i < searchResultItems.length; i++) {\n    const previousItem = searchResultItems[i - 1]\n    const item = searchResultItems[i]\n    if (i === 0 || item.field !== previousItem.field || !isEqual(item.path, previousItem.path)) {\n      deduplicatedMatches.push({\n        path: item.path,\n        field: item.field,\n        items: [item]\n      })\n    } else {\n      ;(last(deduplicatedMatches) as Match).items.push(item)\n    }\n  }\n\n  // step 2: sort from deepest nested to least nested\n  // this is needed to replace in that order because paths may change\n  // if there are replacements in keys\n  deduplicatedMatches.sort((a, b) => {\n    // sort values first, properties next\n    if (a.field !== b.field) {\n      if (a.field === SearchField.key) {\n        return 1\n      } else {\n        return -1\n      }\n    }\n\n    // sort longest paths first, shortest last\n    return b.path.length - a.path.length\n  })\n\n  // step 3: call createSearchAndReplaceOperations for each of the matches\n  let allOperations: JSONPatchDocument = []\n  let lastNewSelection: JSONSelection | undefined\n  deduplicatedMatches.forEach((match) => {\n    // TODO: there is overlap with the logic of createSearchAndReplaceOperations. Can we extract and reuse this logic?\n    const { field, path, items } = match\n\n    if (field === SearchField.key) {\n      // replace a key\n      const parentPath = initial(path)\n      const parent = getIn(json, parentPath)\n      const oldKey = last(path) as string\n      const keys = Object.keys(parent as Record<string, unknown>)\n      const newKey = replaceAllText(oldKey, replacementText, items)\n\n      const operations = rename(parentPath, keys, oldKey, newKey)\n      allOperations = allOperations.concat(operations)\n\n      lastNewSelection = createSelectionFromOperations(json, operations)\n    } else if (field === SearchField.value) {\n      // replace a value\n      const currentValue: unknown | undefined = getIn(json, path)\n      if (currentValue === undefined) {\n        throw new Error(`Cannot replace: path not found ${compileJSONPointer(path)}`)\n      }\n      const currentValueText =\n        typeof currentValue === 'string' ? currentValue : String(currentValue)\n      const enforceString = getEnforceString(json, documentState, path)\n      const value = replaceAllText(currentValueText, replacementText, items)\n\n      const operations: JSONPatchOperation[] = [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: enforceString ? value : stringConvert(value, parser)\n        }\n      ]\n      allOperations = allOperations.concat(operations)\n\n      lastNewSelection = createSelectionFromOperations(json, operations)\n    } else {\n      throw new Error(`Cannot replace: unknown type of search result field ${field}`)\n    }\n  })\n\n  return {\n    operations: allOperations,\n    newSelection: lastNewSelection\n  }\n}\n\nexport interface SplitValuePart {\n  text: string\n  type: 'normal' | 'highlight'\n  active: boolean\n}\n\n/**\n * Split the text into separate parts for each search result and the text\n * in between.\n */\nexport function splitValue(text: string, matches: ExtendedSearchResultItem[]): SplitValuePart[] {\n  const parts: SplitValuePart[] = []\n\n  let previousEnd = 0\n\n  for (const match of matches) {\n    const precedingText = text.slice(previousEnd, match.start)\n    if (precedingText !== '') {\n      parts.push({\n        type: 'normal',\n        text: precedingText,\n        active: false\n      })\n    }\n\n    const matchingText = text.slice(match.start, match.end)\n    parts.push({\n      type: 'highlight',\n      text: matchingText,\n      active: match.active\n    })\n\n    previousEnd = match.end\n  }\n\n  const lastMatch = last(matches)\n  if (lastMatch && lastMatch.end < text.length) {\n    parts.push({\n      type: 'normal',\n      text: text.slice(lastMatch.end),\n      active: false\n    })\n  }\n\n  return parts\n}\n\n/**\n * Get the path of the search result property on a nested search result\n */\nfunction getSearchResultPath(searchResultItem: SearchResultItem): JSONPath {\n  return searchResultItem.path.concat(searchResultItem.field, String(searchResultItem.fieldIndex))\n}\n\n/**\n * Filter key search results.\n * Returns a non-empty array, or undefined if there are no key search results\n */\nexport function filterKeySearchResults(\n  searchResult: SearchResults | undefined\n): ExtendedSearchResultItem[] | undefined {\n  const filtered = hasSearchResults(searchResult)\n    ? searchResult.searchResults.filter((result) => result.field === SearchField.key)\n    : undefined\n\n  return filtered && filtered.length > 0 ? filtered : undefined\n}\n\n/**\n * Filter value search results.\n * Returns a non-empty array, or undefined if there are no value search results\n */\nexport function filterValueSearchResults(\n  searchResult: SearchResults | undefined\n): ExtendedSearchResultItem[] | undefined {\n  const filtered = hasSearchResults(searchResult)\n    ? searchResult.searchResults.filter((result) => result.field === SearchField.value)\n    : undefined\n\n  return filtered && filtered.length > 0 ? filtered : undefined\n}\n\nexport const searchResultsFactory: RecursiveStateFactory = {\n  createObjectDocumentState: () => ({ type: 'object', properties: {} }),\n  createArrayDocumentState: () => ({ type: 'array', items: [] }),\n  createValueDocumentState: () => ({ type: 'value' })\n}\n\nexport function updateInSearchResults(\n  json: unknown,\n  searchResults: SearchResults | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: SearchResults) => SearchResults\n): SearchResults {\n  return updateInRecursiveState(json, searchResults, path, transform, searchResultsFactory)\n}\n\nexport function toRecursiveSearchResults(\n  json: unknown,\n  searchResultItems: ExtendedSearchResultItem[]\n): SearchResults | undefined {\n  return searchResultItems.reduce(\n    (recursiveState, searchResult) => {\n      return updateInSearchResults(json, recursiveState, searchResult.path, (_, nestedState) => ({\n        ...nestedState,\n        searchResults: nestedState.searchResults\n          ? nestedState.searchResults.concat(searchResult)\n          : [searchResult]\n      }))\n    },\n    undefined as SearchResults | undefined\n  )\n}\n\nexport function flattenSearchResults(node: SearchResults | undefined): ExtendedSearchResultItem[] {\n  const self = node?.searchResults ?? []\n\n  const nested = isObjectRecursiveState(node)\n    ? Object.values(node.properties).flatMap(flattenSearchResults)\n    : isArrayRecursiveState(node)\n      ? node.items.flatMap(flattenSearchResults)\n      : []\n\n  return self.concat(nested)\n}\n","<script lang=\"ts\">\n  import { splitValue } from '$lib/logic/search.js'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import type { ExtendedSearchResultItem } from '$lib/types'\n\n  export let text: string\n  export let searchResultItems: ExtendedSearchResultItem[]\n\n  $: parts = splitValue(String(text), searchResultItems)\n</script>\n\n{#each parts as part}\n  {#if part.type === 'normal'}\n    {part.text}\n  {:else}\n    <span class=\"jse-highlight\" class:jse-active={part.active}>{addNewLineSuffix(part.text)}</span>\n  {/if}\n{/each}\n\n<style src=\"./SearchResultHighlighter.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isUrl } from '$lib/utils/typeUtils.js'\n  import { createEditValueSelection } from '$lib/logic/selection.js'\n  import SearchResultHighlighter from '../../../components/modes/treemode/highlight/SearchResultHighlighter.svelte'\n  import { getValueClass } from './utils/getValueClass.js'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import {\n    type ExtendedSearchResultItem,\n    type JSONParser,\n    type Mode,\n    type OnJSONSelect,\n    type ValueNormalization\n  } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { isCtrlKeyDown } from 'svelte-jsoneditor/utils/keyBindings'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let mode: Mode\n  export let readOnly: boolean\n  export let normalization: ValueNormalization\n  export let parser: JSONParser\n  export let onSelect: OnJSONSelect\n\n  export let searchResultItems: ExtendedSearchResultItem[] | undefined\n\n  $: valueIsUrl = isUrl(value)\n\n  function handleValueClick(event: MouseEvent) {\n    if (typeof value === 'string' && valueIsUrl && isCtrlKeyDown(event)) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      window.open(value, '_blank')\n    }\n  }\n\n  function handleValueDoubleClick(event: MouseEvent) {\n    if (!readOnly) {\n      event.preventDefault()\n      onSelect(createEditValueSelection(path))\n    }\n  }\n</script>\n\n<!-- svelte-ignore a11y-click-events-have-key-events -->\n<div\n  role=\"button\"\n  tabindex=\"-1\"\n  data-type=\"selectable-value\"\n  class={getValueClass(value, mode, parser)}\n  on:click={handleValueClick}\n  on:dblclick={handleValueDoubleClick}\n  title={valueIsUrl ? 'Ctrl+Click or Ctrl+Enter to open url in new window' : undefined}\n>\n  {#if searchResultItems}\n    <SearchResultHighlighter text={normalization.escapeValue(value)} {searchResultItems} />\n  {:else}\n    {addNewLineSuffix(normalization.escapeValue(value))}\n  {/if}\n</div>\n\n<style src=\"./ReadonlyValue.scss\"></style>\n","<script lang=\"ts\">\n  export let text: string\n</script>\n\n<div class=\"jse-tooltip\">\n  {text}\n</div>\n\n<style src=\"./Tooltip.scss\"></style>\n","import Tooltip from './Tooltip.svelte'\nimport type { SvelteComponent } from 'svelte'\nimport type { AbsolutePopupOptions } from '$lib/types'\n\nexport interface TooltipOptions {\n  text: string\n  openAbsolutePopup: (\n    component: typeof SvelteComponent<Record<string, unknown>>,\n    props: Record<string, unknown>,\n    options: AbsolutePopupOptions\n  ) => number\n  closeAbsolutePopup: (popupId: number | undefined) => void\n}\n\nexport function tooltip(\n  node: Element,\n  { text, openAbsolutePopup, closeAbsolutePopup }: TooltipOptions\n) {\n  let popupId: number | undefined\n\n  function handleMouseEnter() {\n    const props = {\n      text\n    }\n\n    // opening popup will fail if there is already a popup open\n    popupId = openAbsolutePopup(Tooltip, props, {\n      position: 'top',\n      width: 10 * text.length, // rough estimate of the width of the message\n      offsetTop: 3,\n      anchor: node,\n      closeOnOuterClick: true\n    })\n  }\n\n  function handleMouseLeave() {\n    closeAbsolutePopup(popupId)\n  }\n\n  node.addEventListener('mouseenter', handleMouseEnter)\n  node.addEventListener('mouseleave', handleMouseLeave)\n\n  return {\n    destroy() {\n      node.removeEventListener('mouseenter', handleMouseEnter)\n      node.removeEventListener('mouseleave', handleMouseLeave)\n    }\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faClock } from '@fortawesome/free-regular-svg-icons'\n  import { getContext } from 'svelte'\n  import { tooltip } from '$lib/components/controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext } from '$lib/types'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let value: number\n\n  $: text = `Time: ${new Date(value).toString()}`\n</script>\n\n<div class=\"jse-timestamp\" use:tooltip={{ text, ...absolutePopupContext }}>\n  <Icon data={faClock} />\n</div>\n\n<style src=\"./TimestampTag.scss\"></style>\n","import { isBoolean, isColor, isTimestamp } from '$lib/utils/typeUtils.js'\nimport type { RenderValueComponentDescription, RenderValueProps } from '$lib/types'\nimport BooleanToggle from './components/BooleanToggle.svelte'\nimport ColorPicker from './components/ColorPicker.svelte'\nimport EditableValue from './components/EditableValue.svelte'\nimport ReadonlyValue from './components/ReadonlyValue.svelte'\nimport TimestampTag from './components/TimestampTag.svelte'\n\nexport function renderValue(props: RenderValueProps): RenderValueComponentDescription[] {\n  const renderers: RenderValueComponentDescription[] = []\n\n  if (!props.isEditing && isBoolean(props.value)) {\n    renderers.push({ component: BooleanToggle, props })\n  }\n\n  if (!props.isEditing && isColor(props.value)) {\n    renderers.push({ component: ColorPicker, props })\n  }\n\n  if (props.isEditing) {\n    renderers.push({ component: EditableValue, props })\n  }\n\n  if (!props.isEditing) {\n    renderers.push({ component: ReadonlyValue, props })\n  }\n\n  if (!props.isEditing && isTimestamp(props.value)) {\n    renderers.push({ component: TimestampTag, props })\n  }\n\n  return renderers\n}\n","import { isEmpty } from 'lodash-es'\nimport type { JSONPath } from 'immutable-json-patch'\nimport type { PathOption } from '$lib/types.js'\n\n/**\n **\n * Stringify an array with a path like ['items', '3', 'name'] into string like 'items[3].name'\n * Note that we allow all characters in a property name, like \"item with spaces[3].name\",\n * so this path is not usable as-is in JavaScript.\n */\nexport function stringifyJSONPath(path: JSONPath): string {\n  return path\n    .map((p, index) => {\n      return integerNumberRegex.test(p)\n        ? '[' + p + ']'\n        : /[.[\\]]/.test(p) || p === '' // match any character . or [ or ] and handle an empty string\n          ? '[\"' + escapeQuotes(p) + '\"]'\n          : (index > 0 ? '.' : '') + p\n    })\n    .join('')\n}\n\nfunction escapeQuotes(prop: string): string {\n  return prop.replace(/\"/g, '\\\\\"')\n}\n\n/**\n * Parse a JSON path like 'items[3].name' into a path like ['items', '3', 'name']\n */\nexport function parseJSONPath(pathStr: string): JSONPath {\n  const path: JSONPath = []\n  let i = 0\n\n  while (i < pathStr.length) {\n    if (pathStr[i] === '.') {\n      i++\n    }\n\n    if (pathStr[i] === '[') {\n      i++\n\n      if (pathStr[i] === '\"') {\n        i++\n        path.push(parseProp((c) => c === '\"', true))\n        eatCharacter('\"')\n      } else {\n        path.push(parseProp((c) => c === ']'))\n      }\n\n      eatCharacter(']')\n    } else {\n      path.push(parseProp((c) => c === '.' || c === '['))\n    }\n  }\n\n  function parseProp(isEnd: (char: string) => boolean, unescape = false) {\n    let prop = ''\n\n    while (i < pathStr.length && !isEnd(pathStr[i])) {\n      if (unescape && pathStr[i] === '\\\\' && pathStr[i + 1] === '\"') {\n        // escaped double quote\n        prop += '\"'\n        i += 2\n      } else {\n        prop += pathStr[i]\n        i++\n      }\n    }\n\n    return prop\n  }\n\n  function eatCharacter(char: string) {\n    if (pathStr[i] !== char) {\n      throw new SyntaxError(`Invalid JSON path: ${char} expected at position ${i}`)\n    }\n    i++\n  }\n\n  return path\n}\n\n/**\n * Convert a JSONPath into an option for use in a select box\n */\nexport function pathToOption(path: JSONPath): PathOption {\n  return {\n    value: path,\n    label: isEmpty(path) ? '(item root)' : stringifyJSONPath(path)\n  }\n}\n\n/**\n * Stringify a JSON path into a lodash path like:\n *\n *     [\"data\", 2, \"nested property\", \"name\"]\n *\n * into a lodash path like:\n *\n *     \"data[2].nested.name\"\n *\n */\nexport function createLodashPropertySelector(path: JSONPath): string {\n  return path.length === 0\n    ? ''\n    : path.every((prop) => integerNumberRegex.test(prop) || javaScriptPropertyRegex.test(prop))\n      ? \"'\" + path.map(stringifyLodashProperty).join('').replace(/^\\./, '') + \"'\"\n      : JSON.stringify(path)\n}\n\n/**\n * Stringify a single property of a JSON path. See also createLodashPropertySelector\n */\nfunction stringifyLodashProperty(prop: string): string {\n  if (integerNumberRegex.test(prop)) {\n    return '[' + prop + ']'\n  } else if (javaScriptPropertyRegex.test(prop)) {\n    return '.' + prop\n  } else {\n    const propStr = JSON.stringify(prop)\n    // remove enclosing double quotes, and unescape escaped double quotes \\\"\n    const jsonPathStr = propStr.substring(1, propStr.length - 1).replace(/\\\\\"/g, '\"')\n    return \"['\" + jsonPathStr + \"']\"\n  }\n}\n\n/**\n * Create a JavaScript property selector\n *\n * Turn a paths like:\n *\n *   ['location', 'latitude']\n *   ['address', 'full name']\n *\n * into a JavaScript selector (string) like:\n *\n *   '?.location?.latitude'\n *   '?.address?.[\"full name\"]'\n */\nexport function createPropertySelector(path: JSONPath): string {\n  return path\n    .map((prop) => {\n      if (integerNumberRegex.test(prop)) {\n        // an index\n        return `?.[${prop}]`\n      } else if (javaScriptPropertyRegex.test(prop)) {\n        // a key without special characters\n        return `?.${prop}`\n      } else {\n        // a key that may have special characters (like spaces or so)\n        return `?.[${JSON.stringify(prop)}]`\n      }\n    })\n    .join('')\n}\n\n// https://developer.mozilla.org/en-US/docs/Glossary/Identifier\n// Note: We can extend this regex to allow unicode characters too.\n// I'm too lazy to figure that out right now\nconst javaScriptPropertyRegex = /^[a-zA-Z$_][a-zA-Z$_\\d]*$/\nconst integerNumberRegex = /^\\d+$/\n","import type { QueryLanguageOptions } from '$lib/types.js'\n\nexport interface TransformModalState {\n  queryLanguageId: string\n  queryOptions: QueryLanguageOptions\n  query: string\n  isManual: boolean\n}\n\nexport const transformModalStates: Record<string, TransformModalState> = {}\n\nexport interface TransformModalStateShared {\n  showWizard: boolean\n  showOriginal: boolean\n}\n\nexport const transformModalStateShared: TransformModalStateShared = {\n  showWizard: true,\n  showOriginal: true\n}\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element —\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","//@ts-ignore\nimport { arrow as arrowCore } from \"./core\";\nimport { autoUpdate as _autoUpdate, computePosition } from \"./dom/index.js\";\nimport { get } from \"svelte/store\";\nimport { onDestroy, tick } from 'svelte';\nexport function createFloatingActions(initOptions) {\n    let referenceElement;\n    let floatingElement;\n    const defaultOptions = {\n        autoUpdate: true\n    };\n    let options = initOptions;\n    const getOptions = (mixin) => {\n        return { ...defaultOptions, ...(initOptions || {}), ...(mixin || {}) };\n    };\n    const updatePosition = (updateOptions) => {\n        if (referenceElement && floatingElement) {\n            options = getOptions(updateOptions);\n            computePosition(referenceElement, floatingElement, options)\n                .then(v => {\n                Object.assign(floatingElement.style, {\n                    position: v.strategy,\n                    left: `${v.x}px`,\n                    top: `${v.y}px`,\n                });\n                options?.onComputed && options.onComputed(v);\n            });\n        }\n    };\n    const referenceAction = node => {\n        if ('subscribe' in node) {\n            setupVirtualElementObserver(node);\n            return {};\n        }\n        else {\n            referenceElement = node;\n            updatePosition();\n        }\n    };\n    const contentAction = (node, contentOptions) => {\n        let autoUpdateDestroy;\n        floatingElement = node;\n        options = getOptions(contentOptions);\n        setTimeout(() => updatePosition(contentOptions), 0); //tick doesn't work\n        updatePosition(contentOptions);\n        const destroyAutoUpdate = () => {\n            if (autoUpdateDestroy) {\n                autoUpdateDestroy();\n                autoUpdateDestroy = undefined;\n            }\n        };\n        const initAutoUpdate = ({ autoUpdate } = options || {}) => {\n            destroyAutoUpdate();\n            if (autoUpdate !== false) {\n                tick().then(() => {\n                    return _autoUpdate(referenceElement, floatingElement, () => updatePosition(options), (autoUpdate === true ? {} : autoUpdate));\n                });\n            }\n            return;\n        };\n        autoUpdateDestroy = initAutoUpdate();\n        return {\n            update(contentOptions) {\n                updatePosition(contentOptions);\n                autoUpdateDestroy = initAutoUpdate(contentOptions);\n            },\n            destroy() {\n                destroyAutoUpdate();\n            }\n        };\n    };\n    const setupVirtualElementObserver = (node) => {\n        const unsubscribe = node.subscribe(($node) => {\n            if (referenceElement === undefined) {\n                referenceElement = $node;\n                updatePosition();\n            }\n            else {\n                // Preserve the reference to the virtual element.\n                Object.assign(referenceElement, $node);\n                updatePosition();\n            }\n        });\n        onDestroy(unsubscribe);\n    };\n    return [\n        referenceAction,\n        contentAction,\n        updatePosition\n    ];\n}\nexport function arrow(options) {\n    return {\n        name: \"arrow\",\n        options,\n        fn(args) {\n            const element = get(options.element);\n            if (element) {\n                return arrowCore({\n                    element,\n                    padding: options.padding\n                }).fn(args);\n            }\n            return {};\n        }\n    };\n}\n","export default function filter({\n    loadOptions,\n    filterText,\n    items,\n    multiple,\n    value,\n    itemId,\n    groupBy,\n    filterSelectedItems,\n    itemFilter,\n    convertStringItemsToObjects,\n    filterGroupedItems,\n    label,\n}) {\n    if (items && loadOptions) return items;\n    if (!items) return [];\n\n    if (items && items.length > 0 && typeof items[0] !== 'object') {\n        items = convertStringItemsToObjects(items);\n    }\n\n    let filterResults = items.filter((item) => {\n        let matchesFilter = itemFilter(item[label], filterText, item);\n        if (matchesFilter && multiple && value?.length) {\n            matchesFilter = !value.some((x) => {\n                return filterSelectedItems ? x[itemId] === item[itemId] : false;\n            });\n        }\n\n        return matchesFilter;\n    });\n\n    if (groupBy) {\n        filterResults = filterGroupedItems(filterResults);\n    }\n\n    return filterResults;\n}\n","export default async function getItems({ dispatch, loadOptions, convertStringItemsToObjects, filterText }) {\n    let res = await loadOptions(filterText).catch((err) => {\n        console.warn('svelte-select loadOptions error :>> ', err);\n        dispatch('error', { type: 'loadOptions', details: err });\n    });\n\n    if (res && !res.cancelled) {        \n        if (res) {\n            if (res && res.length > 0 && typeof res[0] !== 'object') {\n                res = convertStringItemsToObjects(res);\n            }\n            \n            dispatch('loaded', { items: res });\n        } else {\n            res = [];\n        }\n\n        return {\n            filteredItems: res,\n            loading: false,\n            focused: true,\n            listOpen: true,\n        };\n    }\n}\n","<script>\n    import { beforeUpdate, createEventDispatcher, onDestroy, onMount } from 'svelte';\n    import { offset, flip, shift } from 'svelte-floating-ui/dom';\n    import { createFloatingActions } from 'svelte-floating-ui';\n\n    const dispatch = createEventDispatcher();\n\n    import _filter from './filter';\n    import _getItems from './get-items';\n\n    import ChevronIcon from './ChevronIcon.svelte';\n    import ClearIcon from './ClearIcon.svelte';\n    import LoadingIcon from './LoadingIcon.svelte';\n\n    export let justValue = null; // read-only\n\n    export let filter = _filter;\n    export let getItems = _getItems;\n\n    export let id = null;\n    export let name = null;\n    export let container = undefined;\n    export let input = undefined;\n    export let multiple = false;\n    export let multiFullItemClearable = false;\n    export let disabled = false;\n    export let focused = false;\n    export let value = null;\n    export let filterText = '';\n    export let placeholder = 'Please select';\n    export let placeholderAlwaysShow = false;\n    export let items = null;\n    export let label = 'label';\n    export let itemFilter = (label, filterText, option) => `${label}`.toLowerCase().includes(filterText.toLowerCase());\n    export let groupBy = undefined;\n    export let groupFilter = (groups) => groups;\n    export let groupHeaderSelectable = false;\n    export let itemId = 'value';\n    export let loadOptions = undefined;\n    export let containerStyles = '';\n    export let hasError = false;\n    export let filterSelectedItems = true;\n    export let required = false;\n    export let closeListOnChange = true;\n    export let clearFilterTextOnBlur = true;\n\n    export let createGroupHeaderItem = (groupValue, item) => {\n        return {\n            value: groupValue,\n            [label]: groupValue,\n        };\n    };\n\n    export const getFilteredItems = () => {\n        return filteredItems;\n    };\n\n    export let searchable = true;\n    export let inputStyles = '';\n    export let clearable = true;\n    export let loading = false;\n    export let listOpen = false;\n\n    let timeout;\n    export let debounce = (fn, wait = 1) => {\n        clearTimeout(timeout);\n        timeout = setTimeout(fn, wait);\n    };\n\n    export let debounceWait = 300;\n    export let hideEmptyState = false;\n    export let inputAttributes = {};\n    export let listAutoWidth = true;\n    export let showChevron = false;\n    export let listOffset = 5;\n    export let hoverItemIndex = 0;\n    export let floatingConfig = {};\n\n    export { containerClasses as class };\n\n    let containerClasses = '';\n    let activeValue;\n    let prev_value;\n    let prev_filterText;\n    let prev_multiple;\n\n    function setValue() {\n        if (typeof value === 'string') {\n            let item = (items || []).find((item) => item[itemId] === value);\n            value = item || {\n                [itemId]: value,\n                label: value,\n            };\n        } else if (multiple && Array.isArray(value) && value.length > 0) {\n            value = value.map((item) => (typeof item === 'string' ? { value: item, label: item } : item));\n        }\n    }\n\n    let _inputAttributes;\n    function assignInputAttributes() {\n        _inputAttributes = Object.assign(\n            {\n                autocapitalize: 'none',\n                autocomplete: 'off',\n                autocorrect: 'off',\n                spellcheck: false,\n                tabindex: 0,\n                type: 'text',\n                'aria-autocomplete': 'list',\n            },\n            inputAttributes\n        );\n\n        if (id) {\n            _inputAttributes['id'] = id;\n        }\n\n        if (!searchable) {\n            _inputAttributes['readonly'] = true;\n        }\n    }\n\n    function convertStringItemsToObjects(_items) {\n        return _items.map((item, index) => {\n            return {\n                index,\n                value: item,\n                label: `${item}`,\n            };\n        });\n    }\n\n    function filterGroupedItems(_items) {\n        const groupValues = [];\n        const groups = {};\n\n        _items.forEach((item) => {\n            const groupValue = groupBy(item);\n\n            if (!groupValues.includes(groupValue)) {\n                groupValues.push(groupValue);\n                groups[groupValue] = [];\n\n                if (groupValue) {\n                    groups[groupValue].push(\n                        Object.assign(createGroupHeaderItem(groupValue, item), {\n                            id: groupValue,\n                            groupHeader: true,\n                            selectable: groupHeaderSelectable,\n                        })\n                    );\n                }\n            }\n\n            groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));\n        });\n\n        const sortedGroupedItems = [];\n\n        groupFilter(groupValues).forEach((groupValue) => {\n            if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);\n        });\n\n        return sortedGroupedItems;\n    }\n\n    function dispatchSelectedItem() {\n        if (multiple) {\n            if (JSON.stringify(value) !== JSON.stringify(prev_value)) {\n                if (checkValueForDuplicates()) {\n                    dispatch('input', value);\n                }\n            }\n            return;\n        }\n\n        if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {\n            dispatch('input', value);\n        }\n    }\n\n    function setupMulti() {\n        if (value) {\n            if (Array.isArray(value)) {\n                value = [...value];\n            } else {\n                value = [value];\n            }\n        }\n    }\n\n    function setupSingle() {\n        if (value) value = null;\n    }\n\n    $: if ((items, value)) setValue();\n    $: if (inputAttributes || !searchable) assignInputAttributes();\n    $: if (multiple) setupMulti();\n    $: if (prev_multiple && !multiple) setupSingle();\n    $: if (multiple && value && value.length > 1) checkValueForDuplicates();\n    $: if (value) dispatchSelectedItem();\n    $: if (!value && multiple && prev_value) dispatch('input', value);\n    $: if (!focused && input) closeList();\n    $: if (filterText !== prev_filterText) setupFilterText();\n    $: if (!multiple && listOpen && value && filteredItems) setValueIndexAsHoverIndex();\n    $: dispatchHover(hoverItemIndex);\n\n    function setValueIndexAsHoverIndex() {\n        const valueIndex = filteredItems.findIndex((i) => {\n            return i[itemId] === value[itemId];\n        });\n\n        checkHoverSelectable(valueIndex, true);\n    }\n\n    function dispatchHover(i) {\n        dispatch('hoverItem', i);\n    }\n\n    function checkHoverSelectable(startingIndex = 0, ignoreGroup) {\n        hoverItemIndex = startingIndex < 0 ? 0 : startingIndex;\n        if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {\n            setHoverIndex(1);\n        }\n    }\n\n    function setupFilterText() {\n        if (!loadOptions && filterText.length === 0) return;\n\n        if (loadOptions) {\n            debounce(async function () {\n                loading = true;\n                let res = await getItems({\n                    dispatch,\n                    loadOptions,\n                    convertStringItemsToObjects,\n                    filterText,\n                });\n\n                if (res) {\n                    loading = res.loading;\n                    listOpen = listOpen ? res.listOpen : filterText.length > 0 ? true : false;\n                    focused = listOpen && res.focused;\n                    items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems;\n                } else {\n                    loading = false;\n                    focused = true;\n                    listOpen = true;\n                }\n            }, debounceWait);\n        } else {\n            listOpen = true;\n\n            if (multiple) {\n                activeValue = undefined;\n            }\n        }\n    }\n\n    $: hasValue = multiple ? value && value.length > 0 : value;\n    $: hideSelectedItem = hasValue && filterText.length > 0;\n    $: showClear = hasValue && clearable && !disabled && !loading;\n    $: placeholderText =\n        placeholderAlwaysShow && multiple\n            ? placeholder\n            : multiple && value?.length === 0\n            ? placeholder\n            : value\n            ? ''\n            : placeholder;\n    $: ariaSelection = value ? handleAriaSelection(multiple) : '';\n    $: ariaContext = handleAriaContent({ filteredItems, hoverItemIndex, focused, listOpen });\n    $: updateValueDisplay(items);\n    $: justValue = computeJustValue(multiple, value, itemId);\n    $: if (!multiple && prev_value && !value) dispatch('input', value);\n    $: filteredItems = filter({\n        loadOptions,\n        filterText,\n        items,\n        multiple,\n        value,\n        itemId,\n        groupBy,\n        label,\n        filterSelectedItems,\n        itemFilter,\n        convertStringItemsToObjects,\n        filterGroupedItems,\n    });\n    $: if (listOpen && filteredItems && !multiple && !value) checkHoverSelectable();\n    $: handleFilterEvent(filteredItems);\n    $: if (container && floatingConfig) floatingUpdate(Object.assign(_floatingConfig, floatingConfig));\n    $: listDom = !!list;\n    $: listMounted(list, listOpen);\n    $: if (listOpen && container && list) setListWidth();\n    $: scrollToHoverItem = hoverItemIndex;\n    $: if (listOpen && multiple) hoverItemIndex = 0;\n    $: if (input && listOpen && !focused) handleFocus();\n    $: if (filterText) hoverItemIndex = 0;\n\n    function handleFilterEvent(items) {\n        if (listOpen) dispatch('filter', items);\n    }\n\n    beforeUpdate(async () => {\n        prev_value = value;\n        prev_filterText = filterText;\n        prev_multiple = multiple;\n    });\n\n    function computeJustValue() {\n        if (multiple) return value ? value.map((item) => item[itemId]) : null;\n        return value ? value[itemId] : value;\n    }\n\n    function checkValueForDuplicates() {\n        let noDuplicates = true;\n        if (value) {\n            const ids = [];\n            const uniqueValues = [];\n\n            value.forEach((val) => {\n                if (!ids.includes(val[itemId])) {\n                    ids.push(val[itemId]);\n                    uniqueValues.push(val);\n                } else {\n                    noDuplicates = false;\n                }\n            });\n\n            if (!noDuplicates) value = uniqueValues;\n        }\n        return noDuplicates;\n    }\n\n    function findItem(selection) {\n        let matchTo = selection ? selection[itemId] : value[itemId];\n        return items.find((item) => item[itemId] === matchTo);\n    }\n\n    function updateValueDisplay(items) {\n        if (!items || items.length === 0 || items.some((item) => typeof item !== 'object')) return;\n        if (!value || (multiple ? value.some((selection) => !selection || !selection[itemId]) : !value[itemId])) return;\n\n        if (Array.isArray(value)) {\n            value = value.map((selection) => findItem(selection) || selection);\n        } else {\n            value = findItem() || value;\n        }\n    }\n\n    async function handleMultiItemClear(i) {\n        const itemToRemove = value[i];\n\n        if (value.length === 1) {\n            value = undefined;\n        } else {\n            value = value.filter((item) => {\n                return item !== itemToRemove;\n            });\n        }\n\n        dispatch('clear', itemToRemove);\n    }\n\n    function handleKeyDown(e) {\n        if (!focused) return;\n        e.stopPropagation();\n        switch (e.key) {\n            case 'Escape':\n                e.preventDefault();\n                closeList();\n                break;\n            case 'Enter':\n                e.preventDefault();\n\n                if (listOpen) {\n                    if (filteredItems.length === 0) break;\n                    const hoverItem = filteredItems[hoverItemIndex];\n\n                    if (value && !multiple && value[itemId] === hoverItem[itemId]) {\n                        closeList();\n                        break;\n                    } else {\n                        handleSelect(filteredItems[hoverItemIndex]);\n                    }\n                }\n\n                break;\n            case 'ArrowDown':\n                e.preventDefault();\n\n                if (listOpen) {\n                    setHoverIndex(1);\n                } else {\n                    listOpen = true;\n                    activeValue = undefined;\n                }\n\n                break;\n            case 'ArrowUp':\n                e.preventDefault();\n\n                if (listOpen) {\n                    setHoverIndex(-1);\n                } else {\n                    listOpen = true;\n                    activeValue = undefined;\n                }\n\n                break;\n            case 'Tab':\n                if (listOpen && focused) {\n                    if (\n                        filteredItems.length === 0 ||\n                        (value && value[itemId] === filteredItems[hoverItemIndex][itemId])\n                    )\n                        return closeList();\n\n                    e.preventDefault();\n                    handleSelect(filteredItems[hoverItemIndex]);\n                    closeList();\n                }\n\n                break;\n            case 'Backspace':\n                if (!multiple || filterText.length > 0) return;\n\n                if (multiple && value && value.length > 0) {\n                    handleMultiItemClear(activeValue !== undefined ? activeValue : value.length - 1);\n                    if (activeValue === 0 || activeValue === undefined) break;\n                    activeValue = value.length > activeValue ? activeValue - 1 : undefined;\n                }\n\n                break;\n            case 'ArrowLeft':\n                if (!value || !multiple || filterText.length > 0) return;\n                if (activeValue === undefined) {\n                    activeValue = value.length - 1;\n                } else if (value.length > activeValue && activeValue !== 0) {\n                    activeValue -= 1;\n                }\n                break;\n            case 'ArrowRight':\n                if (!value || !multiple || filterText.length > 0 || activeValue === undefined) return;\n                if (activeValue === value.length - 1) {\n                    activeValue = undefined;\n                } else if (activeValue < value.length - 1) {\n                    activeValue += 1;\n                }\n                break;\n        }\n    }\n\n    function handleFocus(e) {\n        if (focused && input === document?.activeElement) return;\n        if (e) dispatch('focus', e);\n        input?.focus();\n        focused = true;\n    }\n\n    async function handleBlur(e) {\n        if (isScrolling) return;\n        if (listOpen || focused) {\n            dispatch('blur', e);\n            closeList();\n            focused = false;\n            activeValue = undefined;\n            input?.blur();\n        }\n    }\n\n    function handleClick() {\n        if (disabled) return;\n        if (filterText.length > 0) return listOpen = true;\n        listOpen = !listOpen;\n    }\n\n    export function handleClear() {\n        dispatch('clear', value);\n        value = undefined;\n        closeList();\n        handleFocus();\n    }\n\n    onMount(() => {\n        if (listOpen) focused = true;\n        if (focused && input) input.focus();\n    });\n\n    function itemSelected(selection) {\n        if (selection) {\n            filterText = '';\n            const item = Object.assign({}, selection);\n\n            if (item.groupHeader && !item.selectable) return;\n            value = multiple ? (value ? value.concat([item]) : [item]) : (value = item);\n\n            setTimeout(() => {\n                if (closeListOnChange) closeList();\n                activeValue = undefined;\n                dispatch('change', value);\n                dispatch('select', selection);\n            });\n        }\n    }\n\n    function closeList() {\n        if (clearFilterTextOnBlur) {\n            filterText = '';\n        }\n        listOpen = false;\n    }\n\n    export let ariaValues = (values) => {\n        return `Option ${values}, selected.`;\n    };\n\n    export let ariaListOpen = (label, count) => {\n        return `You are currently focused on option ${label}. There are ${count} results available.`;\n    };\n\n    export let ariaFocused = () => {\n        return `Select is focused, type to refine list, press down to open the menu.`;\n    };\n\n    function handleAriaSelection(_multiple) {\n        let selected = undefined;\n\n        if (_multiple && value.length > 0) {\n            selected = value.map((v) => v[label]).join(', ');\n        } else {\n            selected = value[label];\n        }\n\n        return ariaValues(selected);\n    }\n\n    function handleAriaContent() {\n        if (!filteredItems || filteredItems.length === 0) return '';\n        let _item = filteredItems[hoverItemIndex];\n        if (listOpen && _item) {\n            let count = filteredItems ? filteredItems.length : 0;\n            return ariaListOpen(_item[label], count);\n        } else {\n            return ariaFocused();\n        }\n    }\n\n    let list = null;\n\n    let isScrollingTimer;\n    function handleListScroll() {\n        clearTimeout(isScrollingTimer);\n        isScrollingTimer = setTimeout(() => {\n            isScrolling = false;\n        }, 100);\n    }\n\n    function handleClickOutside(event) {\n        if (!listOpen && !focused && container && !container.contains(event.target) && !list?.contains(event.target)) {\n            handleBlur();\n        }\n    }\n\n    onDestroy(() => {\n        list?.remove();\n    });\n\n    let isScrolling = false;\n\n    function handleSelect(item) {\n        if (!item || item.selectable === false) return;\n        itemSelected(item);\n    }\n\n    function handleHover(i) {\n        if (isScrolling) return;\n        hoverItemIndex = i;\n    }\n\n    function handleItemClick(args) {\n        const { item, i } = args;\n        if (item?.selectable === false) return;\n        if (value && !multiple && value[itemId] === item[itemId]) return closeList();\n        if (isItemSelectable(item)) {\n            hoverItemIndex = i;\n            handleSelect(item);\n        }\n    }\n\n    function setHoverIndex(increment) {\n        let selectableFilteredItems = filteredItems.filter(\n            (item) => !Object.hasOwn(item, 'selectable') || item.selectable === true\n        );\n\n        if (selectableFilteredItems.length === 0) {\n            return (hoverItemIndex = 0);\n        }\n\n        if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {\n            hoverItemIndex = 0;\n        } else if (increment < 0 && hoverItemIndex === 0) {\n            hoverItemIndex = filteredItems.length - 1;\n        } else {\n            hoverItemIndex = hoverItemIndex + increment;\n        }\n\n        const hover = filteredItems[hoverItemIndex];\n\n        if (hover && hover.selectable === false) {\n            if (increment === 1 || increment === -1) setHoverIndex(increment);\n            return;\n        }\n    }\n\n    function isItemActive(item, value, itemId) {\n        if (multiple) return;\n        return value && value[itemId] === item[itemId];\n    }\n\n    function isItemFirst(itemIndex) {\n        return itemIndex === 0;\n    }\n\n    function isItemSelectable(item) {\n        return (item.groupHeader && item.selectable) || item.selectable || !item.hasOwnProperty('selectable');\n    }\n\n    const activeScroll = scrollAction;\n    const hoverScroll = scrollAction;\n\n    function scrollAction(node) {\n        return {\n            update(args) {\n                if (args.scroll) {\n                    handleListScroll();\n                    node.scrollIntoView({ behavior: 'auto', block: 'nearest' });\n                }\n            },\n        };\n    }\n\n    function setListWidth() {\n        const { width } = container.getBoundingClientRect();\n        list.style.width = listAutoWidth ? width + 'px' : 'auto';\n    }\n\n    let _floatingConfig = {\n        strategy: 'absolute',\n        placement: 'bottom-start',\n        middleware: [offset(listOffset), flip(), shift()],\n        autoUpdate: false,\n    };\n\n    const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(_floatingConfig);\n\n    $: if (container && floatingConfig?.autoUpdate === undefined) {\n        _floatingConfig.autoUpdate = true;\n    }\n\n    let prefloat = true;\n    function listMounted(list, listOpen) {\n        if (!list || !listOpen) return (prefloat = true);\n        setTimeout(() => {\n            prefloat = false;\n        }, 0);\n    }\n</script>\n\n<svelte:window on:click={handleClickOutside} on:keydown={handleKeyDown} />\n\n<div\n    class=\"svelte-select {containerClasses}\"\n    class:multi={multiple}\n    class:disabled\n    class:focused\n    class:list-open={listOpen}\n    class:show-chevron={showChevron}\n    class:error={hasError}\n    style={containerStyles}\n    on:pointerup|preventDefault={handleClick}\n    bind:this={container}\n    use:floatingRef\n    role=\"none\">\n    {#if listOpen}\n        <div\n            use:floatingContent\n            bind:this={list}\n            class=\"svelte-select-list\"\n            class:prefloat\n            on:scroll={handleListScroll}\n            on:pointerup|preventDefault|stopPropagation\n            on:mousedown|preventDefault|stopPropagation\n\t\t\trole=\"none\">\n            {#if $$slots['list-prepend']}<slot name=\"list-prepend\" />{/if}\n            {#if $$slots.list}<slot name=\"list\" {filteredItems} />\n            {:else if filteredItems.length > 0}\n                {#each filteredItems as item, i}\n                    <div\n                        on:mouseover={() => handleHover(i)}\n                        on:focus={() => handleHover(i)}\n                        on:click|stopPropagation={() => handleItemClick({ item, i })}\n                        on:keydown|preventDefault|stopPropagation\n                        class=\"list-item\"\n                        tabindex=\"-1\"\n                        role=\"none\">\n                        <div\n                            use:activeScroll={{ scroll: isItemActive(item, value, itemId), listDom }}\n                            use:hoverScroll={{ scroll: scrollToHoverItem === i, listDom }}\n                            class=\"item\"\n                            class:list-group-title={item.groupHeader}\n                            class:active={isItemActive(item, value, itemId)}\n                            class:first={isItemFirst(i)}\n                            class:hover={hoverItemIndex === i}\n                            class:group-item={item.groupItem}\n                            class:not-selectable={item?.selectable === false}>\n                            <slot name=\"item\" {item} index={i}>\n                                {item?.[label]}\n                            </slot>\n                        </div>\n                    </div>\n                {/each}\n            {:else if !hideEmptyState}\n                <slot name=\"empty\">\n                    <div class=\"empty\">No options</div>\n                </slot>\n            {/if}\n            {#if $$slots['list-append']}<slot name=\"list-append\" />{/if}\n        </div>\n    {/if}\n\n    <span aria-live=\"polite\" aria-atomic=\"false\" aria-relevant=\"additions text\" class=\"a11y-text\">\n        {#if focused}\n            <span id=\"aria-selection\">{ariaSelection}</span>\n            <span id=\"aria-context\">\n                {ariaContext}\n            </span>\n        {/if}\n    </span>\n\n    <div class=\"prepend\">\n        <slot name=\"prepend\" />\n    </div>\n\n    <div class=\"value-container\">\n        {#if hasValue}\n            {#if multiple}\n                {#each value as item, i}\n                    <div\n                        class=\"multi-item\"\n                        class:active={activeValue === i}\n                        class:disabled\n                        on:click|preventDefault={() => (multiFullItemClearable ? handleMultiItemClear(i) : {})}\n                        on:keydown|preventDefault|stopPropagation\n                        role=\"none\">\n                        <span class=\"multi-item-text\">\n                            <slot name=\"selection\" selection={item} index={i}>\n                                {item[label]}\n                            </slot>\n                        </span>\n\n                        {#if !disabled && !multiFullItemClearable && ClearIcon}\n                            <div\n                                class=\"multi-item-clear\"\n                                on:pointerup|preventDefault|stopPropagation={() => handleMultiItemClear(i)}>\n                                <slot name=\"multi-clear-icon\">\n                                    <ClearIcon />\n                                </slot>\n                            </div>\n                        {/if}\n                    </div>\n                {/each}\n            {:else}\n                <div class=\"selected-item\" class:hide-selected-item={hideSelectedItem}>\n                    <slot name=\"selection\" selection={value}>\n                        {value[label]}\n                    </slot>\n                </div>\n            {/if}\n        {/if}\n\n        <input\n            on:keydown={handleKeyDown}\n            on:blur={handleBlur}\n            on:focus={handleFocus}\n            readOnly={!searchable}\n            {..._inputAttributes}\n            bind:this={input}\n            bind:value={filterText}\n            placeholder={placeholderText}\n            style={inputStyles}\n            {disabled} />\n    </div>\n\n    <div class=\"indicators\">\n        {#if loading}\n            <div class=\"icon loading\" aria-hidden=\"true\">\n                <slot name=\"loading-icon\">\n                    <LoadingIcon />\n                </slot>\n            </div>\n        {/if}\n\n        {#if showClear}\n            <button type=\"button\" class=\"icon clear-select\" on:click={handleClear}>\n                <slot name=\"clear-icon\">\n                    <ClearIcon />\n                </slot>\n            </button>\n        {/if}\n\n        {#if showChevron}\n            <div class=\"icon chevron\" aria-hidden=\"true\">\n                <slot name=\"chevron-icon\" {listOpen}>\n                    <ChevronIcon />\n                </slot>\n            </div>\n        {/if}\n    </div>\n\n    <slot name=\"input-hidden\" {value}>\n        <input {name} type=\"hidden\" value={value ? JSON.stringify(value) : null} />\n    </slot>\n\n    {#if required && (!value || value.length === 0)}\n        <slot name=\"required\" {value}>\n            <select class=\"required\" required tabindex=\"-1\" aria-hidden=\"true\" />\n        </slot>\n    {/if}\n</div>\n\n<style>\n    .svelte-select {\n        /* deprecating camelCase custom props in favour of kebab-case for v5 */\n        --borderRadius: var(--border-radius);\n        --clearSelectColor: var(--clear-select-color);\n        --clearSelectWidth: var(--clear-select-width);\n        --disabledBackground: var(--disabled-background);\n        --disabledBorderColor: var(--disabled-border-color);\n        --disabledColor: var(--disabled-color);\n        --disabledPlaceholderColor: var(--disabled-placeholder-color);\n        --disabledPlaceholderOpacity: var(--disabled-placeholder-opacity);\n        --errorBackground: var(--error-background);\n        --errorBorder: var(--error-border);\n        --groupItemPaddingLeft: var(--group-item-padding-left);\n        --groupTitleColor: var(--group-title-color);\n        --groupTitleFontSize: var(--group-title-font-size);\n        --groupTitleFontWeight: var(--group-title-font-weight);\n        --groupTitlePadding: var(--group-title-padding);\n        --groupTitleTextTransform: var(--group-title-text-transform);\n        --groupTitleBorderColor: var(--group-title-border-color);\n        --groupTitleBorderWidth: var(--group-title-border-width);\n        --groupTitleBorderStyle: var(--group-title-border-style);\n        --indicatorColor: var(--chevron-color);\n        --indicatorHeight: var(--chevron-height);\n        --indicatorWidth: var(--chevron-width);\n        --inputColor: var(--input-color);\n        --inputLeft: var(--input-left);\n        --inputLetterSpacing: var(--input-letter-spacing);\n        --inputMargin: var(--input-margin);\n        --inputPadding: var(--input-padding);\n        --itemActiveBackground: var(--item-active-background);\n        --itemColor: var(--item-color);\n        --itemFirstBorderRadius: var(--item-first-border-radius);\n        --itemHoverBG: var(--item-hover-bg);\n        --itemHoverColor: var(--item-hover-color);\n        --itemIsActiveBG: var(--item-is-active-bg);\n        --itemIsActiveColor: var(--item-is-active-color);\n        --itemIsNotSelectableColor: var(--item-is-not-selectable-color);\n        --itemPadding: var(--item-padding);\n        --listBackground: var(--list-background);\n        --listBorder: var(--list-border);\n        --listBorderRadius: var(--list-border-radius);\n        --listEmptyColor: var(--list-empty-color);\n        --listEmptyPadding: var(--list-empty-padding);\n        --listEmptyTextAlign: var(--list-empty-text-align);\n        --listMaxHeight: var(--list-max-height);\n        --listPosition: var(--list-position);\n        --listShadow: var(--list-shadow);\n        --listZIndex: var(--list-z-index);\n        --multiItemBG: var(--multi-item-bg);\n        --multiItemBorderRadius: var(--multi-item-border-radius);\n        --multiItemDisabledHoverBg: var(--multi-item-disabled-hover-bg);\n        --multiItemDisabledHoverColor: var(--multi-item-disabled-hover-color);\n        --multiItemHeight: var(--multi-item-height);\n        --multiItemMargin: var(--multi-item-margin);\n        --multiItemPadding: var(--multi-item-padding);\n        --multiSelectInputMargin: var(--multi-select-input-margin);\n        --multiSelectInputPadding: var(--multi-select-input-padding);\n        --multiSelectPadding: var(--multi-select-padding);\n        --placeholderColor: var(--placeholder-color);\n        --placeholderOpacity: var(--placeholder-opacity);\n        --selectedItemPadding: var(--selected-item-padding);\n        --spinnerColor: var(--spinner-color);\n        --spinnerHeight: var(--spinner-height);\n        --spinnerWidth: var(--spinner-width);\n\n        --internal-padding: 0 0 0 16px;\n\n        border: var(--border, 1px solid #d8dbdf);\n        border-radius: var(--border-radius, 6px);\n        min-height: var(--height, 42px);\n        position: relative;\n        display: flex;\n        align-items: stretch;\n        padding: var(--padding, var(--internal-padding));\n        background: var(--background, #fff);\n        margin: var(--margin, 0);\n        width: var(--width, 100%);\n        font-size: var(--font-size, 16px);\n        max-height: var(--max-height);\n    }\n\n    * {\n        box-sizing: var(--box-sizing, border-box);\n    }\n\n    .svelte-select:hover {\n        border: var(--border-hover, 1px solid #b2b8bf);\n    }\n\n    .value-container {\n        display: flex;\n        flex: 1 1 0%;\n        flex-wrap: wrap;\n        align-items: center;\n        gap: 5px 10px;\n        padding: var(--value-container-padding, 5px 0);\n        position: relative;\n        overflow: var(--value-container-overflow, hidden);\n        align-self: stretch;\n    }\n\n    .prepend,\n    .indicators {\n        display: flex;\n        flex-shrink: 0;\n        align-items: center;\n    }\n\n    .indicators {\n        position: var(--indicators-position);\n        top: var(--indicators-top);\n        right: var(--indicators-right);\n        bottom: var(--indicators-bottom);\n    }\n\n    input {\n        position: absolute;\n        cursor: default;\n        border: none;\n        color: var(--input-color, var(--item-color));\n        padding: var(--input-padding, 0);\n        letter-spacing: var(--input-letter-spacing, inherit);\n        margin: var(--input-margin, 0);\n        min-width: 10px;\n        top: 0;\n        right: 0;\n        bottom: 0;\n        left: 0;\n        background: transparent;\n        font-size: var(--font-size, 16px);\n    }\n\n    :not(.multi) > .value-container > input {\n        width: 100%;\n        height: 100%;\n    }\n\n    input::placeholder {\n        color: var(--placeholder-color, #78848f);\n        opacity: var(--placeholder-opacity, 1);\n    }\n\n    input:focus {\n        outline: none;\n    }\n\n    .svelte-select.focused {\n        border: var(--border-focused, 1px solid #006fe8);\n        border-radius: var(--border-radius-focused, var(--border-radius, 6px));\n    }\n\n    .disabled {\n        background: var(--disabled-background, #ebedef);\n        border-color: var(--disabled-border-color, #ebedef);\n        color: var(--disabled-color, #c1c6cc);\n    }\n\n    .disabled input::placeholder {\n        color: var(--disabled-placeholder-color, #c1c6cc);\n        opacity: var(--disabled-placeholder-opacity, 1);\n    }\n\n    .selected-item {\n        position: relative;\n        overflow: var(--selected-item-overflow, hidden);\n        padding: var(--selected-item-padding, 0 20px 0 0);\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        color: var(--selected-item-color, inherit);\n        font-size: var(--font-size, 16px);\n    }\n\n    .multi .selected-item {\n        position: absolute;\n        line-height: var(--height, 42px);\n        height: var(--height, 42px);\n    }\n\n    .selected-item:focus {\n        outline: none;\n    }\n\n    .hide-selected-item {\n        opacity: 0;\n    }\n\n    .icon {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    .clear-select {\n        all: unset;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        width: var(--clear-select-width, 40px);\n        height: var(--clear-select-height, 100%);\n        color: var(--clear-select-color, var(--icons-color));\n        margin: var(--clear-select-margin, 0);\n        pointer-events: all;\n        flex-shrink: 0;\n    }\n\n    .clear-select:focus {\n        outline: var(--clear-select-focus-outline, 1px solid #006fe8);\n    }\n\n    .loading {\n        width: var(--loading-width, 40px);\n        height: var(--loading-height);\n        color: var(--loading-color, var(--icons-color));\n        margin: var(--loading--margin, 0);\n        flex-shrink: 0;\n    }\n\n    .chevron {\n        width: var(--chevron-width, 40px);\n        height: var(--chevron-height, 40px);\n        background: var(--chevron-background, transparent);\n        pointer-events: var(--chevron-pointer-events, none);\n        color: var(--chevron-color, var(--icons-color));\n        border: var(--chevron-border, 0 0 0 1px solid #d8dbdf);\n        flex-shrink: 0;\n    }\n\n    .multi {\n        padding: var(--multi-select-padding, var(--internal-padding));\n    }\n\n    .multi input {\n        padding: var(--multi-select-input-padding, 0);\n        position: relative;\n        margin: var(--multi-select-input-margin, 5px 0);\n        flex: 1 1 40px;\n    }\n\n    .svelte-select.error {\n        border: var(--error-border, 1px solid #ff2d55);\n        background: var(--error-background, #fff);\n    }\n\n    .a11y-text {\n        z-index: 9999;\n        border: 0px;\n        clip: rect(1px, 1px, 1px, 1px);\n        height: 1px;\n        width: 1px;\n        position: absolute;\n        overflow: hidden;\n        padding: 0px;\n        white-space: nowrap;\n    }\n\n    .multi-item {\n        background: var(--multi-item-bg, #ebedef);\n        margin: var(--multi-item-margin, 0);\n        outline: var(--multi-item-outline, 1px solid #ddd);\n        border-radius: var(--multi-item-border-radius, 4px);\n        height: var(--multi-item-height, 25px);\n        line-height: var(--multi-item-height, 25px);\n        display: flex;\n        cursor: default;\n        padding: var(--multi-item-padding, 0 5px);\n        overflow: hidden;\n        gap: var(--multi-item-gap, 4px);\n        outline-offset: -1px;\n        max-width: var(--multi-max-width, none);\n        color: var(--multi-item-color, var(--item-color));\n    }\n\n    .multi-item.disabled:hover {\n        background: var(--multi-item-disabled-hover-bg, #ebedef);\n        color: var(--multi-item-disabled-hover-color, #c1c6cc);\n    }\n\n    .multi-item-text {\n        overflow: hidden;\n        text-overflow: ellipsis;\n        white-space: nowrap;\n    }\n\n    .multi-item-clear {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        --clear-icon-color: var(--multi-item-clear-icon-color, #000);\n    }\n\n    .multi-item.active {\n        outline: var(--multi-item-active-outline, 1px solid #006fe8);\n    }\n\n    .svelte-select-list {\n        box-shadow: var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));\n        border-radius: var(--list-border-radius, 4px);\n        max-height: var(--list-max-height, 252px);\n        overflow-y: auto;\n        background: var(--list-background, #fff);\n        position: var(--list-position, absolute);\n        z-index: var(--list-z-index, 2);\n        border: var(--list-border);\n    }\n\n    .prefloat {\n        opacity: 0;\n        pointer-events: none;\n    }\n\n    .list-group-title {\n        color: var(--group-title-color, #8f8f8f);\n        cursor: default;\n        font-size: var(--group-title-font-size, 16px);\n        font-weight: var(--group-title-font-weight, 600);\n        height: var(--height, 42px);\n        line-height: var(--height, 42px);\n        padding: var(--group-title-padding, 0 20px);\n        text-overflow: ellipsis;\n        overflow-x: hidden;\n        white-space: nowrap;\n        text-transform: var(--group-title-text-transform, uppercase);\n        border-width: var(--group-title-border-width, medium);\n        border-style: var(--group-title-border-style, none);\n        border-color: var(--group-title-border-color, color);\n    }\n\n    .empty {\n        text-align: var(--list-empty-text-align, center);\n        padding: var(--list-empty-padding, 20px 0);\n        color: var(--list-empty-color, #78848f);\n    }\n\n    .item {\n        cursor: default;\n        height: var(--item-height, var(--height, 42px));\n        line-height: var(--item-line-height, var(--height, 42px));\n        padding: var(--item-padding, 0 20px);\n        color: var(--item-color, inherit);\n        text-overflow: ellipsis;\n        overflow: hidden;\n        white-space: nowrap;\n        transition: var(--item-transition, all 0.2s);\n        align-items: center;\n        width: 100%;\n    }\n\n    .item.group-item {\n        padding-left: var(--group-item-padding-left, 40px);\n    }\n\n    .item:active {\n        background: var(--item-active-background, #b9daff);\n    }\n\n    .item.active {\n        background: var(--item-is-active-bg, #007aff);\n        color: var(--item-is-active-color, #fff);\n    }\n\n    .item.first {\n        border-radius: var(--item-first-border-radius, 4px 4px 0 0);\n    }\n\n    .item.hover:not(.active) {\n        background: var(--item-hover-bg, #e7f2ff);\n        color: var(--item-hover-color, inherit);\n    }\n\n    .item.not-selectable,\n    .item.hover.item.not-selectable,\n    .item.active.item.not-selectable,\n    .item.not-selectable:active {\n        color: var(--item-is-not-selectable-color, #999);\n        background: transparent;\n    }\n\n    .required {\n        opacity: 0;\n        z-index: -1;\n        position: absolute;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n    }\n</style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Select from 'svelte-select'\n  import { getNestedPaths } from '$lib/utils/arrayUtils.js'\n  import { pathToOption } from '$lib/utils/pathUtils.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { isEqual } from 'lodash-es'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { setIn } from 'immutable-json-patch'\n  import type { PathOption, QueryLanguageOptions } from '$lib/types.js'\n\n  const debug = createDebug('jsoneditor:TransformWizard')\n\n  export let json: unknown\n  export let queryOptions: QueryLanguageOptions = {}\n  export let onChange: (queryOptions: QueryLanguageOptions) => void\n\n  // options\n  $: jsonIsArray = Array.isArray(json)\n  $: paths = jsonIsArray ? getNestedPaths(json) : []\n  $: pathsIncludingObjects = jsonIsArray ? getNestedPaths(json, true) : []\n  $: fieldOptions = paths.map(pathToOption)\n  $: projectionOptions = pathsIncludingObjects ? pathsIncludingObjects.map(pathToOption) : []\n\n  const filterRelationOptions = ['==', '!=', '<', '<=', '>', '>='].map((relation) => ({\n    value: relation,\n    label: relation\n  }))\n\n  const sortDirectionOptions = [\n    { value: 'asc', label: 'ascending' },\n    { value: 'desc', label: 'descending' }\n  ]\n\n  // TODO: the binding with the select boxes is very cumbersome. Can we simplify this?\n  let filterPath = queryOptions?.filter?.path ? pathToOption(queryOptions.filter.path) : undefined\n  let filterRelation =\n    filterRelationOptions.find((option) => option.value === queryOptions.filter?.relation) ??\n    filterRelationOptions[0]\n  let filterValue = queryOptions?.filter?.value || ''\n  let sortPath = queryOptions?.sort?.path ? pathToOption(queryOptions.sort.path) : undefined\n  let sortDirection =\n    sortDirectionOptions.find((option) => option.value === queryOptions.sort?.direction) ??\n    sortDirectionOptions[0]\n\n  $: projectionPaths =\n    queryOptions?.projection?.paths && projectionOptions\n      ? (queryOptions.projection.paths\n          .map((path) => projectionOptions.find((option) => isEqual(option.value, path)))\n          .filter((option) => !!option) as PathOption[])\n      : undefined\n\n  function changeFilterPath(path: JSONPath | undefined) {\n    if (!isEqual(queryOptions?.filter?.path, path)) {\n      debug('changeFilterPath', path)\n      queryOptions = setIn(queryOptions, ['filter', 'path'], path, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeFilterRelation(relation: string | undefined) {\n    if (!isEqual(queryOptions?.filter?.relation, relation)) {\n      debug('changeFilterRelation', relation)\n      queryOptions = setIn(queryOptions, ['filter', 'relation'], relation, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeFilterValue(value: string | undefined) {\n    if (!isEqual(queryOptions?.filter?.value, value)) {\n      debug('changeFilterValue', value)\n      queryOptions = setIn(queryOptions, ['filter', 'value'], value, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeSortPath(path: JSONPath | undefined) {\n    if (!isEqual(queryOptions?.sort?.path, path)) {\n      debug('changeSortPath', path)\n      queryOptions = setIn(queryOptions, ['sort', 'path'], path, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeSortDirection(direction: string | undefined) {\n    if (!isEqual(queryOptions?.sort?.direction, direction)) {\n      debug('changeSortDirection', direction)\n      queryOptions = setIn(queryOptions, ['sort', 'direction'], direction, true)\n      onChange(queryOptions)\n    }\n  }\n\n  function changeProjectionPaths(paths: JSONPath[] | unknown) {\n    if (!isEqual(queryOptions?.projection?.paths, paths)) {\n      debug('changeProjectionPaths', paths)\n      queryOptions = setIn(queryOptions, ['projection', 'paths'], paths, true)\n      onChange(queryOptions)\n    }\n  }\n\n  $: changeFilterPath(filterPath?.value)\n  $: changeFilterRelation(filterRelation?.value)\n  $: changeFilterValue(filterValue)\n  $: changeSortPath(sortPath?.value)\n  $: changeSortDirection(sortDirection?.value)\n  $: changeProjectionPaths(projectionPaths ? projectionPaths.map((item) => item.value) : undefined)\n</script>\n\n<table class=\"jse-transform-wizard\">\n  <tbody>\n    <tr>\n      <th>Filter</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select\n            class=\"jse-filter-path\"\n            showChevron\n            items={fieldOptions}\n            bind:value={filterPath}\n          />\n          <Select\n            class=\"jse-filter-relation\"\n            showChevron\n            clearable={false}\n            items={filterRelationOptions}\n            bind:value={filterRelation}\n          />\n          <input class=\"jse-filter-value\" bind:value={filterValue} />\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th>Sort</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select class=\"jse-sort-path\" showChevron items={fieldOptions} bind:value={sortPath} />\n          <Select\n            class=\"jse-sort-direction\"\n            showChevron\n            clearable={false}\n            items={sortDirectionOptions}\n            bind:value={sortDirection}\n          />\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th>Pick</th>\n      <td>\n        <div class=\"jse-horizontal\">\n          <Select\n            class=\"jse-projection-paths\"\n            multiple\n            showChevron\n            items={projectionOptions}\n            bind:value={projectionPaths}\n          />\n        </div>\n      </td>\n    </tr>\n  </tbody>\n</table>\n\n<style src=\"./TransformWizard.scss\"></style>\n","<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faCheckSquare, faSquare } from '@fortawesome/free-regular-svg-icons'\n  import type { QueryLanguage, OnChangeQueryLanguage } from '$lib/types.js'\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n  }\n</script>\n\n<div class=\"jse-select-query-language\">\n  <div class=\"jse-select-query-language-container\">\n    {#each queryLanguages as queryLanguage}\n      <button\n        type=\"button\"\n        on:click={() => handleChangeQueryLanguage(queryLanguage.id)}\n        class=\"jse-query-language\"\n        class:selected={queryLanguage.id === queryLanguageId}\n        title={`Select ${queryLanguage.name} as query language`}\n      >\n        {#if queryLanguage.id === queryLanguageId}\n          <Icon data={faCheckSquare} />\n        {:else}\n          <Icon data={faSquare} />\n        {/if}\n        {queryLanguage.name}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./SelectQueryLanguage.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import {\n    faDownLeftAndUpRightToCenter,\n    faTimes,\n    faUpRightAndDownLeftFromCenter\n  } from '@fortawesome/free-solid-svg-icons'\n\n  export let title = 'Modal'\n  export let fullScreenButton: boolean = false\n  export let fullscreen: boolean = false\n  export let onClose: (() => void) | undefined = undefined\n</script>\n\n<div class=\"jse-header\">\n  <div class=\"jse-title\">\n    {title}\n  </div>\n  <slot name=\"actions\" />\n  {#if fullScreenButton}\n    <button\n      type=\"button\"\n      class=\"jse-fullscreen\"\n      title=\"Toggle full screen\"\n      on:click={() => (fullscreen = !fullscreen)}\n    >\n      <Icon data={fullscreen ? faDownLeftAndUpRightToCenter : faUpRightAndDownLeftFromCenter} />\n    </button>\n  {/if}\n  <button type=\"button\" class=\"jse-close\" on:click={() => onClose?.()}>\n    <Icon data={faTimes} />\n  </button>\n</div>\n\n<style src=\"./Header.scss\"></style>\n","import { createDebug } from '$lib/utils/debug.js'\nimport {\n  AUTO_SCROLL_INTERVAL,\n  AUTO_SCROLL_SPEED_FAST,\n  AUTO_SCROLL_SPEED_NORMAL,\n  AUTO_SCROLL_SPEED_SLOW\n} from '$lib/constants.js'\n\nconst debug = createDebug('jsoneditor:AutoScrollHandler')\n\nexport function createAutoScrollHandler(scrollableElement: Element) {\n  debug('createAutoScrollHandler', scrollableElement)\n\n  let autoScrollSpeed: number | undefined // pixels per second\n  let autoScrollTimer: number | undefined\n\n  function calculateSpeed(diff: number) {\n    return diff < 20\n      ? AUTO_SCROLL_SPEED_SLOW\n      : diff < 50\n        ? AUTO_SCROLL_SPEED_NORMAL\n        : AUTO_SCROLL_SPEED_FAST\n  }\n\n  function autoScrollCallback() {\n    if (scrollableElement) {\n      // debug('auto scroll...')\n      const diff = (autoScrollSpeed || 0) * (AUTO_SCROLL_INTERVAL / 1000)\n\n      scrollableElement.scrollTop += diff\n    }\n  }\n\n  function startAutoScroll(speed: number) {\n    if (!autoScrollTimer || speed !== autoScrollSpeed) {\n      stopAutoScroll()\n\n      debug('startAutoScroll', speed)\n      autoScrollSpeed = speed\n      autoScrollTimer = setInterval(autoScrollCallback, AUTO_SCROLL_INTERVAL) as unknown as number\n    }\n  }\n\n  function stopAutoScroll() {\n    if (autoScrollTimer) {\n      debug('stopAutoScroll')\n\n      clearInterval(autoScrollTimer)\n      autoScrollTimer = undefined\n      autoScrollSpeed = undefined\n    }\n  }\n\n  function onDrag(event: MouseEvent) {\n    if (scrollableElement) {\n      const y = event.clientY\n      const { top, bottom } = scrollableElement.getBoundingClientRect()\n\n      if (y < top) {\n        const speed = calculateSpeed(top - y)\n        startAutoScroll(-speed)\n      } else if (y > bottom) {\n        const speed = calculateSpeed(y - bottom)\n        startAutoScroll(speed)\n      } else {\n        stopAutoScroll()\n      }\n    }\n  }\n\n  function onDragEnd() {\n    stopAutoScroll()\n  }\n\n  return {\n    onDrag,\n    onDragEnd\n  }\n}\n","// Robert Penner's easeInOutQuad\n\n// find the rest of his easing functions here: http://robertpenner.com/easing/\n// find them exported for ES6 consumption here: https://github.com/jaxgeller/ez.js\n\nexport default (t: number, b: number, c: number, d: number): number => {\n  t /= d / 2\n  if (t < 1) {\n    return (c / 2) * t * t + b\n  }\n  t--\n  return (-c / 2) * (t * (t - 2) - 1) + b\n}\n","import easeInOutQuad from './easing.js'\n\ntype Easing = (t: number, b: number, c: number, d: number) => number\ntype Duration = number | ((distance: number) => number)\n\ninterface JumpOptions {\n  duration?: Duration\n  offset?: number\n  callback?: () => void\n  easing?: Easing\n  a11y?: boolean\n  container?: Element | string\n}\n\nexport const createJump = () => {\n  // private variable cache\n  // no variables are created during a jump, preventing memory leaks\n\n  let container: Element // container element to be scrolled       (node)\n  let element: Element | undefined // element to scroll to                   (node)\n\n  let start: number // where scroll starts                    (px)\n  let stop: number // where scroll stops                     (px)\n\n  let offset // adjustment from the stop position      (px)\n  let easing: Easing // easing function                        (function)\n  let a11y: boolean // accessibility support flag             (boolean)\n\n  let distance: number // distance of scroll                     (px)\n  let duration: number // scroll duration                        (ms)\n\n  let timeStart: number // time scroll started                    (ms)\n  let timeElapsed: number // time spent scrolling thus far          (ms)\n\n  let next: number // next scroll position                   (px)\n\n  let callback: (() => void) | undefined // to call when done scrolling            (function)\n\n  let scrolling: boolean // true whilst scrolling                  (boolean)\n\n  // scroll position helper\n\n  function location() {\n    return container.scrollTop\n  }\n\n  // element offset helper\n\n  function top(element: Element) {\n    const elementTop = element.getBoundingClientRect().top\n    const containerTop = container.getBoundingClientRect ? container.getBoundingClientRect().top : 0\n\n    return elementTop - containerTop + start\n  }\n\n  // scrollTo helper\n\n  function scrollTo(top: number) {\n    if (container.scrollTo) {\n      container.scrollTo(container.scrollLeft, top) // window\n    } else {\n      container.scrollTop = top // custom container\n    }\n  }\n\n  // rAF loop helper\n\n  function loop(timeCurrent: number) {\n    // store time scroll started, if not started already\n    if (!timeStart) {\n      timeStart = timeCurrent\n    }\n\n    // determine time spent scrolling so far\n    timeElapsed = timeCurrent - timeStart\n\n    // calculate next scroll position\n    next = easing(timeElapsed, start, distance, duration)\n\n    // scroll to it\n    scrollTo(next)\n\n    scrolling = true\n\n    // check progress\n    if (timeElapsed < duration) {\n      requestAnimationFrame(loop) // continue scroll loop\n    } else {\n      done() // scrolling is done\n    }\n  }\n\n  // scroll finished helper\n\n  function done() {\n    // account for rAF time rounding inaccuracies\n    scrollTo(start + distance)\n\n    // if scrolling to an element, and accessibility is enabled\n    if (element && a11y) {\n      // add tabindex indicating programmatic focus\n      element.setAttribute('tabindex', '-1')\n\n      // focus the element\n      const htmlElement = element as HTMLElement\n      htmlElement.focus()\n    }\n\n    // if it exists, fire the callback\n    if (typeof callback === 'function') {\n      callback()\n    }\n\n    // reset time for next jump\n    timeStart = 0\n\n    // we're done scrolling\n    scrolling = false\n  }\n\n  // API\n\n  function jump(target: Element | number | string, options: JumpOptions = {}) {\n    // resolve options, or use defaults\n    duration = 1000\n    offset = options.offset || 0\n    callback = options.callback // \"undefined\" is a suitable default, and won't be called\n    easing = options.easing || easeInOutQuad\n    a11y = options.a11y || false\n\n    // resolve container\n    switch (typeof options.container) {\n      case 'object':\n        // we assume container is an HTML element (Node)\n        container = options.container\n        break\n\n      case 'string':\n        container = document.querySelector(options.container) as Element\n        break\n\n      default:\n        container = window.document.documentElement\n    }\n\n    // cache starting position\n    start = location()\n\n    // resolve target\n    switch (typeof target) {\n      // scroll from current position\n      case 'number':\n        element = undefined // no element to scroll to\n        a11y = false // make sure accessibility is off\n        stop = start + target\n        break\n\n      // scroll to element (node)\n      // bounding rect is relative to the viewport\n      case 'object':\n        element = target\n        stop = top(element)\n        break\n\n      // scroll to element (selector)\n      // bounding rect is relative to the viewport\n      case 'string':\n        element = document.querySelector(target) as unknown as Element\n        stop = top(element)\n        break\n\n      default:\n    }\n\n    // resolve scroll distance, accounting for offset\n    distance = stop - start + offset\n\n    // resolve duration\n    switch (typeof options.duration) {\n      // number in ms\n      case 'number':\n        duration = options.duration\n        break\n\n      // function passed the distance of the scroll\n      case 'function':\n        duration = options.duration(distance)\n        break\n\n      default:\n    }\n\n    // start the loop if we're not already scrolling\n    if (!scrolling) {\n      requestAnimationFrame(loop)\n    } else {\n      // reset time for next jump\n      timeStart = 0\n    }\n  }\n\n  // expose only the jump method\n  return jump\n}\n\n// export singleton\n\nconst singleton = createJump()\n\nexport default singleton\n","/**\n * Measure how long a callback takes to execute.\n * Returns the response from the callback\n * The measured duration is returned via the onDuration callback\n */\nexport function measure<T>(callback: () => T, onDuration: (duration: number) => void): T {\n  const start = Date.now()\n  const result = callback()\n  const end = Date.now()\n\n  onDuration(end - start)\n\n  return result\n}\n","import { initial, isEmpty } from 'lodash-es'\nimport type {\n  ContentErrors,\n  JSONParser,\n  RecursiveStateFactory,\n  ValidationErrors,\n  ValidationError,\n  Validator\n} from '$lib/types.js'\nimport { ValidationSeverity } from '$lib/types.js'\nimport { MAX_AUTO_REPAIRABLE_SIZE, MAX_VALIDATABLE_SIZE } from '../constants.js'\nimport { measure } from '../utils/timeUtils.js'\nimport { normalizeJsonParseError } from '../utils/jsonUtils.js'\nimport { createDebug } from '../utils/debug.js'\nimport { jsonrepair } from 'jsonrepair'\nimport { updateInRecursiveState } from './documentState.js'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst debug = createDebug('validation')\n\nexport const validationErrorsFactory: RecursiveStateFactory = {\n  createObjectDocumentState: () => ({ type: 'object', properties: {} }),\n  createArrayDocumentState: () => ({ type: 'array', items: [] }),\n  createValueDocumentState: () => ({ type: 'value' })\n}\n\nexport function updateInValidationErrors(\n  json: unknown,\n  errors: ValidationErrors | undefined,\n  path: JSONPath,\n  transform: (value: unknown, state: ValidationErrors) => ValidationErrors\n): ValidationErrors {\n  return updateInRecursiveState(json, errors, path, transform, validationErrorsFactory)\n}\n\n/**\n * Create a flat map with validation errors, where the key is the stringified path\n * and also create error messages for the parent nodes of the nodes having an error.\n *\n * Returns a nested object containing the validation errors\n */\nexport function toRecursiveValidationErrors(\n  json: unknown,\n  validationErrors: ValidationError[]\n): ValidationErrors | undefined {\n  let output: ValidationErrors | undefined\n\n  // first generate the errors themselves\n  validationErrors.forEach((validationError) => {\n    output = updateInValidationErrors(json, output, validationError.path, (_, state) => ({\n      ...state,\n      validationError\n    }))\n  })\n\n  // create error entries for all parent nodes (displayed when the node is collapsed)\n  validationErrors.forEach((validationError) => {\n    let parentPath = validationError.path\n\n    while (parentPath.length > 0) {\n      parentPath = initial(parentPath)\n\n      output = updateInValidationErrors(json, output, parentPath, (_, state) => {\n        return state.validationError\n          ? state\n          : {\n              ...state,\n              validationError: {\n                isChildError: true,\n                path: parentPath,\n                message: 'Contains invalid data',\n                severity: ValidationSeverity.warning\n              }\n            }\n      })\n    }\n  })\n\n  return output\n}\n\nexport function validateJSON(\n  json: unknown,\n  validator: Validator | undefined,\n  parser: JSONParser,\n  validationParser: JSONParser\n): ValidationError[] {\n  debug('validateJSON')\n\n  if (!validator) {\n    return []\n  }\n\n  if (parser !== validationParser) {\n    // if needed, convert for example Lossless JSON to native JSON\n    // (like replace bigint or LosslessNumber into regular numbers)\n    const text = parser.stringify(json)\n    const convertedJSON = text !== undefined ? validationParser.parse(text) : undefined\n    return validator(convertedJSON)\n  } else {\n    return validator(json)\n  }\n}\n\nexport function validateText(\n  text: string,\n  validator: Validator | undefined,\n  parser: JSONParser,\n  validationParser: JSONParser\n): ContentErrors | undefined {\n  debug('validateText')\n\n  if (text.length > MAX_VALIDATABLE_SIZE) {\n    const validationError: ValidationError = {\n      path: [],\n      message: 'Validation turned off: the document is too large',\n      severity: ValidationSeverity.info\n    }\n\n    return {\n      validationErrors: [validationError]\n    }\n  }\n\n  if (text.length === 0) {\n    // new, empty document, do not try to parse\n    return undefined\n  }\n\n  try {\n    // parse with the \"main\" parser (not the validation parser) to get parse errors\n    // (like syntax errors and duplicate keys errors)\n    const json = measure(\n      () => parser.parse(text),\n      (duration) => debug(`validate: parsed json in ${duration} ms`)\n    )\n\n    if (!validator) {\n      return undefined\n    }\n\n    // if needed, parse with the validationParser to be able to feed the json to the validator\n    const convertedJSON =\n      parser === validationParser\n        ? json\n        : measure(\n            () => validationParser.parse(text),\n            (duration) => debug(`validate: parsed json with the validationParser in ${duration} ms`)\n          )\n\n    // actually validate the json\n    const validationErrors = measure(\n      () => validator(convertedJSON),\n      (duration) => debug(`validate: validated json in ${duration} ms`)\n    )\n\n    return !isEmpty(validationErrors) ? { validationErrors } : undefined\n  } catch (err) {\n    const isRepairable = measure(\n      () => canAutoRepair(text, parser),\n      (duration) => debug(`validate: checked whether repairable in ${duration} ms`)\n    )\n\n    const parseError = normalizeJsonParseError(\n      text,\n      (err as Error).message || (err as Error).toString()\n    )\n\n    return {\n      parseError,\n      isRepairable\n    }\n  }\n}\n\nfunction canAutoRepair(text: string, parser: JSONParser): boolean {\n  if (text.length > MAX_AUTO_REPAIRABLE_SIZE) {\n    return false\n  }\n\n  try {\n    parser.parse(jsonrepair(text))\n\n    return true\n  } catch {\n    return false\n  }\n}\n","import { createDebug } from '$lib/utils/debug.js'\n\nconst debug = createDebug('jsoneditor:FocusTracker')\n\nexport interface FocusTrackerProps {\n  onMount: (callback: () => void) => void\n  onDestroy: (callback: () => void) => void\n  getWindow: () => Window | undefined\n  hasFocus: () => boolean\n  onFocus: () => void\n  onBlur: () => void\n}\n\nexport function createFocusTracker({\n  onMount,\n  onDestroy,\n  getWindow,\n  hasFocus,\n  onFocus,\n  onBlur\n}: FocusTrackerProps) {\n  let blurTimeoutHandle: number | undefined\n  let focus = false\n\n  function handleFocusIn() {\n    const newFocus = hasFocus()\n\n    if (newFocus) {\n      clearTimeout(blurTimeoutHandle)\n      if (!focus) {\n        debug('focus')\n        onFocus()\n        focus = newFocus\n      }\n    }\n  }\n\n  function handleFocusOut() {\n    if (focus) {\n      // We set focus to false after timeout. Often, you get a blur and directly\n      // another focus when moving focus from one button to another.\n      // The focusIn handler will cancel any pending blur timer in those cases\n      clearTimeout(blurTimeoutHandle)\n      blurTimeoutHandle = setTimeout(() => {\n        if (!hasFocus()) {\n          debug('blur')\n          focus = false\n          onBlur()\n        }\n      }) as unknown as number\n    }\n  }\n\n  onMount(() => {\n    debug('mount FocusTracker')\n    const window = getWindow()\n    if (window) {\n      window.addEventListener('focusin', handleFocusIn, true)\n      window.addEventListener('focusout', handleFocusOut, true)\n    }\n  })\n\n  onDestroy(() => {\n    debug('destroy FocusTracker')\n    const window = getWindow()\n    if (window) {\n      window.removeEventListener('focusin', handleFocusIn, true)\n      window.removeEventListener('focusout', handleFocusOut, true)\n    }\n  })\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import type { MessageAction } from '$lib/types'\n  import type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\n  import { onDestroy } from 'svelte'\n\n  export let type: 'success' | 'error' | 'warning' | 'info' = 'success'\n  export let icon: IconDefinition | undefined = undefined\n  export let message: string | undefined = undefined\n  export let actions: MessageAction[] = []\n  export let onClick: (() => void) | undefined = undefined\n  export let onClose: (() => void) | undefined = undefined\n\n  if (onClose) {\n    onDestroy(onClose)\n  }\n\n  function handleClick() {\n    if (onClick) {\n      onClick()\n    }\n  }\n</script>\n\n<div class=\"jse-message jse-{type}\">\n  <!-- svelte-ignore a11y-click-events-have-key-events -->\n  <div\n    role=\"button\"\n    tabindex=\"-1\"\n    class=\"jse-text\"\n    class:jse-clickable={!!onClick}\n    on:click={handleClick}\n  >\n    <div class=\"jse-text-centered\">\n      {#if icon}\n        <Icon data={icon} />\n      {/if}\n      {message}\n    </div>\n  </div>\n  <div class=\"jse-actions\">\n    {#each actions as action}\n      <button\n        type=\"button\"\n        on:click={() => {\n          if (action.onClick) {\n            action.onClick()\n          }\n        }}\n        on:mousedown={() => {\n          if (action.onMouseDown) {\n            action.onMouseDown()\n          }\n        }}\n        class=\"jse-button jse-action jse-primary\"\n        title={action.title}\n        disabled={action.disabled}\n      >\n        {#if action.icon}\n          <Icon data={action.icon} />\n        {/if}\n        {action.text}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./Message.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faAngleDown,\n    faAngleRight,\n    faExclamationTriangle\n  } from '@fortawesome/free-solid-svg-icons'\n  import { isEmpty } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { ValidationSeverity, type ValidationError } from '$lib/types.js'\n  import { MAX_VALIDATION_ERRORS } from '$lib/constants.js'\n  import { limit } from '$lib/utils/arrayUtils.js'\n\n  export let validationErrors: ValidationError[]\n  export let selectError: (error: ValidationError) => void\n\n  $: count = validationErrors.length\n\n  let expanded = true\n\n  function collapse() {\n    expanded = false\n  }\n\n  function expand() {\n    expanded = true\n  }\n\n  function getMaxSeverity(errors: ValidationError[]): ValidationSeverity | undefined {\n    const severities = [\n      ValidationSeverity.error,\n      ValidationSeverity.warning,\n      ValidationSeverity.info\n    ]\n\n    return severities.find((severity) => errors.some((error) => error.severity === severity))\n  }\n</script>\n\n{#if !isEmpty(validationErrors)}\n  <div class=\"jse-validation-errors-overview\">\n    {#if expanded || count === 1}\n      <table class=\"jse-validation-errors-overview-expanded\">\n        <tbody>\n          {#each limit(validationErrors, MAX_VALIDATION_ERRORS) as validationError, index}\n            <tr\n              class=\"jse-validation-{validationError.severity}\"\n              tabindex=\"0\"\n              on:click={() => {\n                // trigger on the next tick to prevent the editor not getting focus\n                setTimeout(() => selectError(validationError))\n              }}\n            >\n              <td class=\"jse-validation-error-icon\">\n                <Icon data={faExclamationTriangle} />\n              </td>\n              <td class=\"jse-validation-error-path\">\n                {stringifyJSONPath(validationError.path)}\n              </td>\n              <td class=\"jse-validation-error-message\">\n                {validationError.message}\n              </td>\n              <td class=\"jse-validation-error-action\">\n                {#if index === 0 && validationErrors.length > 1}\n                  <button\n                    type=\"button\"\n                    class=\"jse-validation-errors-collapse\"\n                    on:click|stopPropagation={collapse}\n                    title=\"Collapse validation errors\"\n                  >\n                    <Icon data={faAngleDown} />\n                  </button>\n                {/if}\n              </td>\n            </tr>\n          {/each}\n\n          {#if count > MAX_VALIDATION_ERRORS}\n            <tr class=\"jse-validation-error\">\n              <td></td>\n              <td></td>\n              <td>(and {count - MAX_VALIDATION_ERRORS} more errors)</td>\n              <td></td>\n            </tr>\n          {/if}\n        </tbody>\n      </table>\n    {:else}\n      <table class=\"jse-validation-errors-overview-collapsed\">\n        <tbody>\n          <tr class=\"jse-validation-{getMaxSeverity(validationErrors)}\" on:click={expand}>\n            <td class=\"jse-validation-error-icon\">\n              <Icon data={faExclamationTriangle} />\n            </td>\n            <td class=\"jse-validation-error-count\">\n              {count} validation errors\n              <div class=\"jse-validation-errors-expand\">\n                <Icon data={faAngleRight} />\n              </div>\n            </td>\n          </tr>\n        </tbody>\n      </table>\n    {/if}\n  </div>\n{/if}\n\n<style src=\"./ValidationErrorsOverview.scss\"></style>\n","type Callback = () => void\n\n/**\n * The provided callback is invoked when the user presses Escape, and then stops propagation of the event.\n */\nexport function onEscape(element: HTMLElement | undefined, callback: Callback) {\n  if (!element) {\n    return undefined\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    if (event.key === 'Escape') {\n      event.preventDefault()\n      event.stopPropagation()\n      callback()\n    }\n  }\n\n  element.addEventListener('keydown', handleKeyDown)\n\n  return {\n    destroy() {\n      element.removeEventListener('keydown', handleKeyDown)\n    }\n  }\n}\n","<script lang=\"ts\">\n  // code based on: https://svelte.dev/examples/modal\n  import { onEscape } from '$lib/actions/onEscape.js'\n  import { onDestroy, onMount } from 'svelte'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let className: string | undefined = undefined\n  export let fullscreen = false\n  export let onClose: () => void\n\n  let dialog: HTMLDialogElement\n\n  onMount(() => dialog.showModal())\n  onDestroy(() => dialog.close())\n\n  function close() {\n    onClose()\n  }\n</script>\n\n<dialog\n  bind:this={dialog}\n  on:close={close}\n  on:pointerdown|self={close}\n  on:cancel|preventDefault\n  use:onEscape={close}\n  class={classnames('jse-modal', className)}\n  class:jse-fullscreen={fullscreen}\n>\n  <div class=\"jse-modal-inner\">\n    <slot />\n  </div>\n</dialog>\n\n<style lang=\"scss\">\n  @use '../../themes/defaults.scss';\n  @use '../../styles.scss';\n\n  dialog.jse-modal {\n    border-radius: styles.$border-radius;\n    font-size: defaults.$padding; // for some reason that I don't understand, the font-size of the dialog is used as margin around the dialog\n    border: none;\n    padding: 0;\n    display: flex;\n    min-width: 0;\n    margin: auto;\n    overflow: visible;\n    transition:\n      width 0.1s ease-in-out,\n      height 0.1s ease-in-out;\n\n    &.jse-sort-modal {\n      width: 400px;\n    }\n\n    &.jse-repair-modal {\n      width: 600px;\n      height: 500px;\n    }\n\n    &.jse-jsoneditor-modal {\n      width: 800px;\n      height: 600px;\n    }\n\n    &.jse-transform-modal {\n      width: 1200px;\n      height: 800px;\n    }\n\n    &.jse-fullscreen {\n      width: 100%;\n      height: 100%;\n    }\n\n    &::backdrop {\n      background: defaults.$modal-overlay-background;\n    }\n\n    &[open] {\n      animation: zoom 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);\n    }\n\n    &[open]::backdrop {\n      animation: fade 0.2s ease-out;\n    }\n\n    & .jse-modal-inner {\n      @include styles.jse-modal-style;\n    }\n\n    @keyframes zoom {\n      from {\n        transform: scale(0.95);\n      }\n      to {\n        transform: scale(1);\n      }\n    }\n\n    @keyframes fade {\n      from {\n        opacity: 0;\n      }\n      to {\n        opacity: 1;\n      }\n    }\n\n    // styling for the select box, svelte-select\n    // see docs: https://github.com/rob-balfre/svelte-select#css-custom-properties-variables\n    :global(.svelte-select) {\n      --border: #{defaults.$svelte-select-border};\n      --item-is-active-bg: #{defaults.$svelte-select-item-is-active-bg};\n      --border-radius: #{defaults.$svelte-select-border-radius};\n      --background: #{defaults.$svelte-select-background};\n      --padding: #{defaults.$svelte-select-padding};\n      --multi-select-padding: #{defaults.$svelte-select-multi-select-padding};\n      --font-size: #{defaults.$svelte-select-font-size};\n      --height: 36px;\n      --multi-item-height: 28px;\n      --multi-item-margin: 2px;\n      --multi-item-padding: 2px 8px;\n      --multi-item-border-radius: 6px;\n      --indicator-top: 8px;\n    }\n  }\n</style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isMacDevice } from '$lib/utils/navigatorUtils.js'\n  import Header from './Header.svelte'\n  import Modal from './Modal.svelte'\n\n  export let onClose: () => void\n\n  const ctrl = isMacDevice() ? '⌘' : 'Ctrl'\n</script>\n\n<Modal {onClose} className=\"jse-copy-paste\">\n  <Header title=\"Copying and pasting\" {onClose} />\n\n  <div class=\"jse-modal-contents\">\n    <div>Clipboard permission is disabled by your browser. You can use:</div>\n\n    <div class=\"jse-shortcuts\">\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+C\n        </div>\n        for copy\n      </div>\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+X\n        </div>\n        for cut\n      </div>\n      <div class=\"jse-shortcut\">\n        <div class=\"jse-key\">\n          {ctrl}+V\n        </div>\n        for paste\n      </div>\n    </div>\n\n    <div class=\"jse-actions\">\n      <button type=\"button\" class=\"jse-primary\" on:click={onClose}> Close </button>\n    </div>\n  </div>\n</Modal>\n\n<style src=\"./CopyPasteModal.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import type { MenuItem } from '$lib/types'\n  import { isMenuButton, isMenuSeparator, isMenuSpace } from '$lib/typeguards.js'\n\n  export let items: MenuItem[] = []\n\n  function unknownMenuItem(item: MenuItem): string {\n    console.error('Unknown type of menu item', item)\n    return '???'\n  }\n</script>\n\n<div class=\"jse-menu\">\n  <slot name=\"left\" />\n\n  {#each items as item}\n    {#if isMenuSeparator(item)}\n      <div class=\"jse-separator\"></div>\n    {:else if isMenuSpace(item)}\n      <div class=\"jse-space\"></div>\n    {:else if isMenuButton(item)}\n      <button\n        type=\"button\"\n        class=\"jse-button {item.className}\"\n        on:click={item.onClick}\n        title={item.title}\n        disabled={item.disabled || false}\n      >\n        {#if item.icon}\n          <Icon data={item.icon} />\n        {/if}\n        {#if item.text}\n          {item.text}\n        {/if}\n      </button>\n    {:else}\n      {unknownMenuItem(item)}\n    {/if}\n  {/each}\n\n  <slot name=\"right\" />\n</div>\n\n<style src=\"./Menu.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faArrowDown,\n    faCheck,\n    faExclamationTriangle,\n    faTimes,\n    faWrench\n  } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import Message from '../../controls/Message.svelte'\n  import { normalizeJsonParseError } from '$lib/utils/jsonUtils.js'\n  import Menu from '../../controls/Menu.svelte'\n  import type { MenuItem, ParseError } from '$lib/types.js'\n\n  export let text = ''\n  export let readOnly = false\n  export let onParse: (text: string) => void\n  export let onRepair: (text: string) => string\n  export let onChange: ((updatedText: string) => void) | undefined = undefined\n  export let onApply: (repairedText: string) => void\n  export let onCancel: () => void\n\n  const debug = createDebug('jsoneditor:JSONRepair')\n\n  let domTextArea: HTMLTextAreaElement\n\n  $: error = getErrorMessage(text)\n  $: repairable = isRepairable(text)\n\n  $: debug('error', error)\n\n  function getErrorMessage(jsonText: string): ParseError | undefined {\n    try {\n      onParse(jsonText)\n      return undefined\n    } catch (err) {\n      return normalizeJsonParseError(jsonText, (err as Error).message)\n    }\n  }\n\n  function isRepairable(jsonText: string) {\n    try {\n      onRepair(jsonText)\n      return true\n    } catch {\n      return false\n    }\n  }\n\n  function goToError() {\n    if (domTextArea && error) {\n      const position = error.position !== undefined ? error.position : 0\n      domTextArea.setSelectionRange(position, position)\n      domTextArea.focus()\n    }\n  }\n\n  function handleChange(event: Event & { currentTarget: EventTarget & HTMLTextAreaElement }) {\n    debug('handleChange')\n\n    const value = (event.target as HTMLTextAreaElement).value\n\n    if (text === value) {\n      return\n    }\n\n    text = value\n\n    if (onChange) {\n      onChange(text)\n    }\n  }\n\n  function handleApply() {\n    onApply(text)\n  }\n\n  function handleRepair() {\n    try {\n      // TODO: simpleJsonRepair should also partially apply fixes. Now it's all or nothing\n      text = onRepair(text)\n\n      if (onChange) {\n        onChange(text)\n      }\n    } catch {\n      // no need to do something with the error\n    }\n  }\n\n  let items: MenuItem[]\n  $: items = [\n    {\n      type: 'space'\n    },\n    {\n      type: 'button',\n      icon: faTimes,\n      title: 'Cancel repair',\n      className: 'jse-cancel',\n      onClick: onCancel\n    }\n  ]\n\n  $: gotoAction = {\n    icon: faArrowDown,\n    text: 'Show me',\n    title: 'Scroll to the error location',\n    onClick: goToError\n  }\n\n  $: repairAction = {\n    icon: faWrench,\n    text: 'Auto repair',\n    title: 'Automatically repair JSON',\n    onClick: handleRepair\n  }\n\n  $: errorActions = repairable ? [gotoAction, repairAction] : [gotoAction]\n\n  $: successActions = [\n    {\n      icon: faCheck,\n      text: 'Apply',\n      title: 'Apply fixed JSON',\n      disabled: readOnly,\n      onClick: handleApply\n    }\n  ]\n</script>\n\n<div class=\"jse-json-repair-component\">\n  <Menu {items}>\n    <div slot=\"left\" class=\"jse-info\">Repair invalid JSON, then click apply</div>\n  </Menu>\n\n  {#if error}\n    <Message\n      type=\"error\"\n      icon={faExclamationTriangle}\n      message={`Cannot parse JSON: ${error.message}`}\n      actions={errorActions}\n    />\n  {:else}\n    <Message\n      type=\"success\"\n      message=\"JSON is valid now and can be parsed.\"\n      actions={successActions}\n    />\n  {/if}\n  <textarea\n    bind:this={domTextArea}\n    on:input={handleChange}\n    readonly={readOnly}\n    class=\"jse-json-text\"\n    autocomplete=\"off\"\n    autocapitalize=\"off\"\n    spellcheck=\"false\">{text}</textarea\n  >\n</div>\n\n<style src=\"./JSONRepairComponent.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import JSONRepairComponent from './repair/JSONRepairComponent.svelte'\n  import Modal from './Modal.svelte'\n\n  export let text: string\n  export let onParse: (text: string) => void\n  export let onRepair: (text: string) => string\n  export let onApply: (repairedText: string) => void\n  export let onClose: () => void\n\n  function handleApply(repairedText: string) {\n    onApply(repairedText)\n    onClose()\n  }\n\n  function handleCancel() {\n    onClose()\n  }\n</script>\n\n<Modal {onClose} className=\"jse-repair-modal\">\n  <JSONRepairComponent\n    bind:text\n    {onParse}\n    {onRepair}\n    onApply={handleApply}\n    onCancel={handleCancel}\n  />\n</Modal>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getExpandItemsSections } from '$lib/logic/expandItemsSections.js'\n  import type { JSONSelection, Section, VisibleSection, JSONEditorContext } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { pathInSelection } from '$lib/logic/selection.js'\n\n  export let visibleSections: VisibleSection[]\n  export let sectionIndex: number\n  export let total: number\n  export let path: JSONPath\n  export let selection: JSONSelection | undefined\n  export let onExpandSection: (path: JSONPath, section: Section) => void\n  export let context: JSONEditorContext\n\n  $: visibleSection = visibleSections[sectionIndex]\n\n  $: startIndex = visibleSection.end\n  $: endIndex = visibleSections[sectionIndex + 1] ? visibleSections[sectionIndex + 1].start : total\n\n  $: selected = pathInSelection(context.getJson(), selection, path.concat(String(startIndex)))\n\n  $: expandItemsSections = getExpandItemsSections(startIndex, endIndex)\n\n  function handleMouseMove(event: MouseEvent) {\n    // prevent the whole array from being selected whilst dragging over\n    // a section with collapsed items\n    event.stopPropagation()\n  }\n</script>\n\n<div\n  role=\"none\"\n  class=\"jse-collapsed-items\"\n  class:jse-selected={selected}\n  on:mousemove={handleMouseMove}\n  style:--level={path.length + 2}\n>\n  <div>\n    <div class=\"jse-text\">Items {startIndex}-{endIndex}</div>\n    {#each expandItemsSections as expandItemsSection}<button\n        type=\"button\"\n        class=\"jse-expand-items\"\n        on:click={() => onExpandSection(path, expandItemsSection)}\n      >\n        show {expandItemsSection.start}-{expandItemsSection.end}\n      </button>\n    {/each}\n  </div>\n</div>\n\n<style src=\"./CollapsedItems.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCaretDown } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import {\n    CONTEXT_MENU_EXPLANATION,\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH\n  } from '$lib/constants.js'\n  import type { OnContextMenu } from '$lib/types'\n\n  export let root: boolean = false\n  export let insert: boolean = false\n  export let selected: boolean\n  export let onContextMenu: OnContextMenu\n\n  function handleClick(event: MouseEvent & { currentTarget: EventTarget & HTMLButtonElement }) {\n    let buttonElem: Element | undefined = event.target as HTMLButtonElement\n    while (buttonElem && buttonElem.nodeName !== 'BUTTON') {\n      buttonElem = buttonElem.parentNode as Element\n    }\n\n    if (buttonElem) {\n      onContextMenu({\n        anchor: buttonElem,\n        left: 0,\n        top: 0,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        offsetTop: 2,\n        offsetLeft: 0,\n        showTip: true\n      })\n    }\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-context-menu-pointer\"\n  class:jse-root={root}\n  class:jse-insert={insert}\n  class:jse-selected={selected}\n  title={CONTEXT_MENU_EXPLANATION}\n  on:click={handleClick}\n>\n  <Icon data={faCaretDown} />\n</button>\n\n<style src=\"./ContextMenuPointer.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONEditorContext, JSONSelection, SearchResultItem } from '$lib/types.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { isEditingSelection, isValueSelection } from '$lib/logic/selection.js'\n  import { isSvelteActionRenderer } from '$lib/typeguards.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let context: JSONEditorContext\n  export let enforceString: boolean\n  export let selection: JSONSelection | undefined\n  export let searchResultItems: SearchResultItem[] | undefined\n\n  $: isEditing = isValueSelection(selection) && isEditingSelection(selection)\n\n  $: renderers = context.onRenderValue({\n    path,\n    value,\n    mode: context.mode,\n    readOnly: context.readOnly,\n    enforceString,\n    isEditing,\n    parser: context.parser,\n    normalization: context.normalization,\n    selection,\n    searchResultItems,\n    onPatch: context.onPatch,\n    onPasteJson: context.onPasteJson,\n    onSelect: context.onSelect,\n    onFind: context.onFind,\n    findNextInside: context.findNextInside,\n    focus: context.focus\n  })\n</script>\n\n{#each renderers as renderer}\n  {#if isSvelteActionRenderer(renderer)}\n    {@const action = renderer.action}\n    <div\n      role=\"button\"\n      tabindex=\"-1\"\n      class=\"jse-value\"\n      data-type=\"selectable-value\"\n      use:action={renderer.props}\n    ></div>\n  {:else}\n    <svelte:component this={renderer.component} {...renderer.props} />\n  {/if}\n{/each}\n","// used by JSONNode during dragging\nimport type { JSONPath } from 'immutable-json-patch'\n\nexport const singleton: Singleton = {\n  selecting: false,\n  selectionAnchor: undefined, // Path\n  selectionAnchorType: undefined, // Selection type\n  selectionFocus: undefined, // Path\n\n  dragging: false\n}\n\ninterface Singleton {\n  selecting: boolean\n  selectionAnchor: JSONPath | undefined\n  selectionAnchorType: string | undefined\n  selectionFocus: JSONPath | undefined\n\n  dragging: boolean\n}\n","import { createMultiSelection, getEndPath, getStartPath } from './selection.js'\nimport { initial, isEqual } from 'lodash-es'\nimport type { JSONPatchDocument } from 'immutable-json-patch'\nimport { getIn } from 'immutable-json-patch'\nimport { moveInsideParent } from './operations.js'\nimport type {\n  DragInsideAction,\n  DragInsideProps,\n  JSONSelection,\n  MultiSelection,\n  RenderedItem\n} from '$lib/types'\n\nexport interface MoveSelectionProps {\n  json: unknown\n  selection: JSONSelection | undefined\n  deltaY: number\n  items: RenderedItem[]\n}\n\nexport interface MoveSelectionResult {\n  operations: JSONPatchDocument | undefined\n  updatedSelection: JSONSelection | undefined\n  offset: number\n}\n\nexport function onMoveSelection({\n  json,\n  selection,\n  deltaY,\n  items\n}: MoveSelectionProps): MoveSelectionResult {\n  if (!selection) {\n    return {\n      operations: undefined,\n      updatedSelection: undefined,\n      offset: 0\n    }\n  }\n\n  const dragInsideAction =\n    deltaY < 0\n      ? findSwapPathUp({ json, selection, deltaY, items })\n      : findSwapPathDown({ json, selection, deltaY, items })\n\n  if (!dragInsideAction || dragInsideAction.offset === 0) {\n    return {\n      operations: undefined,\n      updatedSelection: undefined,\n      offset: 0\n    }\n  }\n\n  const operations = moveInsideParent(json, selection, dragInsideAction)\n\n  const path = initial(getStartPath(json, selection))\n  const value = getIn(json, path)\n  if (Array.isArray(value)) {\n    const updatedSelection = createUpdatedArraySelection({\n      items,\n      json,\n      selection,\n      offset: dragInsideAction.offset\n    })\n\n    return {\n      operations,\n      updatedSelection,\n      offset: dragInsideAction.offset\n    }\n  } else {\n    // object\n    return {\n      operations,\n      updatedSelection: undefined,\n      offset: dragInsideAction.offset\n    }\n  }\n}\n\nfunction findSwapPathUp({\n  json,\n  items,\n  selection,\n  deltaY\n}: DragInsideProps): DragInsideAction | undefined {\n  const initialPath = getStartPath(json, selection)\n  const initialIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n\n  const prevHeight = () => items[index - 1]?.height\n\n  let index = initialIndex\n  let cumulativeHeight = 0\n\n  while (prevHeight() !== undefined && Math.abs(deltaY) > cumulativeHeight + prevHeight() / 2) {\n    cumulativeHeight += prevHeight()\n    index -= 1\n  }\n\n  const beforePath = items[index].path\n  const offset = index - initialIndex\n\n  return index !== initialIndex && items[index] !== undefined ? { beforePath, offset } : undefined\n}\n\nfunction findSwapPathDown({\n  json,\n  items,\n  selection,\n  deltaY\n}: DragInsideProps): DragInsideAction | undefined {\n  const initialPath = getEndPath(json, selection)\n  const initialIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n\n  let cumulativeHeight = 0\n  let index = initialIndex\n\n  const nextHeight = () => items[index + 1]?.height\n\n  while (nextHeight() !== undefined && Math.abs(deltaY) > cumulativeHeight + nextHeight() / 2) {\n    cumulativeHeight += nextHeight()\n    index += 1\n  }\n\n  const parentPath = initial(initialPath)\n  const parent = getIn(json, parentPath)\n  const isArray = Array.isArray(parent)\n  const beforeIndex = isArray ? index : index + 1\n  const beforePath = items[beforeIndex]?.path\n  const offset = index - initialIndex\n\n  return beforePath ? { beforePath, offset } : { append: true, offset }\n}\n\ninterface UpdatedArraySelectionProps {\n  items: RenderedItem[]\n  json: unknown\n  selection: JSONSelection\n  offset: number\n}\n\nfunction createUpdatedArraySelection({\n  items,\n  json,\n  selection,\n  offset\n}: UpdatedArraySelectionProps): MultiSelection {\n  const startPath = getStartPath(json, selection)\n  const endPath = getEndPath(json, selection)\n\n  const startIndex = items.findIndex((item) => isEqual(item.path, startPath))\n  const endIndex = items.findIndex((item) => isEqual(item.path, endPath))\n\n  const anchorPath = items[startIndex + offset]?.path\n  const focusPath = items[endIndex + offset]?.path\n\n  return createMultiSelection(anchorPath, focusPath)\n}\n","<script lang=\"ts\">\n  import { faExclamationTriangle } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import { getContext } from 'svelte'\n  import { tooltip } from '../../controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext, NestedValidationError, ValidationError } from '$lib/types.js'\n  import { isNestedValidationError } from '$lib/typeguards.js'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let validationError: NestedValidationError | ValidationError\n  export let onExpand: (event: MouseEvent) => void\n\n  $: text =\n    isNestedValidationError(validationError) && validationError.isChildError\n      ? 'Contains invalid data'\n      : validationError.message\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-validation-{validationError.severity}\"\n  on:click={onExpand}\n  use:tooltip={{ text, ...absolutePopupContext }}\n>\n  <Icon data={faExclamationTriangle} />\n</button>\n\n<style src=\"./ValidationErrorIcon.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\n  import type { JSONPath, JSONPointer } from 'immutable-json-patch'\n  import { appendToJSONPointer, parseJSONPointer } from 'immutable-json-patch'\n  import { initial, isEqual, last, range } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import {\n    DEFAULT_VISIBLE_SECTIONS,\n    HOVER_COLLECTION,\n    HOVER_INSERT_AFTER,\n    HOVER_INSERT_INSIDE,\n    INSERT_EXPLANATION\n  } from '$lib/constants.js'\n  import { getEnforceString, getVisibleCaretPositions } from '$lib/logic/documentState.js'\n  import { rename } from '$lib/logic/operations.js'\n  import {\n    createAfterSelection,\n    createInsideSelection,\n    createMultiSelection,\n    fromCaretPosition,\n    fromSelectionType,\n    getAnchorPath,\n    getEndPath,\n    getFocusPath,\n    getSelectionPaths,\n    getStartPath,\n    isAfterSelection,\n    isEditingSelection,\n    isInsideSelection,\n    isKeySelection,\n    isMultiSelection,\n    isValueSelection,\n    pathInSelection,\n    selectionIfOverlapping\n  } from '$lib/logic/selection.js'\n  import {\n    getDataPathFromTarget,\n    getSelectionTypeFromTarget,\n    isChildOfAttribute,\n    isChildOfNodeName,\n    isContentEditableDiv\n  } from '$lib/utils/domUtils.js'\n  import CollapsedItems from './CollapsedItems.svelte'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n  import JSONKey from './JSONKey.svelte'\n  import JSONValue from './JSONValue.svelte'\n  import { singleton } from './singleton.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { onMoveSelection } from '$lib/logic/dragging.js'\n  import { forEachIndex, moveItems } from '$lib/utils/arrayUtils.js'\n  import type {\n    AbsolutePopupOptions,\n    CaretPosition,\n    DocumentState,\n    DraggingState,\n    JSONSelection,\n    NestedValidationError,\n    SearchResults,\n    ValidationErrors,\n    RenderedItem,\n    TreeModeContext,\n    VisibleSection\n  } from '$lib/types'\n  import { SelectionType } from '$lib/types.js'\n  import {\n    isArrayRecursiveState,\n    isExpandableState,\n    isObjectRecursiveState\n  } from '$lib/typeguards.js'\n  import { filterKeySearchResults, filterValueSearchResults } from '$lib/logic/search.js'\n  import ValidationErrorIcon from './ValidationErrorIcon.svelte'\n  import { isObject } from '$lib/utils/typeUtils.js'\n  import { classnames } from '$lib/utils/cssUtils.js'\n  import { isCtrlKeyDown } from 'svelte-jsoneditor/utils/keyBindings'\n\n  // We pass `pointer` instead of `path` because pointer (a string) is immutable.\n  // Without it, *all* nodes would re-render on *every* change in JSON or DocumentState,\n  // because the path changes every time by re-creating it.\n  export let pointer: JSONPointer\n  export let value: unknown\n  export let state: DocumentState | undefined\n  export let validationErrors: ValidationErrors | undefined\n  export let searchResults: SearchResults | undefined\n  export let selection: JSONSelection | undefined\n  export let context: TreeModeContext\n  export let onDragSelectionStart: (\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) => void\n\n  const debug = createDebug('jsoneditor:JSONNode')\n\n  let hover: string | undefined = undefined\n  let hoverTimer: number | undefined = undefined\n  let dragging: DraggingState | undefined = undefined\n\n  let path: JSONPath\n  $: path = parseJSONPointer(pointer)\n  $: dataPath = encodeURIComponent(pointer) // This is the same as encodeDataPath(path) but faster\n\n  let expanded: boolean\n  $: expanded = isExpandableState(state) ? state.expanded : false\n\n  let enforceString: boolean\n  $: enforceString = getEnforceString(value, state, [])\n\n  let visibleSections: VisibleSection[] | undefined\n  $: visibleSections = isArrayRecursiveState(state) ? state.visibleSections : undefined\n\n  let validationError: NestedValidationError | undefined\n  $: validationError = validationErrors?.validationError\n\n  let isNodeSelected: boolean\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: isNodeSelected = pathInSelection(context.getJson(), selection, path)\n\n  $: root = path.length === 0\n\n  /**\n   * Get sorted keys, applying dragging order\n   */\n  function getKeys(object: Record<string, unknown>, dragging: DraggingState | undefined): string[] {\n    const keys = Object.keys(object)\n\n    // reorder the keys whilst dragging\n    if (dragging && dragging.offset !== 0) {\n      return moveItems(\n        keys,\n        dragging.selectionStartIndex,\n        dragging.selectionItemsCount,\n        dragging.offset\n      )\n    }\n\n    return keys\n  }\n\n  interface ItemIndex {\n    index: number\n    gutterIndex: number\n  }\n\n  function getItems(\n    array: Array<unknown>,\n    visibleSection: VisibleSection,\n    dragging: DraggingState | undefined\n  ): ItemIndex[] {\n    const start = visibleSection.start\n    const end = Math.min(visibleSection.end, array.length)\n    const indices = range(start, end)\n\n    // reorder the items whilst dragging\n    if (dragging && dragging.offset !== 0) {\n      return moveItems(\n        indices,\n        dragging.selectionStartIndex,\n        dragging.selectionItemsCount,\n        dragging.offset\n      ).map((index, gutterIndex) => ({ index, gutterIndex }))\n    }\n\n    return indices.map((index) => ({ index, gutterIndex: index }))\n  }\n\n  function toggleExpand(event: MouseEvent) {\n    event.stopPropagation()\n\n    const recursive = isCtrlKeyDown(event)\n    context.onExpand(path, !expanded, recursive)\n  }\n\n  function handleExpand(event: MouseEvent) {\n    event.stopPropagation()\n\n    context.onExpand(path, true)\n  }\n\n  function handleUpdateKey(oldKey: string, newKey: string): string {\n    const operations = rename(path, Object.keys(value as Record<string, unknown>), oldKey, newKey)\n    context.onPatch(operations)\n\n    // It is possible that the applied key differs from newKey,\n    // to prevent duplicate keys. Here we figure out the actually applied key\n    return last(parseJSONPointer(operations[0].path)) as string\n  }\n\n  function handleMouseDown(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    // only handle when the left or right mouse button is pressed, not the middle mouse button (scroll wheel)\n    if (event.buttons !== 1 && event.buttons !== 2) {\n      return\n    }\n\n    // check if the mouse down is not happening in the key or value input fields or on a button\n    if (\n      isContentEditableDiv(event.target as HTMLElement) ||\n      (event.buttons === 1 && isChildOfNodeName(event.target as Element, 'BUTTON')) // left mouse on a button\n    ) {\n      return\n    }\n\n    event.stopPropagation()\n    event.preventDefault()\n\n    // due to event.stopPropagation here and there, the focus tracker does not receive this mouse event.\n    // make sure the editor has focus\n    context.focus()\n\n    // we attach the mousemove and mouseup event listeners to the global document,\n    // so we will not miss if the mouse events happen outside the editor\n    document.addEventListener('mousemove', handleMouseMoveGlobal, true)\n    document.addEventListener('mouseup', handleMouseUpGlobal)\n\n    const anchorType = getSelectionTypeFromTarget(event.target as Element)\n    const json = context.getJson()\n    const documentState = context.getDocumentState()\n\n    if (\n      selection &&\n      anchorType !== SelectionType.after &&\n      anchorType !== SelectionType.inside &&\n      (selection.type === anchorType || selection.type === SelectionType.multi) &&\n      pathInSelection(json, selection, path)\n    ) {\n      // when right-clicking inside the current selection, do nothing: context menu will open\n      // when left-clicking inside the current selection, do nothing: it can be the start of dragging\n      if (event.button === 0) {\n        onDragSelectionStart(event)\n      }\n\n      return\n    }\n\n    // TODO: refactor dragging, there are now two separate mechanisms handling mouse movement: with dragging.* and with singleton.*\n    singleton.selecting = true\n    singleton.selectionAnchor = path\n    singleton.selectionAnchorType = anchorType\n    singleton.selectionFocus = path\n\n    if (event.shiftKey) {\n      // Shift+Click will select multiple entries\n      const fullSelection = context.getSelection()\n      if (fullSelection) {\n        context.onSelect(createMultiSelection(getAnchorPath(fullSelection), path))\n      }\n    } else {\n      if (anchorType === SelectionType.multi) {\n        if (root && (event.target as Element).hasAttribute('data-path')) {\n          const lastCaretPosition = last(\n            getVisibleCaretPositions(value, documentState)\n          ) as CaretPosition\n          context.onSelect(fromCaretPosition(lastCaretPosition))\n        } else {\n          context.onSelect(createMultiSelection(path, path))\n        }\n      } else if (json !== undefined) {\n        context.onSelect(fromSelectionType(anchorType, path))\n      }\n    }\n  }\n\n  function handleMouseMove(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    if (singleton.selecting) {\n      event.preventDefault()\n      event.stopPropagation()\n\n      if (singleton.selectionFocus === undefined) {\n        // First move event, no selection yet.\n        // Clear the default selection of the browser\n        if (window.getSelection) {\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          window.getSelection().empty()\n        }\n      }\n\n      const selectionType = getSelectionTypeFromTarget(event.target as Element)\n\n      if (\n        !isEqual(path, singleton.selectionFocus) ||\n        selectionType !== singleton.selectionAnchorType\n      ) {\n        singleton.selectionFocus = path\n        singleton.selectionAnchorType = selectionType // TODO: this is a bit ugly\n\n        context.onSelect(\n          createMultiSelection(\n            singleton.selectionAnchor || singleton.selectionFocus,\n            singleton.selectionFocus\n          )\n        )\n      }\n    }\n  }\n\n  function handleMouseMoveGlobal(event: MouseEvent) {\n    context.onDrag(event)\n  }\n\n  function handleMouseUpGlobal(event: Event) {\n    if (singleton.selecting) {\n      singleton.selecting = false\n\n      event.stopPropagation()\n    }\n\n    context.onDragEnd()\n\n    document.removeEventListener('mousemove', handleMouseMoveGlobal, true)\n    document.removeEventListener('mouseup', handleMouseUpGlobal)\n  }\n\n  function findContentTop() {\n    return context.findElement([])?.getBoundingClientRect()?.top || 0\n  }\n\n  function calculateDeltaY(dragging: DraggingState, event: MouseEvent) {\n    // calculate the contentOffset, this changes when scrolling\n    const contentTop = findContentTop()\n    const contentOffset = contentTop - dragging.initialContentTop\n\n    // calculate the vertical mouse movement\n    const clientOffset = event.clientY - dragging.initialClientY\n\n    return clientOffset - contentOffset\n  }\n\n  function handleDragSelectionStart(\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) {\n    if (context.readOnly || !selection) {\n      return\n    }\n\n    const selectionParentPath = initial(getFocusPath(selection))\n    if (!isEqual(path, selectionParentPath)) {\n      // pass to parent\n      onDragSelectionStart(event)\n\n      return\n    }\n\n    // note that the returned items will be of one section only,\n    // and when the selection is spread over multiple sections,\n    // no items will be returned: this is not (yet) supported\n    const items = getVisibleItemsWithHeights(selection, visibleSections || DEFAULT_VISIBLE_SECTIONS)\n\n    debug('dragSelectionStart', { selection, items })\n\n    if (!items) {\n      debug('Cannot drag the current selection (probably spread over multiple sections)')\n      return\n    }\n\n    const json = context.getJson()\n    if (json === undefined) {\n      return\n    }\n    const initialPath = getStartPath(json, selection)\n    const selectionStartIndex = items.findIndex((item) => isEqual(item.path, initialPath))\n    const { offset } = onMoveSelection({\n      json,\n      selection: context.getSelection(),\n      deltaY: 0,\n      items\n    })\n\n    dragging = {\n      initialTarget: event.target as Element,\n      initialClientY: event.clientY,\n      initialContentTop: findContentTop(),\n      selectionStartIndex,\n      selectionItemsCount: getSelectionPaths(json, selection).length,\n      items,\n      offset,\n      didMoveItems: false // whether items have been moved during dragging or not\n    }\n    singleton.dragging = true\n\n    document.addEventListener('mousemove', handleDragSelection, true)\n    document.addEventListener('mouseup', handleDragSelectionEnd)\n  }\n\n  function handleDragSelection(event: MouseEvent) {\n    if (dragging) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return\n      }\n\n      const deltaY = calculateDeltaY(dragging, event)\n      const { offset } = onMoveSelection({\n        json,\n        selection: context.getSelection(),\n        deltaY,\n        items: dragging.items\n      })\n\n      if (offset !== dragging.offset) {\n        debug('drag selection', offset, deltaY)\n\n        dragging = {\n          ...dragging,\n          offset,\n          didMoveItems: true\n        }\n      }\n    }\n  }\n\n  function handleDragSelectionEnd(event: MouseEvent) {\n    if (dragging) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return\n      }\n      const deltaY = calculateDeltaY(dragging, event)\n      const { operations, updatedSelection } = onMoveSelection({\n        json,\n        selection: context.getSelection(),\n        deltaY,\n        items: dragging.items\n      })\n\n      if (operations) {\n        context.onPatch(operations, (_, patchedState) => ({\n          state: patchedState,\n          selection: updatedSelection ?? selection\n        }))\n      } else {\n        // the user did click inside the selection and no contents have been dragged,\n        // select the clicked item\n        if (event.target === dragging.initialTarget && !dragging.didMoveItems) {\n          const selectionType = getSelectionTypeFromTarget(event.target as Element)\n          const path = getDataPathFromTarget(event.target as Element)\n          if (path) {\n            context.onSelect(fromSelectionType(selectionType, path))\n          }\n        }\n      }\n\n      dragging = undefined\n      singleton.dragging = false\n\n      document.removeEventListener('mousemove', handleDragSelection, true)\n      document.removeEventListener('mouseup', handleDragSelectionEnd)\n    }\n  }\n\n  /**\n   * Get a list with all visible items and their rendered heights inside\n   * this object or array\n   */\n  // TODO: extract and unit test getVisibleItemsWithHeights\n  function getVisibleItemsWithHeights(\n    selection: JSONSelection,\n    visibleSections: VisibleSection[]\n  ): RenderedItem[] | undefined {\n    const items: RenderedItem[] = []\n\n    function addHeight(prop: string) {\n      const itemPath = path.concat(prop)\n      const element = context.findElement(itemPath)\n      if (element !== undefined) {\n        items.push({\n          path: itemPath,\n          height: element.clientHeight\n        })\n      }\n    }\n\n    if (Array.isArray(value)) {\n      const json = context.getJson()\n      if (json === undefined) {\n        return undefined\n      }\n      const startPath = getStartPath(json, selection)\n      const endPath = getEndPath(json, selection)\n      const startIndex = parseInt(last(startPath) as string, 10)\n      const endIndex = parseInt(last(endPath) as string, 10)\n\n      // find the section where the selection is\n      // if the selection is spread over multiple visible sections,\n      // we will not return any items, so dragging will not work there.\n      // We do this to keep things simple for now.\n      const currentSection = visibleSections.find((visibleSection) => {\n        return startIndex >= visibleSection.start && endIndex <= visibleSection.end\n      })\n\n      if (!currentSection) {\n        return undefined\n      }\n\n      const { start, end } = currentSection\n      forEachIndex(start, Math.min(value.length, end), (index) => addHeight(String(index)))\n    } else {\n      // value is Object\n      Object.keys(value as Record<string, unknown>).forEach(addHeight)\n    }\n\n    return items\n  }\n\n  function handleMouseOver(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    if (singleton.selecting || singleton.dragging) {\n      return\n    }\n\n    event.stopPropagation()\n\n    if (isChildOfAttribute(event.target as Element, 'data-type', 'selectable-value')) {\n      hover = HOVER_COLLECTION\n    } else if (isChildOfAttribute(event.target as Element, 'data-type', 'selectable-key')) {\n      hover = undefined\n    } else if (\n      isChildOfAttribute(event.target as Element, 'data-type', 'insert-selection-area-inside')\n    ) {\n      hover = HOVER_INSERT_INSIDE\n    } else if (\n      isChildOfAttribute(event.target as Element, 'data-type', 'insert-selection-area-after')\n    ) {\n      hover = HOVER_INSERT_AFTER\n    }\n\n    clearTimeout(hoverTimer)\n  }\n\n  function handleMouseOut(event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    event.stopPropagation()\n\n    // to prevent \"flickering\" in the hovering state when hovering on the edge\n    // of the insert area context menu button: it's visibility toggles when\n    // `hover` toggles, which will alternating mouseout and mouseover events\n    hoverTimer = window.setTimeout(() => (hover = undefined))\n  }\n\n  function handleInsertInside(event: MouseEvent) {\n    if (!event.shiftKey) {\n      event.stopPropagation()\n      event.preventDefault()\n\n      context.onSelect(createInsideSelection(path))\n    }\n  }\n\n  function handleInsertAfter(event: MouseEvent) {\n    if (!event.shiftKey) {\n      event.stopPropagation()\n      event.preventDefault()\n\n      context.onSelect(createAfterSelection(path))\n    }\n  }\n\n  function handleInsertInsideOpenContextMenu(contextMenuProps: AbsolutePopupOptions) {\n    context.onSelect(createInsideSelection(path))\n    context.onContextMenu(contextMenuProps)\n  }\n\n  function handleInsertAfterOpenContextMenu(contextMenuProps: AbsolutePopupOptions) {\n    context.onSelect(createAfterSelection(path))\n    context.onContextMenu(contextMenuProps)\n  }\n</script>\n\n<!-- svelte-ignore a11y-mouse-events-have-key-events -->\n<div\n  role=\"treeitem\"\n  tabindex=\"-1\"\n  class={classnames(\n    'jse-json-node',\n    { 'jse-expanded': expanded },\n    context.onClassName(path, value)\n  )}\n  data-path={dataPath}\n  aria-selected={isNodeSelected}\n  style:--level={path.length}\n  class:jse-root={root}\n  class:jse-selected={isNodeSelected && isMultiSelection(selection)}\n  class:jse-selected-value={isNodeSelected && isValueSelection(selection)}\n  class:jse-readonly={context.readOnly}\n  class:jse-hovered={hover === HOVER_COLLECTION}\n  on:mousedown={handleMouseDown}\n  on:mousemove={handleMouseMove}\n  on:mouseover={handleMouseOver}\n  on:mouseout={handleMouseOut}\n>\n  {#if Array.isArray(value)}\n    <div class=\"jse-header-outer\">\n      <div class=\"jse-header\">\n        <button\n          type=\"button\"\n          class=\"jse-expand\"\n          on:click={toggleExpand}\n          title=\"Expand or collapse this array (Ctrl+Click to expand/collapse recursively)\"\n        >\n          {#if expanded}\n            <Icon data={faCaretDown} />\n          {:else}\n            <Icon data={faCaretRight} />\n          {/if}\n        </button>\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-meta\">\n          <div class=\"jse-meta-inner\" data-type=\"selectable-value\">\n            {#if expanded}\n              <div class=\"jse-bracket\">[</div>\n              <span class=\"jse-tag jse-expanded\">\n                {value.length}\n                {value.length === 1 ? 'item' : 'items'}\n              </span>\n              &nbsp;\n            {:else}\n              <div class=\"jse-bracket\">[</div>\n              <button type=\"button\" class=\"jse-tag\" on:click={handleExpand}>\n                {value.length}\n                {value.length === 1 ? 'item' : 'items'}\n              </button>\n              <div class=\"jse-bracket\">]</div>\n            {/if}\n          </div>\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError && (!expanded || !validationError.isChildError)}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if expanded}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-inside\"\n          data-type=\"insert-selection-area-inside\"\n          on:click={handleInsertInside}\n        ></div>\n      {:else}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n    {#if expanded}\n      <div class=\"jse-items\">\n        {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isNodeSelected && isInsideSelection(selection)))}\n          <div\n            class=\"jse-insert-area jse-inside\"\n            class:jse-hovered={hover === HOVER_INSERT_INSIDE}\n            class:jse-selected={isNodeSelected && isInsideSelection(selection)}\n            data-type=\"insert-selection-area-inside\"\n            style:--level={path.length + 1}\n            title={INSERT_EXPLANATION}\n          >\n            <ContextMenuPointer\n              insert={true}\n              selected={isNodeSelected && isInsideSelection(selection)}\n              onContextMenu={handleInsertInsideOpenContextMenu}\n            />\n          </div>\n        {/if}\n        {#each visibleSections || DEFAULT_VISIBLE_SECTIONS as visibleSection, sectionIndex (sectionIndex)}\n          {#each getItems(value, visibleSection, dragging) as item (item.index)}\n            {@const nestedValidationErrors = isArrayRecursiveState(validationErrors)\n              ? validationErrors.items[item.index]\n              : undefined}\n\n            {@const nestedSelection = selectionIfOverlapping(\n              context.getJson(),\n              selection,\n              path.concat(String(item.index))\n            )}\n\n            <svelte:self\n              value={value[item.index]}\n              pointer={appendToJSONPointer(pointer, item.index)}\n              state={isArrayRecursiveState(state) ? state.items[item.index] : undefined}\n              validationErrors={nestedValidationErrors}\n              searchResults={isArrayRecursiveState(searchResults)\n                ? searchResults.items[item.index]\n                : undefined}\n              selection={nestedSelection}\n              {context}\n              onDragSelectionStart={handleDragSelectionStart}\n            >\n              <div slot=\"identifier\" class=\"jse-identifier\">\n                <div class=\"jse-index\">{item.gutterIndex}</div>\n              </div>\n            </svelte:self>\n          {/each}\n          {#if visibleSection.end < value.length}\n            <CollapsedItems\n              visibleSections={visibleSections || DEFAULT_VISIBLE_SECTIONS}\n              {sectionIndex}\n              total={value.length}\n              {path}\n              onExpandSection={context.onExpandSection}\n              {selection}\n              {context}\n            />\n          {/if}\n        {/each}\n      </div>\n      <div class=\"jse-footer-outer\">\n        <div data-type=\"selectable-value\" class=\"jse-footer\">\n          <span class=\"jse-bracket\">]</span>\n        </div>\n        {#if !root}\n          <div\n            role=\"none\"\n            class=\"jse-insert-selection-area jse-after\"\n            data-type=\"insert-selection-area-after\"\n            on:click={handleInsertAfter}\n          ></div>\n        {/if}\n      </div>\n    {/if}\n  {:else if isObject(value)}\n    <div class=\"jse-header-outer\">\n      <div class=\"jse-header\">\n        <button\n          type=\"button\"\n          class=\"jse-expand\"\n          on:click={toggleExpand}\n          title=\"Expand or collapse this object (Ctrl+Click to expand/collapse recursively)\"\n        >\n          {#if expanded}\n            <Icon data={faCaretDown} />\n          {:else}\n            <Icon data={faCaretRight} />\n          {/if}\n        </button>\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-meta\" data-type=\"selectable-value\">\n          <div class=\"jse-meta-inner\">\n            {#if expanded}\n              <div class=\"jse-bracket jse-expanded\">&lbrace;</div>\n            {:else}\n              <div class=\"jse-bracket\">&lbrace;</div>\n              <button type=\"button\" class=\"jse-tag\" on:click={handleExpand}>\n                {Object.keys(value).length}\n                {Object.keys(value).length === 1 ? 'prop' : 'props'}\n              </button>\n              <div class=\"jse-bracket\">&rbrace;</div>\n            {/if}\n          </div>\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError && (!expanded || !validationError.isChildError)}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if expanded}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-inside\"\n          data-type=\"insert-selection-area-inside\"\n          on:click={handleInsertInside}\n        ></div>\n      {:else if !root}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n    {#if expanded}\n      <div class=\"jse-props\">\n        {#if !context.readOnly && (hover === HOVER_INSERT_INSIDE || (isNodeSelected && isInsideSelection(selection)))}\n          <div\n            class=\"jse-insert-area jse-inside\"\n            class:jse-hovered={hover === HOVER_INSERT_INSIDE}\n            class:jse-selected={isNodeSelected && isInsideSelection(selection)}\n            data-type=\"insert-selection-area-inside\"\n            style:--level={path.length + 1}\n            title={INSERT_EXPLANATION}\n          >\n            <ContextMenuPointer\n              insert={true}\n              selected={isNodeSelected && isInsideSelection(selection)}\n              onContextMenu={handleInsertInsideOpenContextMenu}\n            />\n          </div>\n        {/if}\n        {#each getKeys(value, dragging) as key}\n          {@const propPointer = appendToJSONPointer(pointer, key)}\n\n          {@const nestedSearchResults = isObjectRecursiveState(searchResults)\n            ? searchResults.properties[key]\n            : undefined}\n\n          {@const nestedValidationErrors = isObjectRecursiveState(validationErrors)\n            ? validationErrors.properties[key]\n            : undefined}\n\n          {@const nestedPath = path.concat(key)}\n\n          {@const nestedSelection = selectionIfOverlapping(\n            context.getJson(),\n            selection,\n            nestedPath\n          )}\n\n          <svelte:self\n            value={value[key]}\n            pointer={propPointer}\n            state={isObjectRecursiveState(state) ? state.properties[key] : undefined}\n            validationErrors={nestedValidationErrors}\n            searchResults={nestedSearchResults}\n            selection={nestedSelection}\n            {context}\n            onDragSelectionStart={handleDragSelectionStart}\n          >\n            <div\n              slot=\"identifier\"\n              class=\"jse-key-outer\"\n              class:jse-selected-key={isKeySelection(nestedSelection) &&\n                isEqual(nestedSelection.path, nestedPath)}\n            >\n              <JSONKey\n                pointer={propPointer}\n                {key}\n                selection={nestedSelection}\n                searchResultItems={filterKeySearchResults(nestedSearchResults)}\n                {context}\n                onUpdateKey={handleUpdateKey}\n              />\n            </div>\n          </svelte:self>\n        {/each}\n      </div>\n      <div class=\"jse-footer-outer\">\n        <div data-type=\"selectable-value\" class=\"jse-footer\">\n          <div class=\"jse-bracket\">&rbrace;</div>\n        </div>\n        {#if !root}\n          <div\n            role=\"none\"\n            class=\"jse-insert-selection-area jse-after\"\n            data-type=\"insert-selection-area-after\"\n            on:click={handleInsertAfter}\n          ></div>\n        {/if}\n      </div>\n    {/if}\n  {:else}\n    <div class=\"jse-contents-outer\">\n      <div class=\"jse-contents\">\n        <slot name=\"identifier\" />\n        {#if !root}\n          <div class=\"jse-separator\">:</div>\n        {/if}\n        <div class=\"jse-value-outer\">\n          <JSONValue\n            {path}\n            {value}\n            {enforceString}\n            selection={isNodeSelected ? selection : undefined}\n            searchResultItems={filterValueSearchResults(searchResults)}\n            {context}\n          />\n        </div>\n        {#if !context.readOnly && isNodeSelected && selection && (isValueSelection(selection) || isMultiSelection(selection)) && !isEditingSelection(selection) && isEqual(getFocusPath(selection), path)}\n          <div class=\"jse-context-menu-pointer-anchor\">\n            <ContextMenuPointer {root} selected={true} onContextMenu={context.onContextMenu} />\n          </div>\n        {/if}\n      </div>\n      {#if validationError}\n        <ValidationErrorIcon {validationError} onExpand={handleExpand} />\n      {/if}\n      {#if !root}\n        <div\n          role=\"none\"\n          class=\"jse-insert-selection-area jse-after\"\n          data-type=\"insert-selection-area-after\"\n          on:click={handleInsertAfter}\n        ></div>\n      {/if}\n    </div>\n  {/if}\n  {#if !context.readOnly && (hover === HOVER_INSERT_AFTER || (isNodeSelected && isAfterSelection(selection)))}\n    <div\n      class=\"jse-insert-area jse-after\"\n      class:jse-hovered={hover === HOVER_INSERT_AFTER}\n      class:jse-selected={isNodeSelected && isAfterSelection(selection)}\n      data-type=\"insert-selection-area-after\"\n      title={INSERT_EXPLANATION}\n    >\n      <ContextMenuPointer\n        insert={true}\n        selected={isNodeSelected && isAfterSelection(selection)}\n        onContextMenu={handleInsertAfterOpenContextMenu}\n      />\n    </div>\n  {/if}\n</div>\n\n<style src=\"./JSONNode.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { initial, isEqual } from 'lodash-es'\n  import {\n    createEditKeySelection,\n    createKeySelection,\n    createValueSelection,\n    isEditingSelection,\n    isKeySelection\n  } from '$lib/logic/selection.js'\n  import SearchResultHighlighter from './highlight/SearchResultHighlighter.svelte'\n  import EditableDiv from '../../controls/EditableDiv.svelte'\n  import { addNewLineSuffix } from '$lib/utils/domUtils.js'\n  import type { ExtendedSearchResultItem, JSONSelection, TreeModeContext } from '$lib/types.js'\n  import { UpdateSelectionAfterChange } from '$lib/types.js'\n  import { type JSONPath, type JSONPointer, parseJSONPointer } from 'immutable-json-patch'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n\n  export let pointer: JSONPointer\n  export let key: string\n  export let selection: JSONSelection | undefined\n  export let searchResultItems: ExtendedSearchResultItem[] | undefined\n  export let onUpdateKey: (oldKey: string, newKey: string) => string\n\n  export let context: TreeModeContext\n\n  let path: JSONPath\n  $: path = parseJSONPointer(pointer)\n\n  $: isKeySelected = isKeySelection(selection) && isEqual(selection.path, path)\n  $: isEditingKey = isKeySelected && isEditingSelection(selection)\n\n  function handleKeyDoubleClick(\n    event: MouseEvent & { currentTarget: EventTarget & HTMLDivElement }\n  ) {\n    if (!isEditingKey && !context.readOnly) {\n      event.preventDefault()\n      context.onSelect(createEditKeySelection(path))\n    }\n  }\n\n  function handleChangeValue(newKey: string, updateSelection: UpdateSelectionAfterChange) {\n    const updatedKey = onUpdateKey(key, context.normalization.unescapeValue(newKey))\n    const updatedPath = initial(path).concat(updatedKey)\n\n    context.onSelect(\n      updateSelection === UpdateSelectionAfterChange.nextInside\n        ? createValueSelection(updatedPath)\n        : createKeySelection(updatedPath)\n    )\n\n    if (updateSelection !== UpdateSelectionAfterChange.self) {\n      context.focus()\n    }\n  }\n\n  function handleCancelChange() {\n    context.onSelect(createKeySelection(path))\n    context.focus()\n  }\n</script>\n\n{#if !context.readOnly && isEditingKey}\n  <EditableDiv\n    value={context.normalization.escapeValue(key)}\n    initialValue={isEditingSelection(selection) ? selection.initialValue : undefined}\n    label=\"Edit key\"\n    shortText\n    onChange={handleChangeValue}\n    onCancel={handleCancelChange}\n    onFind={context.onFind}\n  />\n{:else}\n  <div\n    role=\"none\"\n    data-type=\"selectable-key\"\n    class=\"jse-key\"\n    class:jse-empty={key === ''}\n    on:dblclick={handleKeyDoubleClick}\n  >\n    {#if searchResultItems}\n      <SearchResultHighlighter text={context.normalization.escapeValue(key)} {searchResultItems} />\n    {:else}\n      {addNewLineSuffix(context.normalization.escapeValue(key))}\n    {/if}\n  </div>\n{/if}\n{#if !context.readOnly && isKeySelected && !isEditingKey}\n  <ContextMenuPointer selected={true} onContextMenu={context.onContextMenu} />\n{/if}\n\n<style src=\"./JSONKey.scss\"></style>\n","import type { IconDefinition } from '@fortawesome/free-solid-svg-icons'\nimport type { IconName } from '@fortawesome/fontawesome-common-types'\n\nexport const faJSONEditorExpand: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-expand' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,448 V 512 h 512 v -64 z ' +\n      'M 0,0 V 64 H 512 V 0 Z ' +\n      'M 256,96 128,224 h 256 z ' +\n      'M 256,416 384,288 H 128 Z'\n  ]\n}\n\nexport const faJSONEditorCollapse: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-collapse' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'm 0,224 v 64 h 512 v -64 z ' + 'M 256,192 384,64 H 128 Z ' + 'M 256,320 128,448 h 256 z'\n  ]\n}\n\nexport const faJSONEditorFormat: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-format' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,32 v 64 h 416 v -64 z ' +\n      'M 160,160 v 64 h 352 v -64 z ' +\n      'M 160,288 v 64 h 288 v -64 z ' +\n      'M 0,416 v 64 h 320 v -64 z'\n  ]\n}\n\nexport const faJSONEditorCompact: IconDefinition = {\n  prefix: 'fas',\n  iconName: 'jsoneditor-compact' as IconName,\n  icon: [\n    512,\n    512,\n    [],\n    '',\n    'M 0,32 v 64 h 512 v -64 z ' + 'M 0,160 v 64 h 512 v -64 z ' + 'M 0,288 v 64 h 352 v -64 z'\n  ]\n}\n","import diffSequence from '../generated/diffSequence.js'\nimport type { JSONPatchDocument, JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport {\n  compileJSONPointer,\n  getIn,\n  isJSONArray,\n  isJSONPatchCopy,\n  isJSONPatchMove,\n  parseFrom,\n  parsePath,\n  setIn\n} from 'immutable-json-patch'\nimport { first, initial, isEmpty, isEqual, last } from 'lodash-es'\nimport naturalCompare from 'natural-compare-lite'\nimport { int } from '../utils/numberUtils.js'\nimport { isObject } from '../utils/typeUtils.js'\n\nexport function caseInsensitiveNaturalCompare(a: unknown, b: unknown) {\n  const aLower = typeof a === 'string' ? a.toLowerCase() : a\n  const bLower = typeof b === 'string' ? b.toLowerCase() : b\n\n  return naturalCompare(aLower, bLower)\n}\n\n/**\n * Sort a JSON object or array\n * @param json           The the JSON containing the (optionally nested)\n *                       object to be sorted\n * @param [rootPath=[]]  Relative path when the array was located\n * @param [itemPath=[]]  Item path by which to sort items in case of an array\n * @param [direction=1]  Pass 1 to sort ascending, -1 to sort descending\n * @return               Returns a JSONPatch document with move operation\n *                       to get the array sorted.\n */\nexport function sortJson(\n  json: unknown,\n  rootPath: JSONPath = [],\n  itemPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const value = getIn(json, rootPath)\n\n  if (isJSONArray(value)) {\n    if (itemPath === undefined) {\n      throw new Error('Cannot sort: no property selected by which to sort the array')\n    }\n\n    return sortArray(json, rootPath, itemPath, direction)\n  }\n\n  if (isObject(value)) {\n    return sortObjectKeys(json, rootPath, direction)\n  }\n\n  throw new Error('Cannot sort: no array or object')\n}\n\n/**\n * Sort the keys of an object\n * @param json           The the JSON containing the (optionally nested)\n *                       object to be sorted\n * @param [rootPath=[]]  Relative path when the array was located\n * @param [direction=1]  Pass 1 to sort ascending, -1 to sort descending\n * @return               Returns a JSONPatch document with operations\n *                       to get the array sorted.\n */\nexport function sortObjectKeys(\n  json: unknown,\n  rootPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const object = getIn(json, rootPath) as Record<string, unknown>\n  const keys = Object.keys(object as unknown as Record<string, unknown>)\n  const sortedKeys = keys.slice()\n\n  sortedKeys.sort((keyA, keyB) => {\n    return direction * caseInsensitiveNaturalCompare(keyA, keyB)\n  })\n\n  // for performance reasons, do a full replace (we could also create a move operation for every key)\n  const sortedObject: Record<string, unknown> = {}\n  sortedKeys.forEach((key) => (sortedObject[key] = object[key]))\n\n  return [\n    {\n      op: 'replace',\n      path: compileJSONPointer(rootPath),\n      value: sortedObject\n    }\n  ]\n}\n\n/**\n * Sort the items of an array\n * @param json               The document containing (optionally nested)\n *                           the array to be sorted.\n * @param [rootPath=[]]      Relative path when the array was located\n * @param [propertyPath=[]]  Nested path to the property on which to sort the contents\n * @param [direction=1]      Pass 1 to sort ascending, -1 to sort descending\n * @return                   Returns a JSONPatch document with move operation\n *                           to get the array sorted.\n */\nexport function sortArray(\n  json: unknown,\n  rootPath: JSONPath = [],\n  propertyPath: JSONPath = [],\n  direction: 1 | -1 = 1\n): JSONPatchDocument {\n  const comparator = createObjectComparator(propertyPath, direction)\n\n  // TODO: make the mechanism to sort configurable? Like use sortOperationsMove and sortOperationsMoveAdvanced\n  const array = getIn(json, rootPath) as Array<unknown>\n  return [\n    {\n      op: 'replace',\n      path: compileJSONPointer(rootPath),\n      value: array.slice(0).sort(comparator)\n    }\n  ]\n}\n\n/**\n * Create a comparator function to compare nested properties in an array\n */\nfunction createObjectComparator(propertyPath: JSONPath, direction: 1 | -1) {\n  return function comparator(a: unknown, b: unknown) {\n    const valueA = getIn(a, propertyPath)\n    const valueB = getIn(b, propertyPath)\n\n    if (valueA === undefined) {\n      return direction\n    }\n    if (valueB === undefined) {\n      return -direction\n    }\n\n    if (typeof valueA !== 'string' && typeof valueB !== 'string') {\n      // both values are a number, boolean, or null -> use simple, fast sorting\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      return valueA > valueB ? direction : valueA < valueB ? -direction : 0\n    }\n\n    return direction * caseInsensitiveNaturalCompare(valueA, valueB)\n  }\n}\n\n/**\n * Create a list with JSON Patch move operations\n * needed to sort the array contents.\n */\nexport function sortOperationsMove<T>(\n  array: T[],\n  comparator: (a: T, b: T) => number\n): JSONPatchOperation[] {\n  const operations: JSONPatchOperation[] = []\n  const sorted = []\n\n  // TODO: rewrite the function to pass a callback instead of returning an array?\n  for (let i = 0; i < array.length; i++) {\n    // TODO: can we simplify the following code?\n    const item = array[i]\n    if (i > 0 && comparator(sorted[i - 1], item) > 0) {\n      let j = i - 1\n      while (j > 0 && comparator(sorted[j - 1], item) > 0) {\n        j--\n      }\n\n      operations.push({\n        op: 'move',\n        from: '/' + i,\n        path: '/' + j\n      })\n\n      sorted.splice(j, 0, item)\n    } else {\n      sorted.push(item)\n    }\n  }\n\n  return operations\n}\n\n/**\n * Create an array containing all move operations\n * needed to sort the array contents.\n */\nexport function sortOperationsMoveAdvanced<T>(\n  array: T[],\n  comparator: (a: T, b: T) => number\n): JSONPatchOperation[] {\n  const moves: { from: number; to: number }[] = []\n\n  const sortedIndices = array\n    .map((item, index) => ({ item, index }))\n    .sort((a, b) => comparator(a.item, b.item))\n    .map((entry) => entry.index)\n\n  let bIndex = 0\n\n  function foundSubsequence(nCommon: number, aCommon: number, bCommon: number) {\n    for (let b = bIndex; b < bCommon; b++) {\n      moves.push({\n        from: sortedIndices[b],\n        to: aCommon\n      })\n    }\n\n    bIndex = bCommon + nCommon\n  }\n\n  const size = array.length\n\n  function isCommon(aIndex: number, bIndex: number) {\n    return aIndex === sortedIndices[bIndex]\n  }\n\n  diffSequence(size, size, isCommon, foundSubsequence)\n  foundSubsequence(0, size, size)\n\n  // every move will change the actual indices, so we've to adjust for that\n  // in all moves that still have to be executed\n  for (let i = 0; i < moves.length; i++) {\n    if (moves[i].to > moves[i].from) {\n      moves[i].to--\n    }\n\n    const { from, to } = moves[i]\n\n    for (let j = i + 1; j < moves.length; j++) {\n      const other = moves[j]\n      if (other.from >= from) {\n        other.from--\n      }\n      if (other.to >= from) {\n        other.to--\n      }\n      if (other.from >= to) {\n        other.from++\n      }\n      if (other.to >= to) {\n        other.to++\n      }\n    }\n  }\n\n  return moves.map(({ from, to }) => {\n    return {\n      op: 'move',\n      from: '/' + from,\n      path: '/' + to\n    }\n  })\n}\n\n/**\n * Fast solution to apply many JSON patch move operations inside a single array,\n * like applying all moves needed to sort an array.\n *\n * Throws an error when not all operations are move operation inside the same\n * array.\n */\n// TODO: write unit tests\nexport function fastPatchSort(json: unknown, operations: JSONPatchDocument): unknown {\n  if (isEmpty(operations)) {\n    // nothing to do :)\n    return json\n  }\n\n  // validate whether all operations are \"move\" operations\n  const invalidOp = operations.find((operation) => {\n    return operation.op !== 'move'\n  })\n  if (invalidOp) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not a \"move\" operation ' +\n        '(actual: ' +\n        JSON.stringify(invalidOp) +\n        ')'\n    )\n  }\n\n  // parse all paths\n  const parsedOperations: Array<{ from: JSONPath | undefined; path: JSONPath }> = operations.map(\n    (operation) => ({\n      from:\n        isJSONPatchCopy(operation) || isJSONPatchMove(operation)\n          ? parseFrom(operation.from)\n          : undefined,\n      path: parsePath(json, operation.path)\n    })\n  )\n\n  // validate whether the move actions take place in an array\n  const arrayPath = initial(first(parsedOperations)?.path)\n  const array = getIn(json, arrayPath)\n  if (!Array.isArray(array)) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not an Array ' + '(path: ' + JSON.stringify(arrayPath) + ')'\n    )\n  }\n\n  // validate whether all paths are in the same array\n  const invalidPath = parsedOperations.find((parsedOperation) => {\n    return (\n      !isEqual(arrayPath, initial(parsedOperation.path)) ||\n      !isEqual(arrayPath, initial(parsedOperation.from))\n    )\n  })\n  if (invalidPath) {\n    throw new Error(\n      'Cannot apply fastPatchSort: not all move operations are in the same array ' +\n        '(expected: ' +\n        JSON.stringify(arrayPath) +\n        ', actual: ' +\n        JSON.stringify(invalidPath) +\n        ')'\n    )\n  }\n\n  // apply the actual operations on the same array. Only copy the only array once\n  const updatedArray = array.slice(0)\n  parsedOperations.forEach((parsedOperation) => {\n    const toIndex = int(last(parsedOperation.path) || '-1')\n    const fromIndex = int(last(parsedOperation.from) || '-1')\n\n    const value = updatedArray.splice(fromIndex, 1)[0]\n    updatedArray.splice(toIndex, 0, value)\n  })\n\n  return setIn(json, arrayPath, updatedArray)\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { limit } from '$lib/utils/arrayUtils.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n\n  export let items: (string | number)[]\n  export let selectedItem: string | number\n  export let onSelect: (item: string | number) => void\n\n  const MAX_ITEMS = 100\n  const MAX_ITEM_CHARACTERS = 30\n</script>\n\n<div class=\"jse-navigation-bar-dropdown\">\n  {#each limit(items, MAX_ITEMS) as item (item)}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-dropdown-item\"\n      class:jse-selected={item === selectedItem}\n      on:click|stopPropagation={() => onSelect(item)}\n      title={item.toString()}\n    >\n      {truncate(item.toString(), MAX_ITEM_CHARACTERS)}\n    </button>\n  {/each}\n  {#if items.length > MAX_ITEMS}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-dropdown-item\"\n      title=\"Limited to {MAX_ITEMS} items\"\n    >\n      ...\n    </button>\n  {/if}\n</div>\n\n<style src=\"./NavigationBarDropdown.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faAngleRight } from '@fortawesome/free-solid-svg-icons'\n  import NavigationBarDropdown from '../../../components/controls/navigationBar/NavigationBarDropdown.svelte'\n  import { getContext } from 'svelte'\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { AbsolutePopupContext } from '$lib/types'\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let index: number\n  export let onSelect: (path: JSONPath) => void\n  export let getItems: (path: JSONPath) => string[]\n\n  let refNavigationBarItem: Element | undefined\n  let open = false\n  let popupId: number | undefined\n\n  $: itemPath = path.slice(0, index)\n  $: selectedItem = path[index]\n\n  function handleSelectItem(item: string) {\n    closeAbsolutePopup(popupId)\n    onSelect(itemPath.concat(item))\n  }\n\n  function openDropdown() {\n    if (refNavigationBarItem) {\n      open = true\n\n      const props = {\n        items: getItems(itemPath),\n        selectedItem,\n        onSelect: handleSelectItem\n      }\n\n      popupId = openAbsolutePopup(NavigationBarDropdown, props, {\n        anchor: refNavigationBarItem,\n        closeOnOuterClick: true,\n        onClose: () => {\n          open = false\n        }\n      })\n    }\n  }\n</script>\n\n<div class=\"jse-navigation-bar-item\" bind:this={refNavigationBarItem}>\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-button jse-navigation-bar-arrow\"\n    class:jse-open={open}\n    on:click={openDropdown}\n  >\n    <Icon data={faAngleRight} />\n  </button>\n  {#if selectedItem !== undefined}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-button\"\n      on:click={() => handleSelectItem(selectedItem)}\n    >\n      {selectedItem}\n    </button>\n  {/if}\n</div>\n\n<style src=\"./NavigationBarItem.scss\"></style>\n","export default function copyToClipBoard(text: string): Promise<void> {\n  if (navigator.clipboard) {\n    return navigator.clipboard.writeText(text)\n  }\n  // Compatible with old browsers such as Chrome <=65, Edge <=18 & IE\n  // Compatible with HTTP\n  else if (document.queryCommandSupported?.('copy')) {\n    const textarea = document.createElement('textarea')\n    textarea.value = text\n\n    textarea.style.position = 'fixed' // Avoid scrolling to bottom\n    textarea.style.opacity = '0'\n\n    document.body.appendChild(textarea)\n    textarea.select()\n\n    // Security exception may be thrown by some browsers\n    try {\n      document.execCommand('copy')\n    } catch (e) {\n      console.error(e)\n    } finally {\n      document.body.removeChild(textarea)\n    }\n\n    return Promise.resolve()\n  } else {\n    console.error('Copy failed.')\n\n    return Promise.resolve()\n  }\n}\n","<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { getContext, onDestroy, onMount } from 'svelte'\n  import copyToClipBoard from '$lib/utils/copyToClipboard.js'\n  import { faCopy, faExclamationTriangle } from '@fortawesome/free-solid-svg-icons'\n  import Icon from 'svelte-awesome'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { tooltip } from '../../controls/tooltip/tooltip.js'\n  import type { AbsolutePopupContext, JSONPathParser, OnError } from '$lib/types.js'\n\n  const absolutePopupContext = getContext<AbsolutePopupContext>('absolute-popup')\n\n  export let path: JSONPath\n  export let pathParser: JSONPathParser\n  export let onChange: (updatedPath: JSONPath) => void\n  export let onClose: () => void\n  export let onError: OnError\n  export let pathExists: (path: JSONPath) => boolean\n\n  let inputRef: HTMLInputElement\n  let inputPath: string\n  let validationActive = false\n  $: inputPath = pathParser.stringify(path)\n  $: inputValidationError = validationActive ? parseAndValidate(inputPath).error : undefined\n\n  let copiedTimer: number | undefined = undefined\n  let copied = false\n  const copiedDelay = 1000 // ms\n\n  onMount(() => {\n    focus()\n  })\n\n  onDestroy(() => {\n    clearTimeout(copiedTimer)\n  })\n\n  function focus() {\n    inputRef.focus()\n  }\n\n  function parseAndValidate(pathStr: string): {\n    path: JSONPath | undefined\n    error: Error | undefined\n  } {\n    try {\n      const path = pathParser.parse(pathStr)\n      validatePathExists(path)\n      return {\n        path,\n        error: undefined\n      }\n    } catch (error) {\n      return {\n        path: undefined,\n        error: error as Error\n      }\n    }\n  }\n\n  function validatePathExists(path: JSONPath) {\n    if (!pathExists(path)) {\n      throw new Error('Path does not exist in current document')\n    }\n  }\n\n  function handleInput(event: Event & { currentTarget: EventTarget & HTMLInputElement }) {\n    inputPath = event.currentTarget.value\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Escape') {\n      event.preventDefault()\n      onClose()\n    }\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n\n      validationActive = true\n      const result = parseAndValidate(inputPath)\n      if (result.path !== undefined) {\n        onChange(result.path)\n      } else {\n        onError(result.error as Error)\n      }\n    }\n  }\n\n  function handleCopy() {\n    copyToClipBoard(inputPath)\n    copied = true\n    copiedTimer = window.setTimeout(() => (copied = false), copiedDelay)\n    focus()\n  }\n</script>\n\n<div class=\"jse-navigation-bar-path-editor\" class:error={inputValidationError}>\n  <input\n    type=\"text\"\n    class=\"jse-navigation-bar-text\"\n    value={inputPath}\n    bind:this={inputRef}\n    on:keydown|stopPropagation={handleKeyDown}\n    on:input={handleInput}\n  />\n  {#if inputValidationError}\n    <button\n      type=\"button\"\n      class=\"jse-navigation-bar-validation-error\"\n      use:tooltip={{\n        text: String(inputValidationError || ''),\n        ...absolutePopupContext\n      }}\n    >\n      <Icon data={faExclamationTriangle} />\n    </button>\n  {/if}\n  {#if copied}\n    <div class=\"jse-copied-text\">Copied!</div>\n  {/if}\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-copy\"\n    class:copied\n    title=\"Copy selected path to the clipboard\"\n    on:click={handleCopy}\n  >\n    <Icon data={faCopy} />\n  </button>\n</div>\n\n<style src=\"./NavigationBarPathEditor.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { existsIn, getIn } from 'immutable-json-patch'\n  import { range } from 'lodash-es'\n  import { isObject, isObjectOrArray } from '$lib/utils/typeUtils.js'\n  import { createMultiSelection, getFocusPath } from '$lib/logic/selection.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import { caseInsensitiveNaturalCompare } from '$lib/logic/sort.js'\n  import type { JSONPathParser, JSONSelection, OnError, OnJSONSelect } from '$lib/types.js'\n  import Icon from 'svelte-awesome'\n  import { faClose, faEdit } from '@fortawesome/free-solid-svg-icons'\n  import NavigationBarItem from './NavigationBarItem.svelte'\n  import NavigationBarPathEditor from './NavigationBarPathEditor.svelte'\n\n  const debug = createDebug('jsoneditor:NavigationBar')\n\n  export let json: unknown\n  export let selection: JSONSelection | undefined\n  export let onSelect: OnJSONSelect\n  export let onError: OnError\n  export let pathParser: JSONPathParser\n\n  let refNavigationBar: Element | undefined\n  let editing = false\n\n  $: path = selection ? getFocusPath(selection) : []\n  $: hasNextItem = isObjectOrArray(getIn(json, path))\n\n  // we have an unused parameter path to trigger scrollToLastItem when path changes,\n  // see $: scrollToLastItem(path)\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function scrollToLastItem(path: JSONPath) {\n    setTimeout(() => {\n      if (refNavigationBar && refNavigationBar.scrollTo) {\n        const left = refNavigationBar.scrollWidth - refNavigationBar.clientWidth\n        if (left > 0) {\n          debug('scrollTo ', left)\n          refNavigationBar.scrollTo({ left, behavior: 'smooth' })\n        }\n      }\n    })\n  }\n\n  // trigger scrollToLastItem when path changes\n  $: scrollToLastItem(path)\n\n  function getItems(path: JSONPath): string[] {\n    debug('get items for path', path)\n\n    const node = getIn(json, path)\n    if (Array.isArray(node)) {\n      return range(0, node.length).map(String)\n    } else if (isObject(node)) {\n      const keys = Object.keys(node)\n\n      const sortedKeys = keys.slice(0)\n      sortedKeys.sort(caseInsensitiveNaturalCompare)\n\n      return sortedKeys\n    } else {\n      // never happens but just for robustness...\n      return []\n    }\n  }\n\n  function pathExists(path: JSONPath): boolean {\n    return existsIn(json, path)\n  }\n\n  function handleSelect(path: JSONPath) {\n    debug('select path', JSON.stringify(path))\n\n    onSelect(createMultiSelection(path, path))\n  }\n\n  function toggleEditing() {\n    editing = !editing\n  }\n\n  function handleCloseEditor() {\n    editing = false\n  }\n\n  function handleChangePath(path: JSONPath) {\n    handleCloseEditor()\n    handleSelect(path)\n  }\n</script>\n\n<div class=\"jse-navigation-bar\" bind:this={refNavigationBar}>\n  {#if !editing}\n    <!-- eslint-disable-next-line @typescript-eslint/no-unused-vars -->\n    {#each path as item, index (index)}\n      <NavigationBarItem {getItems} {path} {index} onSelect={handleSelect} />\n    {/each}\n    {#if hasNextItem}\n      <NavigationBarItem {getItems} {path} index={path.length} onSelect={handleSelect} />\n    {/if}\n  {:else}\n    <NavigationBarPathEditor\n      {path}\n      onClose={handleCloseEditor}\n      onChange={handleChangePath}\n      {onError}\n      {pathExists}\n      {pathParser}\n    />\n  {/if}\n\n  <button\n    type=\"button\"\n    class=\"jse-navigation-bar-edit\"\n    class:flex={!editing}\n    class:editing\n    title={editing ? 'Cancel editing the selected path' : 'Edit the selected path'}\n    on:click={toggleEditing}\n  >\n    <span class=\"jse-navigation-bar-space\">\n      <!-- ensure the right height (arrows have less height than the text) -->\n      {!isObjectOrArray(json) && !editing ? 'Navigation bar' : '\\u00A0'}\n    </span>\n\n    <Icon data={editing ? faClose : faEdit} />\n  </button>\n</div>\n\n<style src=\"./NavigationBar.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { debounce } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import {\n    faCaretDown,\n    faCaretRight,\n    faChevronDown,\n    faChevronUp,\n    faCircleNotch,\n    faSearch,\n    faTimes\n  } from '@fortawesome/free-solid-svg-icons'\n  import { DEBOUNCE_DELAY, MAX_SEARCH_RESULTS } from '$lib/constants.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { DocumentState, JSONParser, OnPatch, SearchResultDetails } from '$lib/types.js'\n  import {\n    createSearchAndReplaceAllOperations,\n    createSearchAndReplaceOperations,\n    search,\n    searchNext,\n    searchPrevious,\n    updateSearchResult\n  } from '$lib/logic/search.js'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { tick } from 'svelte'\n\n  const debug = createDebug('jsoneditor:SearchBox')\n\n  export let json: unknown\n  export let documentState: DocumentState | undefined\n  export let parser: JSONParser\n  export let showSearch: boolean\n  export let showReplace: boolean\n  export let readOnly: boolean\n  export let columns: JSONPath[] | undefined\n  export let onSearch: (result: SearchResultDetails | undefined) => void\n  export let onFocus: (path: JSONPath) => Promise<void>\n  export let onPatch: OnPatch\n  export let onClose: () => void\n\n  let text = ''\n  let appliedText = ''\n  let replaceText = ''\n  let searching = false\n  let searchResult: SearchResultDetails | undefined\n\n  $: resultCount = searchResult?.items?.length || 0\n  $: activeIndex = searchResult?.activeIndex || 0\n  $: formattedResultCount =\n    resultCount >= MAX_SEARCH_RESULTS ? `${MAX_SEARCH_RESULTS - 1}+` : String(resultCount)\n\n  $: onSearch(searchResult)\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyChangedShowSearch(showSearch)\n\n  const applyChangedSearchTextDebounced = debounce(applyChangedSearchText, DEBOUNCE_DELAY)\n  $: applyChangedSearchTextDebounced(text)\n\n  const applyChangedJsonDebounced = debounce(applyChangedJson, DEBOUNCE_DELAY)\n  $: applyChangedJsonDebounced(json)\n\n  function toggleShowReplace() {\n    showReplace = !showReplace && !readOnly\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    // key events must not be handled by the generic keydown handler of the\n    // whole JSONEditor.\n    event.stopPropagation()\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n\n      const pendingChanges = text !== appliedText\n      if (pendingChanges) {\n        applyChangedSearchTextDebounced.flush()\n      } else {\n        handleNext()\n      }\n    }\n\n    if (combo === 'Shift+Enter') {\n      event.preventDefault()\n      handlePrevious()\n    }\n\n    if (combo === 'Ctrl+Enter') {\n      event.preventDefault()\n\n      if (showReplace) {\n        handleReplace()\n      } else {\n        handleNext()\n        // TODO: move focus to the active element so you can start editing?\n      }\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      toggleShowReplace()\n    }\n\n    if (combo === 'Escape') {\n      event.preventDefault()\n\n      handleClose()\n    }\n  }\n\n  function handleReplaceKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n\n    if (combo === 'Enter') {\n      event.preventDefault()\n      event.stopPropagation()\n\n      handleReplace()\n    }\n  }\n\n  async function handlePaste() {\n    await tick()\n    setTimeout(() => applyChangedSearchTextDebounced.flush())\n  }\n\n  async function handleReplace() {\n    if (readOnly) {\n      return\n    }\n\n    const activeItem = searchResult?.activeItem\n    debug('handleReplace', { replaceText, activeItem })\n\n    if (!searchResult || !activeItem || json === undefined) {\n      return\n    }\n\n    // move to the next search result *before* applying the replacement\n    searchResult = {\n      ...searchNext(searchResult),\n      activeIndex // trick to prevent shortly flickering of index from 1 to 2 and then to 1 again after the next search\n    }\n\n    const { operations, newSelection } = createSearchAndReplaceOperations(\n      json,\n      documentState,\n      replaceText,\n      activeItem,\n      parser\n    )\n\n    onPatch(operations, (_, patchedState) => ({\n      state: patchedState,\n      selection: newSelection\n    }))\n\n    // immediately trigger updating the search results\n    await tick()\n    await applyChangedJsonDebounced.flush()\n\n    // focus to the next search result\n    await handleFocus()\n  }\n\n  async function handleReplaceAll() {\n    if (readOnly) {\n      return\n    }\n\n    debug('handleReplaceAll', { text, replaceText })\n\n    const { operations, newSelection } = createSearchAndReplaceAllOperations(\n      json,\n      documentState,\n      text,\n      replaceText,\n      parser\n    )\n\n    onPatch(operations, (_, patchedState) => ({\n      state: patchedState,\n      selection: newSelection\n    }))\n\n    await handleFocus()\n  }\n\n  function initSearchInput(element: HTMLInputElement) {\n    element.select()\n  }\n\n  async function handleNext() {\n    searchResult = searchResult ? searchNext(searchResult) : undefined\n\n    await handleFocus()\n  }\n\n  async function handlePrevious() {\n    searchResult = searchResult ? searchPrevious(searchResult) : undefined\n\n    await handleFocus()\n  }\n\n  async function handleFocus() {\n    debug('handleFocus', searchResult)\n\n    const activeItem = searchResult?.activeItem\n    if (activeItem && json !== undefined) {\n      await onFocus(activeItem.path)\n    }\n  }\n\n  async function applyChangedShowSearch(showSearch: boolean) {\n    await applySearch(showSearch, text, json)\n  }\n\n  async function applyChangedSearchText(text: string) {\n    await applySearch(showSearch, text, json)\n    await handleFocus()\n  }\n\n  async function applyChangedJson(json: unknown) {\n    await applySearch(showSearch, text, json)\n  }\n\n  // we pass searchText and json as argument to trigger search when these variables change,\n  // via various listeners like applyChangedSearchText\n  async function applySearch(showSearch: boolean, text: string, json: unknown): Promise<void> {\n    if (!showSearch) {\n      if (searchResult) {\n        searchResult = undefined\n      }\n\n      return Promise.resolve()\n    }\n\n    debug('applySearch', { showSearch, text })\n\n    if (text === '') {\n      debug('clearing search result')\n\n      if (searchResult !== undefined) {\n        searchResult = undefined\n      }\n\n      return Promise.resolve()\n    }\n\n    appliedText = text\n    searching = true\n\n    return new Promise<void>((resolve) => {\n      setTimeout(() => {\n        // wait until the search icon has been rendered\n        const newResultItems = search(text, json, { maxResults: MAX_SEARCH_RESULTS, columns })\n        searchResult = updateSearchResult(newResultItems, searchResult)\n\n        searching = false\n        resolve()\n      })\n    })\n  }\n\n  function handleClose() {\n    debug('handleClose')\n    applyChangedSearchTextDebounced.cancel()\n    applyChangedJsonDebounced.cancel()\n    applySearch(false, text, json) // will clear the search results\n    onClose()\n  }\n</script>\n\n{#if showSearch}\n  <div class=\"jse-search-box\">\n    <!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n    <form class=\"jse-search-form\" on:keydown={handleKeyDown}>\n      {#if !readOnly}\n        <button\n          type=\"button\"\n          class=\"jse-replace-toggle\"\n          title=\"Toggle visibility of replace options (Ctrl+H)\"\n          on:click={toggleShowReplace}\n        >\n          <Icon data={showReplace ? faCaretDown : faCaretRight} />\n        </button>\n      {/if}\n      <div class=\"jse-search-contents\">\n        <div class=\"jse-search-section\">\n          <div class=\"jse-search-icon\">\n            {#if searching}\n              <Icon data={faCircleNotch} spin />\n            {:else}\n              <Icon data={faSearch} />\n            {/if}\n          </div>\n          <label class=\"jse-search-input-label\" about=\"jse-search input\">\n            <input\n              class=\"jse-search-input\"\n              title=\"Enter text to search\"\n              type=\"text\"\n              placeholder=\"Find\"\n              bind:value={text}\n              use:initSearchInput\n              on:paste={handlePaste}\n            />\n          </label>\n          <div class=\"jse-search-count\" class:jse-visible={text !== ''}>\n            {activeIndex !== -1 && activeIndex < resultCount\n              ? `${activeIndex + 1}/`\n              : ''}{formattedResultCount}\n          </div>\n          <button\n            type=\"button\"\n            class=\"jse-search-next\"\n            title=\"Go to next search result (Enter)\"\n            on:click={handleNext}\n          >\n            <Icon data={faChevronDown} />\n          </button>\n          <button\n            type=\"button\"\n            class=\"jse-search-previous\"\n            title=\"Go to previous search result (Shift+Enter)\"\n            on:click={handlePrevious}\n          >\n            <Icon data={faChevronUp} />\n          </button>\n          <button\n            type=\"button\"\n            class=\"jse-search-clear\"\n            title=\"Close search box (Esc)\"\n            on:click={handleClose}\n          >\n            <Icon data={faTimes} />\n          </button>\n        </div>\n        {#if showReplace && !readOnly}\n          <div class=\"jse-replace-section\">\n            <input\n              class=\"jse-replace-input\"\n              title=\"Enter replacement text\"\n              type=\"text\"\n              placeholder=\"Replace\"\n              bind:value={replaceText}\n              on:keydown={handleReplaceKeyDown}\n            />\n            <button\n              type=\"button\"\n              title=\"Replace current occurrence (Ctrl+Enter)\"\n              on:click={handleReplace}>Replace</button\n            >\n            <button type=\"button\" title=\"Replace all occurrences\" on:click={handleReplaceAll}\n              >All</button\n            >\n          </div>\n        {/if}\n      </div>\n    </form>\n  </div>\n{/if}\n\n<style src=\"./SearchBox.scss\"></style>\n","import type { JSONPatchOperation, JSONPath } from 'immutable-json-patch'\nimport {\n  compileJSONPointer,\n  isJSONArray,\n  isJSONObject,\n  parseJSONPointer\n} from 'immutable-json-patch'\nimport { groupBy, isEmpty, isEqual, mapValues, partition } from 'lodash-es'\nimport type { JSONSelection, SortedColumn, TableCellIndex, ValidationError } from '$lib/types.js'\nimport { ValidationSeverity } from '$lib/types.js'\nimport { createValueSelection, getFocusPath, pathStartsWith } from './selection.js'\nimport { containsNumber } from '../utils/numberUtils.js'\nimport type { Dictionary } from 'lodash'\nimport { stringifyJSONPath } from '$lib/utils/pathUtils.js'\nimport { forEachSample } from '$lib/utils/arrayUtils.js'\nimport { isObject } from '$lib/utils/typeUtils.js'\n\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\ntype NestedObject = Record<string, NestedObject>\n\nconst endOfPath = Symbol('path')\n\nexport function getColumns(\n  array: Array<unknown>,\n  flatten: boolean,\n  maxSampleCount = Infinity\n): JSONPath[] {\n  const merged: NestedObject = {}\n\n  if (Array.isArray(array)) {\n    // We read samples spread through the whole array, from begin to end.\n    // When the array is sorted, and a specific field is present only at the last\n    // couple of items of the array or in the middle, we want to pick that up too.\n    forEachSample(array, maxSampleCount, (item) => {\n      if (isObject(item)) {\n        _recurseObject(item, merged, flatten)\n      } else {\n        merged[endOfPath] = true\n      }\n    })\n  }\n\n  const paths: JSONPath[] = []\n  if (endOfPath in merged) {\n    paths.push([])\n  }\n  _collectPaths(merged, [], paths, flatten)\n\n  return paths\n}\n\n// internal function for getColumns\n// mutates the argument merged\nfunction _recurseObject(object: NestedObject, merged: NestedObject, flatten: boolean): void {\n  for (const key in object) {\n    const value = object[key]\n    const valueMerged = merged[key] || (merged[key] = {})\n\n    if (isObject(value) && flatten) {\n      _recurseObject(value, valueMerged, flatten)\n    } else {\n      if (valueMerged[endOfPath] === undefined) {\n        valueMerged[endOfPath] = true\n      }\n    }\n  }\n}\n\n// internal function for getColumns\n// mutates the argument paths\nfunction _collectPaths(\n  object: NestedObject,\n  parentPath: JSONPath,\n  paths: JSONPath[],\n  flatten: boolean\n): void {\n  for (const key in object) {\n    const path = parentPath.concat(key)\n    const value = object[key]\n\n    if (value && value[endOfPath] === true) {\n      paths.push(path)\n    }\n\n    if (isJSONObject(value) && flatten) {\n      _collectPaths(value, path, paths, flatten)\n    }\n  }\n}\n\nexport function maintainColumnOrder(\n  newColumns: JSONPath[],\n  previousColumns: JSONPath[]\n): JSONPath[] {\n  const orderedColumns = new Set(previousColumns.map(compileJSONPointer))\n  const newColumnsSet = new Set(newColumns.map(compileJSONPointer))\n\n  // delete the columns that are gone now\n  for (const column of orderedColumns) {\n    if (!newColumnsSet.has(column)) {\n      orderedColumns.delete(column)\n    }\n  }\n\n  // append the new columns to the end\n  for (const column of newColumnsSet) {\n    if (!orderedColumns.has(column)) {\n      orderedColumns.add(column)\n    }\n  }\n\n  return [...orderedColumns].map(parseJSONPointer)\n}\n\nexport function getShallowKeys(value: unknown): JSONPath[] {\n  return isJSONObject(value) ? Object.keys(value).map((key) => [key]) : [[]]\n}\n\nexport function getRecursiveKeys(value: unknown): JSONPath[] {\n  const paths: JSONPath[] = []\n\n  function recurse(value: unknown, path: JSONPath) {\n    if (isJSONObject(value)) {\n      Object.keys(value).forEach((key) => {\n        recurse(value[key], path.concat(key))\n      })\n    } else {\n      // array or primitive value like string or number\n      paths.push(path)\n    }\n  }\n\n  recurse(value, [])\n\n  return paths\n}\n\nexport interface VisibleSection {\n  startIndex: number\n  endIndex: number\n  startHeight: number\n  visibleHeight: number\n  endHeight: number\n  averageItemHeight: number\n  visibleItems: Array<unknown>\n}\n\n// TODO: write unit tests\nexport function calculateVisibleSection(\n  scrollTop: number,\n  viewPortHeight: number,\n  json: unknown | undefined,\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number,\n  searchBoxOffset: number,\n  margin = 80\n): VisibleSection {\n  const itemCount = isJSONArray(json) ? json.length : 0\n  const averageItemHeight = calculateAverageItemHeight(itemHeights, defaultItemHeight)\n  const viewPortTop = scrollTop - margin\n  const viewPortBottom = viewPortHeight + 2 * margin\n\n  const getItemHeight = (index: number) => itemHeights[index] || defaultItemHeight\n\n  let startIndex = 0\n  let startHeight = searchBoxOffset\n  while (startHeight < viewPortTop && startIndex < itemCount) {\n    startHeight += getItemHeight(startIndex)\n    startIndex++\n  }\n  if (startIndex > 0) {\n    // go one item back, else there is white space at the top for up to 1 missing item\n    startIndex--\n    startHeight -= getItemHeight(startIndex)\n  }\n\n  let endIndex = startIndex\n  let visibleHeight = 0\n  while (visibleHeight < viewPortBottom && endIndex < itemCount) {\n    visibleHeight += getItemHeight(endIndex)\n    endIndex++\n  }\n\n  let endHeight = 0\n  for (let i = endIndex; i < itemCount; i++) {\n    endHeight += getItemHeight(i)\n  }\n\n  const visibleItems = isJSONArray(json) ? json.slice(startIndex, endIndex) : []\n\n  return {\n    startIndex,\n    endIndex,\n    startHeight,\n    endHeight,\n    averageItemHeight,\n    visibleHeight,\n    visibleItems\n  }\n}\n\n// TODO: cleanup if we will not use it in the end\n// TODO: write unit tests\nexport function calculateVisibleSectionApprox(\n  scrollTop: number,\n  viewPortHeight: number,\n  json: unknown | undefined,\n  defaultItemHeight: number\n): VisibleSection {\n  const itemCount = isJSONArray(json) ? json.length : 0\n  const averageItemHeight = defaultItemHeight\n\n  const viewPortTop = scrollTop\n  const startIndex = Math.floor(viewPortTop / defaultItemHeight)\n  const startHeight = startIndex * defaultItemHeight\n  const endIndex = Math.ceil((viewPortTop + viewPortHeight) / defaultItemHeight)\n  const visibleHeight = (endIndex - startIndex) * defaultItemHeight\n  const endHeight = (itemCount - endIndex) * defaultItemHeight\n\n  const visibleItems = isJSONArray(json) ? json.slice(startIndex, endIndex) : []\n\n  return {\n    startIndex,\n    endIndex,\n    startHeight,\n    endHeight,\n    averageItemHeight,\n    visibleHeight,\n    visibleItems\n  }\n}\n\n// TODO: write unit tests\nexport function calculateAbsolutePosition(\n  path: JSONPath,\n  columns: JSONPath[],\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number\n): number {\n  const { rowIndex } = toTableCellPosition(path, columns)\n\n  let top = 0\n  for (let currentIndex = 0; currentIndex < rowIndex; currentIndex++) {\n    top += itemHeights[currentIndex] || defaultItemHeight\n  }\n\n  // TODO: also calculate left\n  return top\n}\n\nfunction calculateAverageItemHeight(\n  itemHeights: Record<number, number>,\n  defaultItemHeight: number\n): number {\n  const values = Object.values(itemHeights) // warning: itemHeights is mutated and not updated itself, we can't watch it!\n  if (isEmpty(values)) {\n    return defaultItemHeight\n  }\n\n  const add = (a: number, b: number) => a + b\n  const total = values.reduce(add)\n  return total / values.length\n}\n\nexport function selectPreviousRow(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (rowIndex > 0) {\n    const previousPosition = { rowIndex: rowIndex - 1, columnIndex }\n    const previousPath = fromTableCellPosition(previousPosition, columns)\n    return createValueSelection(previousPath)\n  }\n\n  return selection\n}\n\nexport function selectNextRow(\n  json: unknown,\n  columns: JSONPath[],\n  selection: JSONSelection\n): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (rowIndex < (json as Array<unknown>).length - 1) {\n    const nextPosition = { rowIndex: rowIndex + 1, columnIndex }\n    const nextPath = fromTableCellPosition(nextPosition, columns)\n    return createValueSelection(nextPath)\n  }\n\n  return selection\n}\n\nexport function selectPreviousColumn(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (columnIndex > 0) {\n    const previousPosition = { rowIndex, columnIndex: columnIndex - 1 }\n    const previousPath = fromTableCellPosition(previousPosition, columns)\n    return createValueSelection(previousPath)\n  }\n\n  return selection\n}\n\nexport function selectNextColumn(columns: JSONPath[], selection: JSONSelection): JSONSelection {\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  if (columnIndex < columns.length - 1) {\n    const nextPosition = { rowIndex, columnIndex: columnIndex + 1 }\n    const nextPath = fromTableCellPosition(nextPosition, columns)\n    return createValueSelection(nextPath)\n  }\n\n  return selection\n}\n\nexport function toTableCellPosition(path: JSONPath, columns: JSONPath[]): TableCellIndex {\n  const [index, ...column] = path\n\n  const rowIndex = parseInt(index, 10)\n\n  return {\n    rowIndex: !isNaN(rowIndex) ? rowIndex : -1,\n    columnIndex: columns.findIndex((c) => pathStartsWith(column, c))\n  }\n}\n\nexport function fromTableCellPosition(position: TableCellIndex, columns: JSONPath[]): JSONPath {\n  const { rowIndex, columnIndex } = position\n\n  return [String(rowIndex), ...columns[columnIndex]]\n}\n\nexport function stringifyTableCellPosition(position: TableCellIndex): string {\n  const { rowIndex, columnIndex } = position\n\n  return `${rowIndex}:${columnIndex}`\n}\n\ninterface GroupedValidationErrorsByRow {\n  row: ValidationError[]\n  columns: Dictionary<ValidationError[]>\n}\n\nexport interface GroupedValidationErrors {\n  root: ValidationError[]\n  rows: Dictionary<GroupedValidationErrorsByRow>\n}\n\n/**\n * Group validation errors for use in the Table view: per column, and a group for the row as a whole\n */\nexport function groupValidationErrors(\n  validationErrors: ValidationError[],\n  columns: JSONPath[]\n): GroupedValidationErrors {\n  const [arrayErrors, rootErrors] = partition(validationErrors, (validationError) =>\n    containsNumber(validationError.path[0])\n  )\n\n  const errorsByRow: Dictionary<ValidationError[]> = groupBy(arrayErrors, findRowIndex)\n\n  const groupedErrorsByRow = mapValues(errorsByRow, (errors) => {\n    const groupByRow: GroupedValidationErrorsByRow = {\n      row: [],\n      columns: {}\n    }\n\n    errors.forEach((error) => {\n      const columnIndex = findColumnIndex(error, columns)\n\n      if (columnIndex !== -1) {\n        if (groupByRow.columns[columnIndex] === undefined) {\n          groupByRow.columns[columnIndex] = []\n        }\n        groupByRow.columns[columnIndex].push(error)\n      } else {\n        groupByRow.row.push(error)\n      }\n    })\n\n    return groupByRow\n  })\n\n  return {\n    root: rootErrors,\n    rows: groupedErrorsByRow\n  }\n}\n\nexport function mergeValidationErrors(\n  path: JSONPath,\n  validationErrors: ValidationError[] | undefined\n): ValidationError | undefined {\n  if (!validationErrors || validationErrors.length === 0) {\n    return undefined\n  }\n\n  if (validationErrors.length === 1) {\n    return validationErrors[0]\n  }\n\n  return {\n    path,\n    message:\n      'Multiple validation issues: ' +\n      validationErrors\n        .map((error) => {\n          return stringifyJSONPath(error.path) + ' ' + error.message\n        })\n        .join(', '),\n    severity: ValidationSeverity.warning\n  }\n}\n\nfunction findRowIndex(error: ValidationError): number {\n  return parseInt(error.path[0], 10)\n}\n\nfunction findColumnIndex(error: ValidationError, columns: JSONPath[]): number {\n  const position = toTableCellPosition(error.path, columns)\n\n  if (position.columnIndex !== -1) {\n    return position.columnIndex\n  }\n\n  return -1\n}\n\n/**\n * Clear the sorted column from the documentState when it is affected by the operations\n */\nexport function clearSortedColumnWhenAffectedByOperations(\n  sortedColumn: SortedColumn | undefined,\n  operations: JSONPatchOperation[],\n  columms: JSONPath[]\n): SortedColumn | undefined {\n  const mustBeCleared = operations.some((operation) =>\n    operationAffectsSortedColumn(sortedColumn, operation, columms)\n  )\n\n  return mustBeCleared ? undefined : sortedColumn\n}\n\nexport function operationAffectsSortedColumn(\n  sortedColumn: SortedColumn | undefined,\n  operation: JSONPatchOperation,\n  columns: JSONPath[]\n): boolean {\n  if (!sortedColumn) {\n    return false\n  }\n\n  // an operation of replacing a value in a different column does not affect the currently sorted order\n  if (operation.op === 'replace') {\n    const path = parseJSONPointer(operation.path)\n    const { rowIndex, columnIndex } = toTableCellPosition(path, columns)\n    const selectedColumnIndex = columns.findIndex((column) => isEqual(column, sortedColumn.path))\n\n    if (rowIndex !== -1 && columnIndex !== -1 && columnIndex !== selectedColumnIndex) {\n      return false\n    }\n  }\n\n  // TODO: there are more cases where we can known an operation does not affect the sorted order, improve this\n  //  For example adding a nested value in a different column, or removing a full row.\n\n  return true\n}\n\n/**\n * Find nested arrays inside a JSON object\n */\nexport function findNestedArrays(json: unknown, maxLevel = 2): JSONPath[] {\n  const props: JSONPath[] = []\n\n  function recurse(value: unknown, path: JSONPath) {\n    if (isJSONObject(value) && path.length < maxLevel) {\n      Object.keys(value).forEach((key) => {\n        recurse(value[key], path.concat(key))\n      })\n    }\n\n    if (isJSONArray(value)) {\n      props.push(path)\n    }\n  }\n\n  recurse(json, [])\n\n  return props\n}\n","import {\n  createEditKeySelection,\n  createEditValueSelection,\n  createInsideSelection,\n  createMultiSelection,\n  createValueSelection,\n  getFocusPath,\n  hasSelectionContents,\n  isKeySelection,\n  isValueSelection,\n  selectionToPartialJson\n} from '$lib/logic/selection.js'\nimport copyToClipboard from '$lib/utils/copyToClipboard.js'\nimport {\n  append,\n  createNewValue,\n  createRemoveOperations,\n  duplicate,\n  insert,\n  insertBefore,\n  removeAll\n} from '$lib/logic/operations.js'\nimport type {\n  AfterPatchCallback,\n  InsertType,\n  JSONParser,\n  JSONSelection,\n  OnChange,\n  OnChangeText,\n  OnJSONSelect,\n  OnPatch\n} from '$lib/types'\nimport { createDebug } from '$lib/utils/debug.js'\nimport {\n  getIn,\n  isJSONObject,\n  isJSONPatchAdd,\n  isJSONPatchReplace,\n  type JSONPath,\n  parsePath\n} from 'immutable-json-patch'\nimport { isObject, isObjectOrArray } from '$lib/utils/typeUtils.js'\nimport { expandAll, expandNone, expandPath, expandSmart } from '$lib/logic/documentState.js'\nimport { initial, isEmpty, last } from 'lodash-es'\nimport { fromTableCellPosition, toTableCellPosition } from '$lib/logic/table.js'\n\nconst debug = createDebug('jsoneditor:actions')\n\nexport interface OnCutAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  indentation: string | number | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n}\n\n// TODO: write unit tests\nexport async function onCut({\n  json,\n  selection,\n  indentation,\n  readOnly,\n  parser,\n  onPatch\n}: OnCutAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const clipboard = selectionToPartialJson(json, selection, indentation, parser)\n  if (clipboard === undefined) {\n    return\n  }\n\n  debug('cut', { selection, clipboard, indentation })\n\n  await copyToClipboard(clipboard)\n\n  const { operations, newSelection } = createRemoveOperations(json, selection)\n\n  onPatch(operations, (_, patchedState) => ({\n    state: patchedState,\n    selection: newSelection\n  }))\n}\n\nexport interface OnCopyAction {\n  json: unknown\n  selection: JSONSelection | undefined\n  indentation: string | number | undefined\n  parser: JSONParser\n}\n\n// TODO: write unit tests\nexport async function onCopy({ json, selection, indentation, parser }: OnCopyAction) {\n  const clipboard = selectionToPartialJson(json, selection, indentation, parser)\n  if (clipboard === undefined) {\n    return\n  }\n\n  debug('copy', { clipboard, indentation })\n\n  await copyToClipboard(clipboard)\n}\n\ntype RepairModalCallback = (text: string, onApply: (repairedText: string) => void) => void\n\ninterface OnPasteAction {\n  clipboardText: string\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onChangeText: OnChangeText\n  openRepairModal: RepairModalCallback\n}\n\n// TODO: write unit tests\nexport function onPaste({\n  clipboardText,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onChangeText,\n  openRepairModal\n}: OnPasteAction) {\n  if (readOnly) {\n    return\n  }\n\n  function doPaste(pastedText: string) {\n    if (json !== undefined) {\n      const ensureSelection = selection || createValueSelection([])\n\n      const operations = insert(json, ensureSelection, pastedText, parser)\n\n      debug('paste', { pastedText, operations, ensureSelection })\n\n      onPatch(operations, (patchedJson, patchedState) => {\n        let updatedState = patchedState\n\n        // expand newly inserted object/array\n        operations\n          .filter(\n            (operation) =>\n              (isJSONPatchAdd(operation) || isJSONPatchReplace(operation)) &&\n              isObjectOrArray(operation.value)\n          )\n          .forEach((operation) => {\n            const path = parsePath(json, operation.path)\n            updatedState = expandSmart(patchedJson, updatedState, path)\n          })\n\n        return {\n          state: updatedState\n        }\n      })\n    } else {\n      // no json: empty document, or the contents is invalid text\n      debug('paste text', { pastedText })\n\n      onChangeText(clipboardText, (patchedJson, patchedState) => {\n        if (patchedJson) {\n          const path: JSONPath = []\n          return {\n            state: expandSmart(patchedJson, patchedState, path)\n          }\n        }\n\n        return undefined\n      })\n    }\n  }\n\n  try {\n    doPaste(clipboardText)\n  } catch {\n    openRepairModal(clipboardText, (repairedText) => {\n      debug('repaired pasted text: ', repairedText)\n      doPaste(repairedText)\n    })\n  }\n}\n\nexport interface OnRemoveAction {\n  json: unknown | undefined\n  text: string | undefined\n  selection: JSONSelection | undefined\n  keepSelection: boolean\n  readOnly: boolean\n  onChange: OnChange\n  onPatch: OnPatch\n}\n\n// TODO: write unit tests\nexport function onRemove({\n  json,\n  text,\n  selection,\n  keepSelection,\n  readOnly,\n  onChange,\n  onPatch\n}: OnRemoveAction) {\n  if (readOnly || !selection) {\n    return\n  }\n\n  // in case of a selected key or value, we change the selection to the whole\n  // entry to remove this, we do not want to clear a key or value only.\n  const removeSelection =\n    json !== undefined && (isKeySelection(selection) || isValueSelection(selection))\n      ? createMultiSelection(selection.path, selection.path)\n      : selection\n\n  if (isEmpty(getFocusPath(selection))) {\n    // root selected -> clear complete document\n    debug('remove root', { selection })\n\n    if (onChange) {\n      onChange(\n        { text: '', json: undefined },\n        json !== undefined ? { text: undefined, json } : { text: text || '', json },\n        {\n          contentErrors: undefined,\n          patchResult: undefined\n        }\n      )\n    }\n  } else {\n    // remove selection\n    if (json !== undefined) {\n      const { operations, newSelection } = createRemoveOperations(json, removeSelection)\n\n      debug('remove', { operations, selection, newSelection })\n\n      onPatch(operations, (_, patchedState) => ({\n        state: patchedState,\n        selection: keepSelection ? selection : newSelection\n      }))\n    }\n  }\n}\n\nexport interface OnDuplicateRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onDuplicateRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnDuplicateRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('duplicate row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const operations = duplicate(json, [rowPath])\n\n  onPatch(operations, (_, patchedState) => {\n    const newRowIndex = rowIndex < (json as Array<unknown>).length ? rowIndex + 1 : rowIndex\n    const newPath = fromTableCellPosition({ rowIndex: newRowIndex, columnIndex }, columns)\n    const newSelection = createValueSelection(newPath)\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnInsertBeforeRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onInsertBeforeRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnInsertBeforeRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('insert before row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const newValue = isJSONObject((json as Array<unknown>)[0]) ? {} : ''\n  const values = [{ key: '', value: newValue }]\n  const operations = insertBefore(json, rowPath, values)\n\n  onPatch(operations)\n}\n\nexport interface OnInsertAfterRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onInsertAfterRow({\n  json,\n  selection,\n  columns,\n  readOnly,\n  onPatch\n}: OnInsertAfterRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('insert after row', { rowIndex })\n\n  const nextRowIndex = rowIndex + 1\n  const nextRowPath = [String(nextRowIndex)]\n  const newValue = isJSONObject((json as Array<unknown>)[0]) ? {} : ''\n  const values = [{ key: '', value: newValue }]\n\n  const operations =\n    nextRowIndex < (json as Array<unknown>).length\n      ? insertBefore(json, nextRowPath, values)\n      : append(json, [], values)\n\n  onPatch(operations, (_, patchedState) => {\n    const nextPath = fromTableCellPosition({ rowIndex: nextRowIndex, columnIndex }, columns)\n    const newSelection = createValueSelection(nextPath)\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnRemoveRowAction {\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  columns: JSONPath[]\n  readOnly: boolean\n  onPatch: OnPatch\n}\n\n/**\n * This function assumes that the json holds the Array that we're duplicating a row for,\n * it cannot duplicate something in some nested array\n */\n// TODO: write unit tests\nexport function onRemoveRow({ json, selection, columns, readOnly, onPatch }: OnRemoveRowAction) {\n  if (readOnly || json === undefined || !selection || !hasSelectionContents(selection)) {\n    return\n  }\n\n  const { rowIndex, columnIndex } = toTableCellPosition(getFocusPath(selection), columns)\n\n  debug('remove row', { rowIndex })\n\n  const rowPath = [String(rowIndex)]\n  const operations = removeAll([rowPath])\n\n  onPatch(operations, (patchedJson, patchedState) => {\n    const newRowIndex =\n      rowIndex < (patchedJson as Array<unknown>).length\n        ? rowIndex\n        : rowIndex > 0\n          ? rowIndex - 1\n          : undefined\n\n    const newSelection =\n      newRowIndex !== undefined\n        ? createValueSelection(\n            fromTableCellPosition({ rowIndex: newRowIndex, columnIndex }, columns)\n          )\n        : undefined\n\n    debug('remove row new selection', { rowIndex, newRowIndex, newSelection })\n\n    return {\n      state: patchedState,\n      selection: newSelection\n    }\n  })\n}\n\nexport interface OnInsert {\n  insertType: InsertType\n  selectInside: boolean\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  initialValue: string | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n}\n\n// TODO: write unit tests\nexport function onInsert({\n  insertType,\n  selectInside,\n  initialValue,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson\n}: OnInsert): void {\n  if (readOnly) {\n    return\n  }\n\n  const newValue = createNewValue(json, selection, insertType)\n\n  if (json !== undefined) {\n    const data = parser.stringify(newValue) as string\n    const operations = insert(json, selection, data, parser)\n    debug('onInsert', { insertType, operations, newValue, data })\n\n    const operation = last(\n      operations.filter((operation) => operation.op === 'add' || operation.op === 'replace')\n    )\n\n    onPatch(operations, (patchedJson, patchedState, patchedSelection) => {\n      // TODO: extract determining the newSelection in a separate function\n      if (operation) {\n        const path = parsePath(patchedJson, operation.path)\n\n        if (isObjectOrArray(newValue)) {\n          return {\n            state: expandPath(patchedJson, patchedState, path, expandAll),\n            selection: selectInside ? createInsideSelection(path) : patchedSelection\n          }\n        }\n\n        if (newValue === '') {\n          // open the newly inserted value in edit mode\n          const parent = !isEmpty(path) ? getIn(patchedJson, initial(path)) : undefined\n\n          return {\n            state: expandPath(patchedJson, patchedState, path, expandNone),\n            selection: isObject(parent)\n              ? createEditKeySelection(path, initialValue)\n              : createEditValueSelection(path, initialValue)\n          }\n        }\n      }\n\n      return undefined\n    })\n\n    debug('after patch')\n  } else {\n    // document is empty or invalid (in that case it has text but no json)\n    debug('onInsert', { insertType, newValue })\n\n    const path: JSONPath = []\n    onReplaceJson(newValue, (patchedJson, patchedState) => ({\n      state: expandSmart(patchedJson, patchedState, path),\n      selection: isObjectOrArray(newValue)\n        ? createInsideSelection(path)\n        : createEditValueSelection(path)\n    }))\n  }\n}\n\nexport interface OnInsertCharacter {\n  char: string\n  selectInside: boolean\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n  onSelect: OnJSONSelect\n}\n\n// TODO: write unit tests\nexport async function onInsertCharacter({\n  char,\n  selectInside,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson,\n  onSelect\n}: OnInsertCharacter) {\n  // a regular key like a, A, _, etc. is entered.\n  // Replace selected contents with a new value having this first character as text\n  if (readOnly) {\n    return\n  }\n\n  if (isKeySelection(selection)) {\n    onSelect({ ...selection, edit: true, initialValue: char })\n    return\n  }\n\n  if (char === '{') {\n    onInsert({\n      insertType: 'object',\n      selectInside,\n      initialValue: undefined, // not relevant\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch,\n      onReplaceJson\n    })\n  } else if (char === '[') {\n    onInsert({\n      insertType: 'array',\n      selectInside,\n      initialValue: undefined, // not relevant\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch,\n      onReplaceJson\n    })\n  } else {\n    if (isValueSelection(selection) && json !== undefined) {\n      if (!isObjectOrArray(getIn(json, selection.path))) {\n        onSelect({ ...selection, edit: true, initialValue: char })\n      } else {\n        // TODO: replace the object/array with editing a text in edit mode?\n        //  (Ideally this this should not create an entry in history though,\n        //  which isn't really possible right now since we have to apply\n        //  a patch to change the object/array into a value)\n      }\n    } else {\n      debug('onInsertValueWithCharacter', { char })\n      await onInsertValueWithCharacter({\n        char,\n        json,\n        selection,\n        readOnly,\n        parser,\n        onPatch,\n        onReplaceJson\n      })\n    }\n  }\n}\n\ninterface OnInsertValueWithCharacter {\n  char: string\n  json: unknown | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  parser: JSONParser\n  onPatch: OnPatch\n  onReplaceJson: (updatedJson: unknown, afterPatch: AfterPatchCallback) => void\n}\n\nasync function onInsertValueWithCharacter({\n  char,\n  json,\n  selection,\n  readOnly,\n  parser,\n  onPatch,\n  onReplaceJson\n}: OnInsertValueWithCharacter) {\n  if (readOnly) {\n    return\n  }\n\n  // first insert a new value\n  onInsert({\n    insertType: 'value',\n    selectInside: false, // not relevant, we insert a value, not an object or array\n    initialValue: char,\n    json,\n    selection,\n    readOnly,\n    parser,\n    onPatch,\n    onReplaceJson\n  })\n}\n","<script lang=\"ts\">\n  import type { JSONParser } from '$lib/types'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { getText } from '$lib/utils/jsonUtils.js'\n  import { MAX_CHARACTERS_TEXT_PREVIEW } from '$lib/constants.js'\n\n  export let text: string | undefined\n  export let json: unknown | undefined\n  export let indentation: number | string\n  export let parser: JSONParser\n\n  $: content = json !== undefined ? { json } : { text: text || '' }\n  $: truncated = truncate(getText(content, indentation, parser), MAX_CHARACTERS_TEXT_PREVIEW)\n</script>\n\n<div class=\"jse-json-preview\">\n  {truncated}\n</div>\n\n<style src=\"./JSONPreview.scss\"></style>\n","<script lang=\"ts\">\n  import type { MenuButton } from '$lib/types'\n  import Icon from 'svelte-awesome'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let item: MenuButton\n  export let className: string | undefined = undefined\n  export let onRequestClose: () => void\n</script>\n\n<button\n  type=\"button\"\n  class={classnames('jse-context-menu-button', className, item.className)}\n  on:click={(event) => {\n    onRequestClose()\n    item.onClick(event)\n  }}\n  title={item.title}\n  disabled={item.disabled || false}\n>\n  {#if item.icon}\n    <Icon data={item.icon} />\n  {/if}\n  {#if item.text}\n    {item.text}\n  {/if}\n</button>\n\n<style src=\"./ContextMenuButton.scss\"></style>\n","<script lang=\"ts\">\n  import type { MenuDropDownButton } from '$lib/types'\n  import DropdownButton from '../DropdownButton.svelte'\n  import Icon from 'svelte-awesome'\n  import { classnames } from '$lib/utils/cssUtils.js'\n\n  export let item: MenuDropDownButton\n  export let className: string | undefined = undefined\n  export let onRequestClose: () => void\n\n  $: items = item.items.map((item) => ({\n    ...item,\n    onClick: (event: MouseEvent) => {\n      onRequestClose()\n      item.onClick(event)\n    }\n  }))\n</script>\n\n<DropdownButton width={item.width} {items}>\n  <button\n    class={classnames('jse-context-menu-button', className, item.main.className)}\n    type=\"button\"\n    slot=\"defaultItem\"\n    title={item.main.title}\n    on:click={(event) => {\n      onRequestClose()\n      item.main.onClick(event)\n    }}\n    disabled={item.main.disabled || false}\n  >\n    {#if item.main.icon}\n      <Icon data={item.main.icon} />\n    {/if}\n    {item.main.text}\n  </button>\n</DropdownButton>\n\n<style src=\"./ContextMenuDropDownButton.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faCaretDown } from '@fortawesome/free-solid-svg-icons'\n  import { onDestroy, onMount } from 'svelte'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import type { MenuButton } from '$lib/types.js'\n\n  export let items: MenuButton[] = []\n  export let title: string | undefined = undefined\n  export let width = '120px'\n\n  let visible = false\n\n  $: allItemsDisabled = items.every((item) => item.disabled === true)\n\n  function toggleShow() {\n    const wasVisible = visible\n\n    // trigger *after* the handleClick which changes visibility to false\n    setTimeout(() => (visible = !wasVisible))\n  }\n\n  function handleClick() {\n    visible = false\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    if (combo === 'Escape') {\n      event.preventDefault()\n      visible = false\n    }\n  }\n\n  onMount(() => {\n    document.addEventListener('click', handleClick)\n    document.addEventListener('keydown', handleKeyDown)\n  })\n\n  onDestroy(() => {\n    document.removeEventListener('click', handleClick)\n    document.removeEventListener('keydown', handleKeyDown)\n  })\n</script>\n\n<!-- svelte-ignore a11y-click-events-have-key-events -->\n<div role=\"button\" tabindex=\"0\" class=\"jse-dropdown-button\" {title} on:click={handleClick}>\n  <slot name=\"defaultItem\" />\n\n  <button\n    type=\"button\"\n    class=\"jse-open-dropdown\"\n    data-type=\"jse-open-dropdown\"\n    class:jse-visible={visible}\n    on:click={toggleShow}\n    disabled={allItemsDisabled}\n  >\n    <Icon data={faCaretDown} />\n  </button>\n\n  <div class=\"jse-dropdown-items\" class:jse-visible={visible} style=\"width: {width};\">\n    <ul>\n      {#each items as item}\n        <li>\n          <button\n            type=\"button\"\n            on:click={(event) => item.onClick(event)}\n            title={item.title}\n            disabled={item.disabled}\n            class={item.className}\n          >\n            {#if item.icon}\n              <Icon data={item.icon} />\n            {/if}\n            {item.text}\n          </button>\n        </li>\n      {/each}\n    </ul>\n  </div>\n</div>\n\n<style src=\"./DropdownButton.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onMount } from 'svelte'\n  import Icon from 'svelte-awesome'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { faLightbulb } from '@fortawesome/free-regular-svg-icons'\n  import { findNearestElement } from '$lib/utils/domUtils.js'\n  import type { ContextMenuItem, MenuItem } from '$lib/types.js'\n  import {\n    isContextMenuColumn,\n    isContextMenuRow,\n    isMenuButton,\n    isMenuDropDownButton,\n    isMenuLabel,\n    isMenuSeparator\n  } from '$lib/typeguards.js'\n  import ContextMenuButton from './ContextMenuButton.svelte'\n  import ContextMenuDropDownButton from './ContextMenuDropDownButton.svelte'\n\n  export let items: ContextMenuItem[]\n  export let onRequestClose: () => void\n  export let tip: string | undefined\n\n  let refContextMenu: HTMLDivElement\n\n  onMount(() => {\n    const firstEnabledButton = Array.from(refContextMenu.querySelectorAll('button')).find(\n      (button) => !button.disabled\n    )\n\n    if (firstEnabledButton) {\n      firstEnabledButton.focus()\n    }\n  })\n\n  const directionByCombo: Record<string, 'Up' | 'Down' | 'Left' | 'Right'> = {\n    ArrowUp: 'Up',\n    ArrowDown: 'Down',\n    ArrowLeft: 'Left',\n    ArrowRight: 'Right'\n  }\n\n  function handleKeyDown(event: KeyboardEvent & { currentTarget: EventTarget & HTMLDivElement }) {\n    const combo = keyComboFromEvent(event)\n    const direction: 'Up' | 'Down' | 'Left' | 'Right' | undefined = directionByCombo[combo]\n\n    if (direction && event.target) {\n      event.preventDefault()\n\n      const buttons: HTMLButtonElement[] = Array.from(\n        refContextMenu.querySelectorAll('button:not([disabled])')\n      )\n      const nearest = findNearestElement<HTMLButtonElement>({\n        allElements: buttons,\n        currentElement: event.target as unknown as HTMLButtonElement,\n        direction,\n        hasPrio: (element: HTMLButtonElement) => {\n          return element.getAttribute('data-type') !== 'jse-open-dropdown'\n        }\n      })\n      if (nearest) {\n        nearest.focus()\n      }\n    }\n  }\n\n  function unknownMenuItem(item: MenuItem): string {\n    console.error('Unknown type of context menu item', item)\n    return '???'\n  }\n</script>\n\n<div\n  role=\"menu\"\n  tabindex=\"-1\"\n  class=\"jse-contextmenu\"\n  bind:this={refContextMenu}\n  on:keydown={handleKeyDown}\n>\n  {#each items as item}\n    {#if isMenuButton(item)}\n      <ContextMenuButton {item} {onRequestClose} />\n    {:else if isMenuDropDownButton(item)}\n      <ContextMenuDropDownButton {item} {onRequestClose} />\n    {:else if isContextMenuRow(item)}\n      <div class=\"jse-row\">\n        {#each item.items as rowItem}\n          {#if isMenuButton(rowItem)}\n            <ContextMenuButton item={rowItem} {onRequestClose} />\n          {:else if isMenuDropDownButton(rowItem)}\n            <ContextMenuDropDownButton item={rowItem} {onRequestClose} />\n          {:else if isContextMenuColumn(rowItem)}\n            <div class=\"jse-column\">\n              {#each rowItem.items as columnItem}\n                {#if isMenuButton(columnItem)}\n                  <ContextMenuButton className=\"left\" item={columnItem} {onRequestClose} />\n                {:else if isMenuDropDownButton(columnItem)}\n                  <ContextMenuDropDownButton className=\"left\" item={columnItem} {onRequestClose} />\n                {:else if isMenuSeparator(columnItem)}\n                  <div class=\"jse-separator\"></div>\n                {:else if isMenuLabel(columnItem)}\n                  <div class=\"jse-label\">\n                    {columnItem.text}\n                  </div>\n                {:else}\n                  {unknownMenuItem(columnItem)}\n                {/if}\n              {/each}\n            </div>\n          {:else if isMenuSeparator(rowItem)}\n            <div class=\"jse-separator\"></div>\n          {:else}\n            {unknownMenuItem(rowItem)}\n          {/if}\n        {/each}\n      </div>\n    {:else if isMenuSeparator(item)}\n      <div class=\"jse-separator\"></div>\n    {:else}\n      {unknownMenuItem(item)}\n    {/if}\n  {/each}\n\n  {#if tip}\n    <div class=\"jse-row\">\n      <div class=\"jse-tip\">\n        <div class=\"jse-tip-icon\">\n          <Icon data={faLightbulb} />\n        </div>\n        <div class=\"jse-tip-text\">{tip}</div>\n      </div>\n    </div>\n  {/if}\n</div>\n\n<style src=\"./ContextMenu.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer } from 'immutable-json-patch'\n  import { getValueClass } from '$lib/plugins/value/components/utils/getValueClass.js'\n  import { type JSONParser, type JSONSelection, Mode, type OnPatch } from '$lib/types.js'\n  import { isValueSelection } from '$lib/logic/selection.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let mode: Mode\n  export let parser: JSONParser\n  export let readOnly: boolean\n  export let selection: JSONSelection | undefined\n  export let onPatch: OnPatch\n\n  export let options: Array<{ value: unknown; text: string }>\n\n  let refSelect: HTMLSelectElement | undefined\n\n  let bindValue: unknown = value\n  $: bindValue = value\n\n  function applyFocus(selection: JSONSelection | undefined) {\n    if (selection) {\n      if (refSelect) {\n        refSelect.focus()\n      }\n    }\n  }\n\n  $: applyFocus(selection)\n\n  function handleSelect(event: Event) {\n    event.stopPropagation()\n\n    if (readOnly) {\n      return\n    }\n\n    onPatch([\n      {\n        op: 'replace',\n        path: compileJSONPointer(path),\n        value: bindValue\n      }\n    ])\n  }\n\n  function handleMouseDown(event: MouseEvent) {\n    // stop propagation to prevent selecting the whole line\n    event.stopPropagation()\n  }\n</script>\n\n<select\n  class={`jse-enum-value ${getValueClass(bindValue, mode, parser)}`}\n  class:jse-selected={isValueSelection(selection)}\n  bind:value={bindValue}\n  bind:this={refSelect}\n  on:change={handleSelect}\n  on:mousedown={handleMouseDown}\n>\n  {#each options as option}\n    <option value={option.value}>{option.text}</option>\n  {/each}\n</select>\n\n<style src=\"./EnumValue.scss\"></style>\n","import type { JSONPath } from 'immutable-json-patch'\nimport type { JSONSchema, JSONSchemaDefinitions, JSONSchemaEnum } from '$lib/types'\n\n/**\n * Find enum options for given path in a JSONSchema\n */\nexport function getJSONSchemaOptions(\n  schema: JSONSchema,\n  schemaDefinitions: JSONSchemaDefinitions | undefined,\n  path: JSONPath\n): JSONSchemaEnum | undefined {\n  const schemaForPath = findSchema(schema, schemaDefinitions || {}, path)\n\n  return schemaForPath ? findEnum(schemaForPath) : undefined\n}\n\n/**\n * find an enum definition in a JSON schema, as property `enum` or inside\n * one of the schemas composites (`oneOf`, `anyOf`, `allOf`)\n *\n * Source: https://github.com/josdejong/jsoneditor/blob/develop/src/js/Node.js\n */\nexport function findEnum(schema: JSONSchema): JSONSchemaEnum | undefined {\n  if (Array.isArray(schema['enum'])) {\n    return schema['enum']\n  }\n\n  const composite = schema['oneOf'] || schema['anyOf'] || schema['allOf']\n  if (Array.isArray(composite)) {\n    const match = composite.filter((entry) => entry.enum)\n    if (match.length > 0) {\n      return match[0].enum\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Return the part of a JSON schema matching given path.\n *\n * Source: https://github.com/josdejong/jsoneditor/blob/develop/src/js/Node.js\n */\nexport function findSchema(\n  topLevelSchema: JSONSchema,\n  schemaDefinitions: JSONSchemaDefinitions,\n  path: JSONPath,\n  currentSchema = topLevelSchema\n): JSONSchema | undefined {\n  const nextPath = path.slice(1, path.length)\n  const nextKey = path[0]\n\n  let possibleSchemas = [currentSchema]\n  for (const subSchemas of [currentSchema.oneOf, currentSchema.anyOf, currentSchema.allOf]) {\n    if (Array.isArray(subSchemas)) {\n      possibleSchemas = possibleSchemas.concat(subSchemas)\n    }\n  }\n\n  for (const schema of possibleSchemas) {\n    currentSchema = schema\n\n    if ('$ref' in currentSchema && typeof currentSchema.$ref === 'string') {\n      const ref = currentSchema.$ref\n      if (ref in schemaDefinitions) {\n        currentSchema = schemaDefinitions[ref]\n      } else if (ref.startsWith('#/')) {\n        const refPath = ref.substring(2).split('/')\n        currentSchema = topLevelSchema\n        for (const segment of refPath) {\n          if (segment in currentSchema) {\n            currentSchema = currentSchema[segment] as JSONSchema\n          } else {\n            throw Error(`Unable to resolve reference ${ref}`)\n          }\n        }\n      } else if (ref.match(/#\\//g)?.length === 1) {\n        const [schemaUrl, relativePath] = ref.split('#/')\n        if (schemaUrl in schemaDefinitions) {\n          const referencedSchema = schemaDefinitions[schemaUrl]\n          const reference = { $ref: '#/'.concat(relativePath) }\n          const auxNextPath = []\n          auxNextPath.push(nextKey)\n          if (nextPath.length > 0) {\n            auxNextPath.push(...nextPath)\n          }\n          return findSchema(referencedSchema, schemaDefinitions, auxNextPath, reference)\n        } else {\n          throw Error(`Unable to resolve reference ${ref}`)\n        }\n      } else {\n        throw Error(`Unable to resolve reference ${ref}`)\n      }\n    }\n\n    // We have no more path segments to resolve, return the currently found schema\n    // We do this here, after resolving references, in case of the leaf schema beeing a reference\n    if (nextKey === undefined) {\n      return currentSchema\n    }\n\n    if (\n      typeof currentSchema.properties === 'object' &&\n      currentSchema.properties &&\n      nextKey in currentSchema.properties\n    ) {\n      currentSchema = (currentSchema.properties as Record<string, JSONSchema>)[nextKey]\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n\n    if (typeof currentSchema.patternProperties === 'object' && currentSchema.patternProperties) {\n      for (const prop in currentSchema.patternProperties) {\n        if (nextKey.match(prop)) {\n          currentSchema = (currentSchema.patternProperties as Record<string, JSONSchema>)[prop]\n          return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n        }\n      }\n    }\n\n    if (typeof currentSchema.additionalProperties === 'object') {\n      currentSchema = currentSchema.additionalProperties as JSONSchema\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n\n    if (typeof currentSchema.items === 'object' && currentSchema.items) {\n      currentSchema = currentSchema.items as JSONSchema\n      return findSchema(topLevelSchema, schemaDefinitions, nextPath, currentSchema)\n    }\n  }\n\n  return undefined\n}\n","import EnumValue from './components/EnumValue.svelte'\nimport { getJSONSchemaOptions } from '$lib/utils/jsonSchemaUtils.js'\nimport type {\n  JSONSchema,\n  JSONSchemaDefinitions,\n  RenderValueComponentDescription,\n  RenderValueProps\n} from '$lib/types'\n\n/**\n * Search the JSON schema for enums defined at given props.path. If found,\n * return an EnumValue renderer. If not found, return null. In that case you\n * have to fallback on the default valueRender function\n */\nexport function renderJSONSchemaEnum(\n  props: RenderValueProps,\n  schema: JSONSchema,\n  schemaDefinitions?: JSONSchemaDefinitions\n): RenderValueComponentDescription[] | undefined {\n  const enumValues = getJSONSchemaOptions(schema, schemaDefinitions, props.path)\n\n  if (enumValues) {\n    const options = enumValues.map((enumValue) => ({\n      value: enumValue,\n      text: enumValue\n    }))\n\n    // make sure the current value is also added as one of the options,\n    // else it would look as if the first option is the current value\n    const optionsWithValue = enumValues.includes(props.value)\n      ? options\n      : [{ value: props.value, text: props.value }].concat(options)\n\n    return [\n      {\n        component: EnumValue,\n        props: {\n          ...props,\n          options: optionsWithValue\n        }\n      }\n    ]\n  }\n\n  return undefined\n}\n","import type Ajv from 'ajv'\nimport type { Options, Schema, ErrorObject } from 'ajv'\nimport AjvDist from 'ajv'\nimport { parsePath } from 'immutable-json-patch'\nimport type { JSONSchema, JSONSchemaDefinitions, ValidationError, Validator } from '$lib/types'\nimport { ValidationSeverity } from '$lib/types.js'\n\nexport interface AjvValidatorOptions {\n  schema: JSONSchema\n  schemaDefinitions?: JSONSchemaDefinitions\n  ajvOptions?: Options\n  onCreateAjv?: (ajv: Ajv) => Ajv | void\n}\n\n/**\n * Create a JSON Schema validator powered by Ajv.\n * @param options\n * @property schema\n *                    The JSON schema to validate (required).\n * @property [schemaDefinitions=undefined]\n *                    An object containing JSON Schema definitions\n *                    which can be referenced using $ref\n * @property [ajvOptions=undefined]\n *                    Optional extra options for Ajv\n * @property [onCreateAjv=undefined]\n *                    An optional callback function allowing to apply additional\n *                    configuration on the provided Ajv instance, or return\n *                    your own Ajv instance and ignore the provided one.\n * @return Returns a validation function\n */\nexport function createAjvValidator(options: AjvValidatorOptions): Validator {\n  let ajv = createAjvInstance(options)\n  if (options.onCreateAjv !== undefined) {\n    ajv = options.onCreateAjv(ajv) || ajv\n\n    // validate whether ajv is configured correctly (this is needed to enhance error messages)\n    if (ajv.opts.verbose === false) {\n      throw new Error('Ajv must be configured with the option verbose=true')\n    }\n  }\n\n  const validateAjv = ajv.compile(options.schema as Schema)\n\n  if (validateAjv.errors) {\n    throw validateAjv.errors[0]\n  }\n\n  return function validate(json: unknown): ValidationError[] {\n    validateAjv(json)\n    const ajvErrors = validateAjv.errors || []\n\n    return ajvErrors.map(improveAjvError).map((error) => normalizeAjvError(json, error))\n  }\n}\n\nfunction createAjvInstance(options: AjvValidatorOptions): Ajv {\n  const { schemaDefinitions, ajvOptions } = options\n\n  const ajv = new AjvDist({\n    allErrors: true,\n    verbose: true,\n    $data: true,\n    ...ajvOptions\n  })\n\n  if (schemaDefinitions) {\n    Object.keys(schemaDefinitions).forEach((ref) => {\n      ajv.addSchema(schemaDefinitions[ref] as Schema, ref)\n    })\n  }\n\n  return ajv\n}\n\nfunction normalizeAjvError(json: unknown, ajvError: ErrorObject): ValidationError {\n  return {\n    path: parsePath(json, ajvError.instancePath),\n    message: ajvError.message || 'Unknown error',\n    severity: ValidationSeverity.warning\n  }\n}\n\n/**\n * Improve the error message of a JSON schema error,\n * for example list the available values of an enum.\n */\nfunction improveAjvError(ajvError: ErrorObject): ErrorObject {\n  let message: string | undefined = undefined\n\n  if (ajvError.keyword === 'enum' && Array.isArray(ajvError.schema)) {\n    let enums = ajvError.schema\n    if (enums) {\n      enums = enums.map((value) => JSON.stringify(value))\n\n      if (enums.length > 5) {\n        const more = ['(' + (enums.length - 5) + ' more...)']\n        enums = enums.slice(0, 5)\n        enums.push(more)\n      }\n      message = 'should be equal to one of: ' + enums.join(', ')\n    }\n  }\n\n  if (ajvError.keyword === 'additionalProperties') {\n    message = 'should NOT have additional property: ' + ajvError.params.additionalProperty\n  }\n\n  return message ? { ...ajvError, message } : ajvError\n}\n","import jmespath from 'jmespath'\nimport type { JSONPath } from 'immutable-json-patch'\nimport { getIn } from 'immutable-json-patch'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { JSONParser, QueryLanguage, QueryLanguageOptions } from '$lib/types'\nimport { isEqualParser } from '$lib/utils/jsonUtils.js'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://jmespath.org\" target=\"_blank\" rel=\"noopener noreferrer\">JMESPath</a> query \n  to filter, sort, or transform the JSON data.\n To learn JMESPath, go to <a href=\"https://jmespath.org/tutorial.html\" target=\"_blank\" rel=\"noopener noreferrer\">the interactive tutorial</a>.\n</p>\n`\n\nexport const jmespathQueryLanguage: QueryLanguage = {\n  id: 'jmespath',\n  name: 'JMESPath',\n  description: description,\n  createQuery,\n  executeQuery\n}\n\n/**\n * Build a JMESPath query based on query options coming from the wizard\n * @param json   The JSON document for which to build the query.\n *                      Used for context information like determining\n *                      the type of values (string or number)\n * @param queryOptions\n * @return Returns a query (as string)\n */\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { sort, filter, projection } = queryOptions\n  let query = ''\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    const examplePath = ['0'].concat(filter.path)\n    const exampleValue = getIn(json, examplePath)\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof exampleValue === 'string' && filterValue !== null && filterValue !== undefined\n        ? `\"${filter.value}\"`\n        : filterValue\n\n    query +=\n      '[? ' +\n      stringifyPathForJmespath(filter.path) +\n      ' ' +\n      filter.relation +\n      ' ' +\n      '`' +\n      filterValueStr +\n      '`' +\n      ']'\n  } else {\n    query += Array.isArray(json) ? '[*]' : '@'\n  }\n\n  if (sort && sort.path && sort.direction) {\n    if (sort.direction === 'desc') {\n      query += ' | reverse(sort_by(@, &' + stringifyPathForJmespath(sort.path) + '))'\n    } else {\n      query += ' | sort_by(@, &' + stringifyPathForJmespath(sort.path) + ')'\n    }\n  }\n\n  if (projection && projection.paths) {\n    if (query[query.length - 1] !== ']') {\n      query += ' | [*]'\n    }\n\n    if (projection.paths.length === 1) {\n      const path = projection.paths[0]\n\n      query +=\n        path.length === 0\n          ? '' // edge case, selecting projection of the item root\n          : '.' + stringifyPathForJmespath(path)\n    } else if (projection.paths.length > 1) {\n      query +=\n        '.{' +\n        projection.paths\n          .map((path) => {\n            const name = path[path.length - 1]\n            return stringifyProp(name) + ': ' + stringifyPathForJmespath(path)\n          })\n          .join(', ') +\n        '}'\n    } else {\n      // values.length === 0\n      // ignore\n    }\n  }\n\n  return query\n}\n\n/**\n * Execute a JMESPath query, returns the transformed JSON\n */\nfunction executeQuery(json: unknown, query: string, parser: JSONParser): unknown {\n  // JMESPath cannot handle non-native JSON data types like LosslessNumber\n\n  function stringifyAndParse(json: unknown) {\n    const text = parser.stringify(json)\n    return text !== undefined ? JSON.parse(text) : undefined\n  }\n\n  const preprocessedJson = isEqualParser(parser, JSON) ? json : stringifyAndParse(json)\n\n  return jmespath.search(preprocessedJson, query)\n}\n\n// TODO: unit test stringifyPathForJmespath\n// TODO: Isn't there a helper function exposed by the JMESPath library?\nexport function stringifyPathForJmespath(path: JSONPath): string {\n  if (path.length === 0) {\n    return '@'\n  }\n\n  const str = path\n    .map((prop) => {\n      if (typeof prop === 'number') {\n        return '[' + prop + ']'\n      } else {\n        return '.' + stringifyProp(String(prop))\n      }\n    })\n    .join('')\n\n  return str[0] === '.'\n    ? str.slice(1) // remove first dot\n    : str\n}\n\nfunction stringifyProp(prop: string): string {\n  return prop.match(/^[A-Za-z\\d_$]+$/) ? prop : JSON.stringify(prop)\n}\n","import { JSONPath as JSONPathPlus } from 'jsonpath-plus'\nimport { parseString } from '$lib/utils/stringUtils'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types'\nimport type { JSONPath } from 'immutable-json-patch'\n\nconst description = `\n<p>\n  Enter a <a href=\"https://github.com/JSONPath-Plus/JSONPath\" target=\"_blank\" \n  rel=\"noopener noreferrer\"><code>JSONPath</code></a> expression to filter, sort, or transform the data.\n</p>`\n\nexport const jsonpathQueryLanguage: QueryLanguage = {\n  id: 'jsonpath',\n  name: 'JSONPath',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(_json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  let expression = '$'\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    const filterValue = parseString(filter.value)\n    const filterValueStr = JSON.stringify(filterValue)\n\n    expression += `[?(@${pathToString(filter.path)} ${filter.relation} ${filterValueStr})]`\n  }\n\n  if (sort && sort.path && sort.direction) {\n    throw new Error('Sorting is not supported by JSONPath. Please clear the sorting fields')\n  }\n\n  if (projection && projection.paths) {\n    if (projection.paths.length > 1) {\n      throw new Error(\n        'Picking multiple fields is not supported by JSONPath. Please select only one field'\n      )\n    }\n\n    if (!expression.endsWith(']')) {\n      expression += '[*]'\n    }\n    expression += `${pathToString(projection.paths[0])}`.replace(/^\\.\\.\\./, '..')\n  }\n\n  return expression\n}\n\nfunction executeQuery(json: unknown, path: string): unknown {\n  const output = JSONPathPlus({ json: json as JSON, path })\n  return output !== undefined ? output : null\n}\n\nfunction pathToString(path: JSONPath): JSONPath | string {\n  const lettersOnlyRegex = /^[A-z]+$/\n\n  return path\n    .map((prop) => {\n      return lettersOnlyRegex.test(prop) ? `.${prop}` : JSON.stringify([prop])\n    })\n    .join('')\n}\n","import * as _ from 'lodash-es'\nimport { last } from 'lodash-es'\nimport { createLodashPropertySelector, createPropertySelector } from '$lib/utils/pathUtils.js'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport { isInteger } from '$lib/utils/typeUtils.js'\n\nconst description = `\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n  You can use <a href=\"https://lodash.com\" target=\"_blank\" rel=\"noopener noreferrer\">Lodash</a>\n  functions like <code>_.map</code>, <code>_.filter</code>,\n  <code>_.orderBy</code>, <code>_.sortBy</code>, <code>_.groupBy</code>,\n  <code>_.pick</code>, <code>_.uniq</code>, <code>_.get</code>, etcetera.\n</p>\n`\n\nexport const lodashQueryLanguage: QueryLanguage = {\n  id: 'lodash',\n  name: 'Lodash',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryParts = ['  return _.chain(data)\\n']\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    // Note that the comparisons embrace type coercion,\n    // so a filter value like '5' (text) will match numbers like 5 too.\n    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`\n\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof filterValue === 'string'\n        ? `'${filter.value}'`\n        : isInteger(filter.value) && !Number.isSafeInteger(filterValue)\n          ? `${filter.value}n` // bigint\n          : filter.value\n\n    queryParts.push(`    .filter(${actualValueGetter} ${filter.relation} ${filterValueStr})\\n`)\n  }\n\n  if (sort && sort.path && sort.direction) {\n    queryParts.push(\n      `    .orderBy([${createLodashPropertySelector(sort.path)}], ['${sort.direction}'])\\n`\n    )\n  }\n\n  if (projection && projection.paths) {\n    // It is possible to make a util function \"pickFlat\"\n    // and use that when building the query to make it more readable.\n    if (projection.paths.length > 1) {\n      // Note that we do not use _.pick() here because this function doesn't flatten the results\n      const paths = projection.paths.map((path) => {\n        const name = last(path) || 'item' // 'item' in case of having selected the item root\n        return `      ${JSON.stringify(name)}: item${createPropertySelector(path)}`\n      })\n      queryParts.push(`    .map(item => ({\\n${paths.join(',\\n')}\\n    }))\\n`)\n    } else {\n      const path = projection.paths[0]\n      queryParts.push(`    .map(item => item${createPropertySelector(path)})\\n`)\n    }\n  }\n\n  queryParts.push('    .value()\\n')\n\n  return `function query (data) {\\n${queryParts.join('')}}`\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  validate(query)\n\n  // TODO: only import the most relevant subset of lodash instead of the full library?\n  const queryFn = new Function(\n    '_',\n    '\"use strict\";\\n' +\n      '\\n' +\n      query +\n      '\\n' +\n      '\\n' +\n      'if (typeof query !== \"function\") {\\n' +\n      '  throw new Error(\"Cannot execute query: expecting a function named \\'query\\' but is undefined\")\\n' +\n      '}\\n' +\n      '\\n' +\n      'return query;\\n'\n  )(_)\n\n  const output = queryFn(json)\n  return output !== undefined ? output : null\n}\n\nfunction validate(query: string) {\n  // It is very common to forget to end a lodash chain with .value()\n  // This lets the JSON Editor crash though.\n  // Therefore, we do a simple validation (not a guarantee)\n  const chainCount = query.match(/_\\.chain\\(/g)?.length\n  const valueCount = query.match(/\\.value\\(\\)/g)?.length\n\n  if (chainCount !== valueCount) {\n    throw new Error('Cannot execute query: Lodash _.chain(...) must end with .value()')\n  }\n}\n","import { createPropertySelector } from '$lib/utils/pathUtils.js'\nimport { parseString } from '$lib/utils/stringUtils.js'\nimport type { QueryLanguage, QueryLanguageOptions } from '$lib/types.js'\nimport { isInteger } from '$lib/utils/typeUtils.js'\n\nconst description = `\n<p>\n  Enter a JavaScript function to filter, sort, or transform the data.\n</p>\n`\n\nexport const javascriptQueryLanguage: QueryLanguage = {\n  id: 'javascript',\n  name: 'JavaScript',\n  description,\n  createQuery,\n  executeQuery\n}\n\nfunction createQuery(json: unknown, queryOptions: QueryLanguageOptions): string {\n  const { filter, sort, projection } = queryOptions\n  const queryParts = ['  return data\\n']\n\n  if (filter && filter.path && filter.relation && filter.value) {\n    // Note that the comparisons embrace type coercion,\n    // so a filter value like '5' (text) will match numbers like 5 too.\n    const actualValueGetter = `item => item${createPropertySelector(filter.path)}`\n\n    const filterValue = parseString(filter.value)\n    const filterValueStr =\n      typeof filterValue === 'string'\n        ? `'${filter.value}'`\n        : isInteger(filter.value) && !Number.isSafeInteger(filterValue)\n          ? `${filter.value}n` // bigint\n          : filter.value\n\n    queryParts.push(`    .filter(${actualValueGetter} ${filter.relation} ${filterValueStr})\\n`)\n  }\n\n  if (sort && sort.path && sort.direction) {\n    if (sort.direction === 'desc') {\n      queryParts.push(\n        `    .slice()\\n` +\n          `    .sort((a, b) => {\\n` +\n          `      // sort descending\\n` +\n          `      const valueA = a${createPropertySelector(sort.path)}\\n` +\n          `      const valueB = b${createPropertySelector(sort.path)}\\n` +\n          `      return valueA > valueB ? -1 : valueA < valueB ? 1 : 0\\n` +\n          `    })\\n`\n      )\n    } else {\n      // sort direction 'asc'\n      queryParts.push(\n        `    .slice()\\n` +\n          `    .sort((a, b) => {\\n` +\n          `      // sort ascending\\n` +\n          `      const valueA = a${createPropertySelector(sort.path)}\\n` +\n          `      const valueB = b${createPropertySelector(sort.path)}\\n` +\n          `      return valueA > valueB ? 1 : valueA < valueB ? -1 : 0\\n` +\n          `    })\\n`\n      )\n    }\n  }\n\n  if (projection && projection.paths) {\n    // It is possible to make a util function \"pickFlat\"\n    // and use that when building the query to make it more readable.\n    if (projection.paths.length > 1) {\n      const paths = projection.paths.map((path) => {\n        const name = path[path.length - 1] || 'item' // 'item' in case of having selected the item root\n        const item = `item${createPropertySelector(path)}`\n        return `      ${JSON.stringify(name)}: ${item}`\n      })\n\n      queryParts.push(`    .map(item => ({\\n${paths.join(',\\n')}})\\n    )\\n`)\n    } else {\n      const item = `item${createPropertySelector(projection.paths[0])}`\n\n      queryParts.push(`    .map(item => ${item})\\n`)\n    }\n  }\n\n  return `function query (data) {\\n${queryParts.join('')}}`\n}\n\nfunction executeQuery(json: unknown, query: string): unknown {\n  // TODO: only import the most relevant subset of lodash instead of the full library?\n  const queryFn = new Function(\n    '\"use strict\";\\n' +\n      '\\n' +\n      query +\n      '\\n' +\n      '\\n' +\n      'if (typeof query !== \"function\") {\\n' +\n      '  throw new Error(\"Cannot execute query: expecting a function named \\'query\\' but is undefined\")\\n' +\n      '}\\n' +\n      '\\n' +\n      'return query;\\n'\n  )()\n\n  const output = queryFn(json)\n  return output !== undefined ? output : null\n}\n","// source: https://github.com/sveltejs/svelte/issues/7583\n\nlet observer: ResizeObserver\nlet callbacks: WeakMap<Element, (element: Element) => void>\n\n/**\n * Example usage:\n *\n *   <script lang=\"ts\">\n *      let clientWidth = 0\n *   </script>\n *\n *   <div use:resizeObserver={element => clientWidth = element.clientWidth}>\n *      My width is: {clientWidth}\n *   </div>\n */\nexport function resizeObserver(element: Element, onResize: (element: Element) => void) {\n  if (!observer) {\n    callbacks = new WeakMap()\n    observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const onResize = callbacks.get(entry.target)\n        if (onResize) {\n          onResize(entry.target)\n        }\n      }\n    })\n  }\n\n  callbacks.set(element, onResize)\n  observer.observe(element)\n\n  return {\n    destroy: () => {\n      callbacks.delete(element)\n      observer.unobserve(element)\n    }\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { createAutoScrollHandler } from '../../controls/createAutoScrollHandler.js'\n  import { faCheck, faCode, faWrench } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import {\n    compileJSONPointer,\n    existsIn,\n    getIn,\n    immutableJSONPatch,\n    type JSONPatchDocument,\n    type JSONPath\n  } from 'immutable-json-patch'\n  import { jsonrepair } from 'jsonrepair'\n  import { initial, isEmpty, isEqual, noop, uniqueId } from 'lodash-es'\n  import { getContext, onDestroy, onMount, tick } from 'svelte'\n  import { createJump } from '$lib/assets/jump.js/src/jump.js'\n  import {\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH,\n    SCROLL_DURATION,\n    SEARCH_BOX_HEIGHT\n  } from '$lib/constants.js'\n  import {\n    collapsePath,\n    createDocumentState,\n    documentStatePatch,\n    expandAll,\n    expandMinimal,\n    expandNone,\n    expandPath,\n    expandSection,\n    expandSelf,\n    expandSmart,\n    expandSmartIfCollapsed,\n    getEnforceString,\n    setInDocumentState,\n    syncDocumentState\n  } from '$lib/logic/documentState.js'\n  import { duplicate, extract, revertJSONPatchWithMoveOperations } from '$lib/logic/operations.js'\n  import {\n    canConvert,\n    createAfterSelection,\n    createEditKeySelection,\n    createEditValueSelection,\n    createInsideSelection,\n    createSelectionFromOperations,\n    createValueSelection,\n    findRootPath,\n    getAnchorPath,\n    getEndPath,\n    getFocusPath,\n    getInitialSelection,\n    getSelectionDown,\n    getSelectionLeft,\n    getSelectionNextInside,\n    getSelectionPaths,\n    getSelectionRight,\n    getSelectionUp,\n    hasSelectionContents,\n    isAfterSelection,\n    isEditingSelection,\n    isInsideSelection,\n    isJSONSelection,\n    isKeySelection,\n    isMultiSelection,\n    isMultiSelectionWithOneItem,\n    isSelectionInsidePath,\n    isValueSelection,\n    removeEditModeFromSelection,\n    selectAll\n  } from '$lib/logic/selection.js'\n  import { toRecursiveValidationErrors, validateJSON } from '$lib/logic/validation.js'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    encodeDataPath,\n    findParentWithNodeName,\n    getWindow,\n    isChildOf,\n    isChildOfNodeName\n  } from '$lib/utils/domUtils.js'\n  import {\n    convertValue,\n    isJSONContent,\n    isTextContent,\n    normalizeJsonParseError,\n    parseAndRepair,\n    parsePartialJson,\n    repairPartialJson\n  } from '$lib/utils/jsonUtils.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { isObjectOrArray, isUrl, stringConvert } from '$lib/utils/typeUtils.js'\n  import { createFocusTracker } from '../../controls/createFocusTracker.js'\n  import Message from '../../controls/Message.svelte'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import CopyPasteModal from '../../modals/CopyPasteModal.svelte'\n  import JSONRepairModal from '../../modals/JSONRepairModal.svelte'\n  import JSONNode from './JSONNode.svelte'\n  import TreeMenu from './menu/TreeMenu.svelte'\n  import Welcome from './Welcome.svelte'\n  import NavigationBar from '../../controls/navigationBar/NavigationBar.svelte'\n  import SearchBox from '../../controls/SearchBox.svelte'\n  import type {\n    AbsolutePopupContext,\n    AbsolutePopupOptions,\n    AfterPatchCallback,\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    ConvertType,\n    DocumentState,\n    History,\n    HistoryItem,\n    InsertType,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    JSONRepairModalProps,\n    JSONSelection,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRedo,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    OnUndo,\n    ParseError,\n    PastedJson,\n    SearchResultDetails,\n    SearchResults,\n    Section,\n    TransformModalOptions,\n    TreeModeContext,\n    ValidationError,\n    ValidationErrors,\n    Validator,\n    ValueNormalization\n  } from '$lib/types'\n  import { Mode, ValidationSeverity } from '$lib/types.js'\n  import memoizeOne from 'memoize-one'\n  import { measure } from '$lib/utils/timeUtils.js'\n  import {\n    onCopy,\n    onCut,\n    onInsert,\n    onInsertCharacter,\n    onPaste,\n    onRemove\n  } from '$lib/logic/actions.js'\n  import JSONPreview from '../../controls/JSONPreview.svelte'\n  import ContextMenu from '../../controls/contextmenu/ContextMenu.svelte'\n  import createTreeContextMenuItems from './contextmenu/createTreeContextMenuItems'\n  import { toRecursiveSearchResults as toRecursiveSearchResults } from 'svelte-jsoneditor/logic/search.js'\n  import { isTreeHistoryItem } from 'svelte-jsoneditor'\n\n  const debug = createDebug('jsoneditor:TreeMode')\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  let refContents: HTMLDivElement | undefined\n  let refHiddenInput: HTMLInputElement\n  let refJsonEditor: HTMLDivElement\n  let hasFocus = false\n  const jump = createJump()\n\n  export let readOnly: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let history: History<HistoryItem>\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n  export let indentation: number | string\n  export let onError: OnError\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onUndo: OnUndo\n  export let onRedo: OnRedo\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onClassName: OnClassName | undefined\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n  let copyPasteModalOpen = false\n  let jsonRepairModalProps: JSONRepairModalProps | undefined = undefined\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(refJsonEditor),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(refJsonEditor),\n    onFocus: () => {\n      hasFocus = true\n      if (onFocus) {\n        onFocus()\n      }\n    },\n    onBlur: () => {\n      hasFocus = false\n      if (onBlur) {\n        onBlur()\n      }\n    }\n  })\n\n  let json: unknown | undefined\n  let text: string | undefined\n  let parseError: ParseError | undefined = undefined\n\n  let documentStateInitialized = false\n  let documentState: DocumentState | undefined = createDocumentState({ json })\n  let selection: JSONSelection | undefined = isJSONSelection(externalSelection)\n    ? externalSelection\n    : undefined\n\n  onMount(() => {\n    if (selection) {\n      const path = getFocusPath(selection)\n      documentState = expandPath(json, documentState, path, expandNone)\n      setTimeout(() => scrollIntoView(path))\n    }\n  })\n\n  function handleSelect(updatedSelection: JSONSelection | undefined) {\n    selection = updatedSelection\n  }\n\n  function emitOnSelect(updatedSelection: JSONSelection | undefined) {\n    if (!isEqual(updatedSelection, externalSelection)) {\n      debug('onSelect', updatedSelection)\n      onSelect(updatedSelection)\n    }\n  }\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: emitOnSelect(selection)\n\n  let normalization: ValueNormalization\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters,\n    escapeUnicodeCharacters\n  })\n\n  let pastedJson: PastedJson | undefined\n\n  let searchResultDetails: SearchResultDetails | undefined\n  let searchResults: SearchResults | undefined\n  let showSearch = false\n  let showReplace = false\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applySearchBoxSpacing(showSearch)\n\n  function applySearchBoxSpacing(showSearch: boolean) {\n    if (!refContents) {\n      return\n    }\n\n    if (showSearch && refContents.scrollTop === 0) {\n      refContents.style.overflowAnchor = 'none'\n      refContents.scrollTop += SEARCH_BOX_HEIGHT\n      setTimeout(() => {\n        if (refContents) {\n          refContents.style.overflowAnchor = ''\n        }\n      })\n    }\n  }\n\n  function handleSearch(result: SearchResultDetails | undefined) {\n    searchResultDetails = result\n    searchResults = searchResultDetails\n      ? toRecursiveSearchResults(json, searchResultDetails.items)\n      : undefined\n  }\n\n  async function handleFocusSearch(path: JSONPath) {\n    documentState = expandPath(json, documentState, path, expandNone)\n    await scrollTo(path)\n  }\n\n  function handleCloseSearch() {\n    showSearch = false\n    showReplace = false\n    focus()\n  }\n\n  function handleSelectValidationError(error: ValidationError) {\n    debug('select validation error', error)\n\n    selection = createValueSelection(error.path)\n    scrollTo(error.path)\n  }\n\n  export function expand(path: JSONPath, callback: OnExpand = expandSelf) {\n    debug('expand')\n\n    documentState = expandPath(json, documentState, path, callback)\n  }\n\n  export function collapse(path: JSONPath, recursive: boolean) {\n    documentState = collapsePath(json, documentState, path, recursive)\n\n    if (selection) {\n      // check whether the selection is still visible and not collapsed\n      if (isSelectionInsidePath(selection, path)) {\n        // remove selection when not visible anymore\n        selection = undefined\n      }\n    }\n  }\n\n  // two-way binding of externalContent and internal json and text (\n  // when receiving an updated prop, we have to update state for example\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyExternalContent(externalContent)\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyExternalSelection(externalSelection)\n\n  let textIsRepaired = false\n\n  let validationErrorList: ValidationError[] = []\n  let validationErrors: ValidationErrors | undefined\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: updateValidationErrors(json, validator, parser, validationParser)\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidate = memoizeOne(validateJSON)\n\n  function updateValidationErrors(\n    json: unknown,\n    validator: Validator | undefined,\n    parser: JSONParser,\n    validationParser: JSONParser\n  ) {\n    measure(\n      () => {\n        let newValidationErrorList: ValidationError[]\n        try {\n          newValidationErrorList = memoizedValidate(json, validator, parser, validationParser)\n        } catch (err) {\n          newValidationErrorList = [\n            {\n              path: [],\n              message: 'Failed to validate: ' + (err as Error).message,\n              severity: ValidationSeverity.warning\n            }\n          ]\n        }\n\n        if (!isEqual(newValidationErrorList, validationErrorList)) {\n          debug('validationErrors changed:', newValidationErrorList)\n          validationErrorList = newValidationErrorList\n          validationErrors = toRecursiveValidationErrors(json, validationErrorList)\n        }\n      },\n      (duration) => debug(`validationErrors updated in ${duration} ms`)\n    )\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate')\n\n    if (parseError) {\n      return {\n        parseError,\n        isRepairable: false // not applicable, if repairable, we will not have a parseError\n      }\n    }\n\n    // make sure the validation results are up-to-date\n    // normally, they are only updated on the next tick after the json is changed\n    updateValidationErrors(json, validator, parser, validationParser)\n    return !isEmpty(validationErrorList) ? { validationErrors: validationErrorList } : undefined\n  }\n\n  export function getJson() {\n    return json\n  }\n\n  function getDocumentState(): DocumentState | undefined {\n    return documentState\n  }\n\n  function getSelection(): JSONSelection | undefined {\n    return selection\n  }\n\n  function applyExternalContent(updatedContent: Content) {\n    debug('applyExternalContent', { updatedContent })\n\n    if (isJSONContent(updatedContent)) {\n      applyExternalJson(updatedContent.json)\n    } else if (isTextContent(updatedContent)) {\n      applyExternalText(updatedContent.text)\n    }\n  }\n\n  function applyExternalJson(updatedJson: unknown | undefined) {\n    if (updatedJson === undefined) {\n      return\n    }\n\n    // TODO: this is inefficient. Make an optional flag promising that the updates are immutable so we don't have to do a deep equality check? First do some profiling!\n    const isChanged = !isEqual(json, updatedJson)\n\n    debug('update external json', { isChanged, currentlyText: json === undefined })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    json = updatedJson\n    documentState = syncDocumentState(updatedJson, documentState)\n    expandWhenNotInitialized(json)\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalText(updatedText: string | undefined) {\n    if (updatedText === undefined || isJSONContent(externalContent)) {\n      return\n    }\n\n    const isChanged = updatedText !== text\n\n    debug('update external text', { isChanged })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = syncDocumentState(json, documentState)\n      expandWhenNotInitialized(json)\n      text = updatedText\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = syncDocumentState(json, documentState)\n        expandWhenNotInitialized(json)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n        clearSelectionWhenNotExisting(json)\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = undefined\n        text = externalContent['text']\n        textIsRepaired = false\n        parseError =\n          text !== undefined && text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (isEqual(selection, externalSelection)) {\n      return\n    }\n\n    debug('applyExternalSelection', { selection, externalSelection })\n\n    if (isJSONSelection(externalSelection)) {\n      selection = externalSelection\n    }\n  }\n\n  function expandWhenNotInitialized(json: unknown) {\n    if (!documentStateInitialized) {\n      documentStateInitialized = true\n      documentState = expandSmart(json, documentState, [])\n    }\n  }\n\n  function clearSelectionWhenNotExisting(json: unknown) {\n    if (!selection) {\n      return\n    }\n\n    if (existsIn(json, getAnchorPath(selection)) && existsIn(json, getFocusPath(selection))) {\n      return\n    }\n\n    debug('clearing selection: path does not exist anymore', selection)\n    selection = getInitialSelection(json, documentState)\n  }\n\n  interface PreviousState {\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    textIsRepaired: boolean\n  }\n\n  function addHistoryItem(previous: PreviousState) {\n    if (previous.json === undefined && previous.text === undefined) {\n      // initialization -> do not create a history item\n      return\n    }\n\n    const canPatch = json !== undefined && previous.json !== undefined\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: previous.json }] : undefined,\n        json: previous.json,\n        text: previous.text,\n        documentState: previous.documentState,\n        textIsRepaired: previous.textIsRepaired,\n        selection: removeEditModeFromSelection(previous.selection),\n        sortedColumn: undefined\n      },\n      redo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: json }] : undefined,\n        json,\n        text,\n        documentState,\n        textIsRepaired,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn: undefined\n      }\n    })\n  }\n\n  function createDefaultSelection() {\n    debug('createDefaultSelection')\n\n    selection = createValueSelection([])\n  }\n\n  export function patch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('patch', operations, afterPatch)\n\n    if (json === undefined) {\n      throw new Error('Cannot apply patch: no JSON')\n    }\n\n    const previousJson = json\n    const previousState = {\n      json: undefined, // not needed: we use patch to reconstruct the json\n      text,\n      documentState,\n      selection: removeEditModeFromSelection(selection),\n      textIsRepaired,\n      sortedColumn: undefined\n    }\n\n    // execute the patch operations\n    const undo: JSONPatchDocument = revertJSONPatchWithMoveOperations(\n      json,\n      operations\n    ) as JSONPatchDocument\n    const patched = documentStatePatch(json, documentState, operations)\n\n    // update the selection based on the operations\n    const updatedSelection = createSelectionFromOperations(json, operations) ?? selection\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(patched.json, patched.documentState, updatedSelection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : patched.json\n    documentState = callback?.state !== undefined ? callback.state : patched.documentState\n    selection = callback?.selection !== undefined ? callback.selection : updatedSelection\n    text = undefined\n    textIsRepaired = false\n    pastedJson = undefined\n    parseError = undefined\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: undo,\n        ...previousState\n      },\n      redo: {\n        patch: operations,\n        json: undefined, // not needed, we use patch to reconstruct\n        text,\n        documentState,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn: undefined,\n        textIsRepaired\n      }\n    })\n\n    return {\n      json,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handleEditKey() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    selection = createEditKeySelection(getFocusPath(selection))\n  }\n\n  function handleEditValue() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const value = getIn(json, path)\n    if (isObjectOrArray(value)) {\n      openJSONEditorModal(path, value)\n    } else {\n      selection = createEditValueSelection(path)\n    }\n  }\n\n  function handleToggleEnforceString() {\n    if (readOnly || !isValueSelection(selection)) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const pointer = compileJSONPointer(path)\n    const value = getIn(json, path)\n    const enforceString = !getEnforceString(json, documentState, path)\n    const updatedValue = enforceString ? String(value) : stringConvert(String(value), parser)\n\n    debug('handleToggleEnforceString', { enforceString, value, updatedValue })\n\n    handlePatch(\n      [\n        {\n          op: 'replace',\n          path: pointer,\n          value: updatedValue\n        }\n      ],\n      (_, patchedState) => {\n        return {\n          state: setInDocumentState(json, patchedState, path, { type: 'value', enforceString })\n        }\n      }\n    )\n  }\n\n  export function acceptAutoRepair(): Content {\n    if (textIsRepaired && json !== undefined) {\n      handleReplaceJson(json)\n    }\n\n    return json !== undefined ? { json } : { text: text || '' }\n  }\n\n  async function handleCut(indent = true) {\n    await onCut({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      readOnly,\n      parser,\n      onPatch: handlePatch\n    })\n  }\n\n  async function handleCopy(indent = true) {\n    if (json === undefined) {\n      return\n    }\n\n    await onCopy({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      parser\n    })\n  }\n\n  function handlePaste(event: ClipboardEvent) {\n    event.preventDefault()\n\n    const clipboardText = event.clipboardData?.getData('text/plain')\n\n    _paste(clipboardText)\n  }\n\n  async function handlePasteFromMenu() {\n    try {\n      const clipboardText = await navigator.clipboard.readText()\n\n      _paste(clipboardText)\n    } catch (err) {\n      console.error(err)\n\n      copyPasteModalOpen = true\n    }\n  }\n\n  function _paste(clipboardText: string | undefined) {\n    if (clipboardText === undefined) {\n      return\n    }\n\n    onPaste({\n      clipboardText,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onChangeText: handleChangeText,\n      openRepairModal\n    })\n  }\n\n  function openRepairModal(text: string, onApply: (repairedText: string) => void) {\n    jsonRepairModalProps = {\n      text,\n      onParse: (text) => parsePartialJson(text, (t) => parseAndRepair(t, parser)),\n      onRepair: repairPartialJson,\n      onApply,\n      onClose: focus\n    }\n  }\n\n  function handleRemove() {\n    onRemove({\n      json,\n      text,\n      selection,\n      keepSelection: false,\n      readOnly,\n      onChange,\n      onPatch: handlePatch\n    })\n  }\n\n  function handleDuplicate() {\n    if (\n      readOnly ||\n      json === undefined ||\n      !selection ||\n      !hasSelectionContents ||\n      isEmpty(getFocusPath(selection)) // root selected, cannot duplicate\n    ) {\n      return\n    }\n\n    debug('duplicate', { selection })\n\n    const operations = duplicate(json, getSelectionPaths(json, selection))\n\n    handlePatch(operations)\n  }\n\n  function handleExtract() {\n    if (\n      readOnly ||\n      !selection ||\n      (!isMultiSelection(selection) && !isValueSelection(selection)) ||\n      isEmpty(getFocusPath(selection)) // root selected, cannot extract\n    ) {\n      return\n    }\n\n    debug('extract', { selection })\n\n    const operations = extract(json, selection)\n\n    handlePatch(operations, (patchedJson, patchedState) => {\n      if (isObjectOrArray(patchedJson)) {\n        // expand extracted object/array\n        const path: JSONPath = []\n        return {\n          state: expandSmartIfCollapsed(patchedJson, patchedState, path)\n        }\n      }\n\n      return undefined\n    })\n  }\n\n  function handleInsert(insertType: InsertType): void {\n    onInsert({\n      insertType,\n      selectInside: true,\n      initialValue: undefined,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson\n    })\n  }\n\n  function handleInsertFromContextMenu(type: InsertType) {\n    if (isKeySelection(selection)) {\n      // in this case, we do not want to rename the key, but replace the property\n      selection = createValueSelection(selection.path)\n    }\n\n    if (!selection) {\n      selection = getInitialSelection(json, documentState)\n    }\n\n    handleInsert(type)\n  }\n\n  function handleConvert(type: ConvertType) {\n    if (readOnly || !selection) {\n      return\n    }\n\n    if (!canConvert(selection)) {\n      onError(new Error(`Cannot convert current selection to ${type}`))\n      return\n    }\n\n    try {\n      const path = getAnchorPath(selection)\n      const currentValue: unknown = getIn(json, path)\n      const convertedValue = convertValue(\n        currentValue,\n        type as 'value' | 'object' | 'array',\n        parser\n      )\n      if (convertedValue === currentValue) {\n        // no change, do nothing\n        return\n      }\n\n      const operations: JSONPatchDocument = [\n        { op: 'replace', path: compileJSONPointer(path), value: convertedValue }\n      ]\n\n      debug('handleConvert', { selection, path, type, operations })\n\n      handlePatch(operations, (patchedJson, patchedState) => {\n        // expand converted object/array\n        return {\n          state: selection\n            ? expandSmart(patchedJson, patchedState, getFocusPath(selection))\n            : documentState\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleInsertBefore() {\n    if (!selection) {\n      return\n    }\n\n    const selectionBefore = getSelectionUp(json, documentState, selection, false)\n    const parentPath = initial(getFocusPath(selection))\n\n    if (\n      selectionBefore &&\n      !isEmpty(getFocusPath(selectionBefore)) &&\n      isEqual(parentPath, initial(getFocusPath(selectionBefore)))\n    ) {\n      selection = createAfterSelection(getFocusPath(selectionBefore))\n    } else {\n      selection = createInsideSelection(parentPath)\n    }\n\n    debug('insert before', { selection, selectionBefore, parentPath })\n\n    tick().then(() => handleContextMenu())\n  }\n\n  function handleInsertAfter() {\n    if (!selection) {\n      return\n    }\n\n    const path = getEndPath(json, selection)\n\n    debug('insert after', path)\n\n    selection = createAfterSelection(path)\n\n    tick().then(() => handleContextMenu())\n  }\n\n  async function handleInsertCharacter(char: string) {\n    await onInsertCharacter({\n      char,\n      selectInside: true,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson,\n      onSelect: handleSelect\n    })\n  }\n\n  function handleUndo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canUndo) {\n      return\n    }\n\n    const item = history.undo()\n    if (!isTreeHistoryItem(item)) {\n      onUndo(item)\n\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.undo.patch ? immutableJSONPatch(json, item.undo.patch) : item.undo.json\n    documentState = item.undo.documentState\n    selection = item.undo.selection\n    text = item.undo.text\n    textIsRepaired = item.undo.textIsRepaired\n    parseError = undefined\n\n    debug('undo', { item, json, documentState, selection })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.undo.patch,\n            undo: item.redo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function handleRedo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canRedo) {\n      return\n    }\n\n    const item = history.redo()\n    if (!isTreeHistoryItem(item)) {\n      onRedo(item)\n\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.redo.patch ? immutableJSONPatch(json, item.redo.patch) : item.redo.json\n    documentState = item.redo.documentState\n    selection = item.redo.selection\n    text = item.redo.text\n    textIsRepaired = item.redo.textIsRepaired\n    parseError = undefined\n\n    debug('redo', { item, json, documentState, selection })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.redo.patch,\n            undo: item.undo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function openSortModal(rootPath: JSONPath) {\n    if (readOnly || json === undefined) {\n      return\n    }\n\n    modalOpen = true\n\n    onSortModal({\n      id: sortModalId,\n      json,\n      rootPath,\n      onSort: async ({ operations }) => {\n        debug('onSort', rootPath, operations)\n\n        handlePatch(operations, (patchedJson, patchedState) => ({\n          // expand the newly replaced array if needed, and select it\n          state: expandSmartIfCollapsed(patchedJson, patchedState, rootPath),\n          selection: createValueSelection(rootPath)\n        }))\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  function handleSortSelection() {\n    if (!selection) {\n      return\n    }\n\n    const rootPath = findRootPath(json, selection)\n    openSortModal(rootPath)\n  }\n\n  function handleSortAll() {\n    const rootPath: JSONPath = []\n    openSortModal(rootPath)\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal(options: TransformModalOptions) {\n    if (json === undefined) {\n      return\n    }\n\n    const { id, onTransform, onClose } = options\n    const rootPath = options.rootPath || []\n\n    modalOpen = true\n\n    onTransformModal({\n      id: id || transformModalId,\n      json,\n      rootPath,\n      onTransform: (operations) => {\n        if (onTransform) {\n          onTransform({\n            operations,\n            json,\n            transformedJson: immutableJSONPatch(json, operations)\n          })\n        } else {\n          debug('onTransform', rootPath, operations)\n\n          handlePatch(operations, (patchedJson, patchedState) => ({\n            // expand the newly replaced array if needed and select it\n            state: expandSmartIfCollapsed(patchedJson, patchedState, rootPath),\n            selection: createValueSelection(rootPath)\n          }))\n        }\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n        if (onClose) {\n          onClose()\n        }\n      }\n    })\n  }\n\n  function handleTransformSelection() {\n    if (!selection) {\n      return\n    }\n\n    const rootPath = findRootPath(json, selection)\n    openTransformModal({\n      rootPath\n    })\n  }\n\n  function handleTransformAll() {\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function openJSONEditorModal(path: JSONPath, value: unknown) {\n    debug('openJSONEditorModal', { path, value })\n\n    modalOpen = true\n\n    // open a popup where you can edit the nested object/array\n    onJSONEditorModal({\n      content: {\n        json: value\n      },\n      path,\n      onPatch: context.onPatch,\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  /**\n   * Scroll the window vertically to the node with given path.\n   * Expand the path when needed.\n   */\n  export async function scrollTo(path: JSONPath, scrollToWhenVisible = true): Promise<void> {\n    documentState = expandPath(json, documentState, path, expandNone)\n    await tick() // await rerender (else the element we want to scroll to does not yet exist)\n\n    const elem = findElement(path)\n\n    debug('scrollTo', { path, elem, refContents })\n\n    if (!elem || !refContents) {\n      return Promise.resolve()\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect()\n    if (!scrollToWhenVisible) {\n      if (elemRect.bottom > viewPortRect.top && elemRect.top < viewPortRect.bottom) {\n        // element is fully or partially visible, don't scroll to it\n        return Promise.resolve()\n      }\n    }\n\n    const offset = -(viewPortRect.height / 4)\n\n    return new Promise<void>((resolve) => {\n      jump(elem, {\n        container: refContents,\n        offset,\n        duration: SCROLL_DURATION,\n        callback: () => resolve()\n      })\n    })\n  }\n\n  /**\n   * Find the DOM element of a given path.\n   * Note that the path can only be found when the node is expanded.\n   */\n  export function findElement(path: JSONPath): Element | undefined {\n    return refContents?.querySelector(`div[data-path=\"${encodeDataPath(path)}\"]`) ?? undefined\n  }\n\n  /**\n   * If given path is outside the visible viewport, scroll up/down.\n   * When the path is already in view, nothing is done\n   */\n  function scrollIntoView(path: JSONPath) {\n    const elem = findElement(path)\n\n    if (!elem || !refContents) {\n      return\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect()\n    const margin = 20\n    const elemHeight = isObjectOrArray(getIn(json, path))\n      ? margin // do not use real height when array or object\n      : elemRect.height\n\n    if (elemRect.top < viewPortRect.top + margin) {\n      // scroll down\n      jump(elem, {\n        container: refContents,\n        offset: -margin,\n        duration: 0\n      })\n    } else if (elemRect.top + elemHeight > viewPortRect.bottom - margin) {\n      // scroll up\n      jump(elem, {\n        container: refContents,\n        offset: -(viewPortRect.height - elemHeight - margin),\n        duration: 0\n      })\n    }\n  }\n\n  function emitOnChange(previousContent: Content, patchResult: JSONPatchResult | undefined) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (previousContent.json === undefined && previousContent?.text === undefined) {\n      // initialization -> do not fire an onChange event\n      return\n    }\n\n    // make sure we cannot send an invalid contents like having both\n    // json and text defined, or having none defined\n    if (text !== undefined) {\n      const content = { text, json: undefined }\n      onChange?.(content, previousContent, {\n        contentErrors: validate(),\n        patchResult\n      })\n    } else if (json !== undefined) {\n      const content = { text: undefined, json }\n      onChange?.(content, previousContent, {\n        contentErrors: validate(),\n        patchResult\n      })\n    }\n  }\n\n  function handlePatch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('handlePatch', operations, afterPatch)\n\n    const previousContent = { json, text }\n    const patchResult = patch(operations, afterPatch)\n\n    emitOnChange(previousContent, patchResult)\n\n    return patchResult\n  }\n\n  function handleReplaceJson(updatedJson: unknown, afterPatch?: AfterPatchCallback) {\n    const previousContent = { json, text }\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    const updatedState = expandPath(\n      json,\n      syncDocumentState(updatedJson, documentState),\n      [],\n      expandMinimal\n    )\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(updatedJson, updatedState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : updatedJson\n    documentState = callback?.state !== undefined ? callback.state : updatedState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // we could work out a patchResult, or use patch(), but only when the previous and new\n    // contents are both json and not text. We go for simplicity and consistency here and\n    // do _not_ return a patchResult ever.\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  function handleChangeText(updatedText: string, afterPatch?: AfterPatchCallback) {\n    debug('handleChangeText')\n\n    const previousContent = { json, text }\n    const previousState = { documentState, selection, json, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = expandPath(json, syncDocumentState(json, documentState), [], expandMinimal)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = expandPath(json, syncDocumentState(json, documentState), [], expandMinimal)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = createDocumentState({ json, expand: expandMinimal })\n        text = updatedText\n        textIsRepaired = false\n        parseError =\n          text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    if (typeof afterPatch === 'function') {\n      const callback = afterPatch(json, documentState, selection)\n\n      json = callback?.json !== undefined ? callback.json : json\n      documentState = callback?.state !== undefined ? callback.state : documentState\n      selection = callback?.selection !== undefined ? callback.selection : selection\n    }\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // no JSON patch actions available in text mode\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  /**\n   * Toggle expanded state of a node\n   * @param path The path to be expanded\n   * @param expanded  True if currently expanded, false when currently collapsed\n   * @param [recursive=false]  Only applicable when expanding\n   */\n  function handleExpand(path: JSONPath, expanded: boolean, recursive = false): void {\n    debug('handleExpand', { path, expanded, recursive })\n\n    if (expanded) {\n      expand(path, recursive ? expandAll : expandSelf)\n    } else {\n      collapse(path, recursive)\n    }\n\n    // set focus to the hidden input, so we can capture quick keys like Ctrl+X, Ctrl+C, Ctrl+V\n    focus()\n  }\n\n  function handleExpandAll() {\n    handleExpand([], true, true)\n  }\n\n  function handleCollapseAll() {\n    handleExpand([], false, true)\n  }\n\n  function openFind(findAndReplace: boolean): void {\n    debug('openFind', { findAndReplace })\n\n    showSearch = false\n    showReplace = false\n\n    tick().then(() => {\n      // trick to make sure the focus goes to the search box\n      showSearch = true\n      showReplace = findAndReplace\n    })\n  }\n\n  function handleExpandSection(path: JSONPath, section: Section) {\n    debug('handleExpandSection', path, section)\n\n    documentState = expandSection(json, documentState, path, section)\n  }\n\n  function handlePasteJson(newPastedJson: PastedJson) {\n    debug('pasted json as text', newPastedJson)\n\n    pastedJson = newPastedJson\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    const keepAnchorPath = event.shiftKey\n    debug('keydown', { combo, key: event.key })\n\n    if (combo === 'Ctrl+X') {\n      // cut formatted\n      event.preventDefault()\n      handleCut(true)\n    }\n    if (combo === 'Ctrl+Shift+X') {\n      // cut compact\n      event.preventDefault()\n      handleCut(false)\n    }\n    if (combo === 'Ctrl+C') {\n      // copy formatted\n      event.preventDefault()\n      handleCopy(true)\n    }\n    if (combo === 'Ctrl+Shift+C') {\n      // copy compact\n      event.preventDefault()\n      handleCopy(false)\n    }\n    // Note: Ctrl+V (paste) is handled by the on:paste event\n\n    if (combo === 'Ctrl+D') {\n      event.preventDefault()\n      handleDuplicate()\n    }\n    if (combo === 'Delete' || combo === 'Backspace') {\n      event.preventDefault()\n      handleRemove()\n    }\n    if (combo === 'Insert') {\n      event.preventDefault()\n      handleInsert('structure')\n    }\n    if (combo === 'Ctrl+A') {\n      event.preventDefault()\n      selection = selectAll()\n    }\n\n    if (combo === 'Ctrl+Q') {\n      handleContextMenu(event)\n    }\n\n    if (combo === 'ArrowUp' || combo === 'Shift+ArrowUp') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionUp(json, documentState, selection, keepAnchorPath) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowDown' || combo === 'Shift+ArrowDown') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionDown(json, documentState, selection, keepAnchorPath) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowLeft' || combo === 'Shift+ArrowLeft') {\n      event.preventDefault()\n\n      const newSelection = selection\n        ? getSelectionLeft(json, documentState, selection, keepAnchorPath, !readOnly) || selection\n        : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n    if (combo === 'ArrowRight' || combo === 'Shift+ArrowRight') {\n      event.preventDefault()\n\n      const newSelection =\n        selection && json !== undefined\n          ? getSelectionRight(json, documentState, selection, keepAnchorPath, !readOnly) ||\n            selection\n          : getInitialSelection(json, documentState)\n\n      selection = newSelection\n      scrollIntoView(getFocusPath(newSelection))\n    }\n\n    if (combo === 'Enter' && selection) {\n      // when the selection consists of a single Array item, change selection to editing its value\n      if (isMultiSelectionWithOneItem(selection)) {\n        const path = selection.focusPath\n        const parent = getIn(json, initial(path))\n        if (Array.isArray(parent)) {\n          // change into selection of the value\n          event.preventDefault()\n          selection = createValueSelection(path)\n        }\n      }\n\n      if (isKeySelection(selection)) {\n        // go to key edit mode\n        event.preventDefault()\n        selection = { ...selection, edit: true }\n      }\n\n      if (isValueSelection(selection)) {\n        event.preventDefault()\n\n        const value = getIn(json, selection.path)\n        if (isObjectOrArray(value)) {\n          // expand object/array\n          handleExpand(selection.path, true)\n        } else {\n          // go to value edit mode\n          selection = { ...selection, edit: true }\n        }\n      }\n    }\n\n    const normalizedCombo = combo.replace(/^Shift\\+/, '') // replace 'Shift+A' with 'A'\n    if (normalizedCombo.length === 1 && selection) {\n      // a regular key like a, A, _, etc is entered.\n      // Replace selected contents with a new value having this first character as text\n      event.preventDefault()\n      handleInsertCharacter(event.key)\n      return\n    }\n\n    if (combo === 'Enter' && (isAfterSelection(selection) || isInsideSelection(selection))) {\n      // Enter on an insert area -> open the area in edit mode\n      event.preventDefault()\n      handleInsertCharacter('')\n      return\n    }\n\n    if (combo === 'Ctrl+Enter' && isValueSelection(selection)) {\n      const value = getIn(json, selection.path)\n\n      if (isUrl(value)) {\n        // open url in new page\n        window.open(String(value), '_blank')\n      }\n    }\n\n    if (combo === 'Escape' && selection) {\n      event.preventDefault()\n      selection = undefined\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      openFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      openFind(true)\n    }\n\n    if (combo === 'Ctrl+Z') {\n      event.preventDefault()\n      handleUndo()\n    }\n\n    if (combo === 'Ctrl+Shift+Z') {\n      event.preventDefault()\n      handleRedo()\n    }\n  }\n\n  function handleMouseDown(event: Event) {\n    debug('handleMouseDown', event)\n\n    const target = event.target as HTMLElement\n\n    if (!isChildOfNodeName(target, 'BUTTON') && !target.isContentEditable) {\n      // for example when clicking on the empty area in the main menu\n      focus()\n\n      if (!selection && json === undefined && (text === '' || text === undefined)) {\n        createDefaultSelection()\n      }\n    }\n  }\n\n  function openContextMenu({\n    anchor,\n    left,\n    top,\n    width,\n    height,\n    offsetTop,\n    offsetLeft,\n    showTip\n  }: AbsolutePopupOptions) {\n    const defaultItems: ContextMenuItem[] = createTreeContextMenuItems({\n      json,\n      documentState,\n      selection,\n      readOnly,\n\n      onEditKey: handleEditKey,\n      onEditValue: handleEditValue,\n      onToggleEnforceString: handleToggleEnforceString,\n\n      onCut: handleCut,\n      onCopy: handleCopy,\n      onPaste: handlePasteFromMenu,\n\n      onRemove: handleRemove,\n      onDuplicate: handleDuplicate,\n      onExtract: handleExtract,\n\n      onInsertBefore: handleInsertBefore,\n      onInsert: handleInsertFromContextMenu,\n      onInsertAfter: handleInsertAfter,\n      onConvert: handleConvert,\n\n      onSort: handleSortSelection,\n      onTransform: handleTransformSelection\n    })\n\n    const items = onRenderContextMenu(defaultItems) ?? defaultItems\n\n    if (items === false) {\n      return\n    }\n\n    const props = {\n      tip: showTip\n        ? 'Tip: you can open this context menu via right-click or with Ctrl+Q'\n        : undefined,\n      items,\n      onRequestClose: () => closeAbsolutePopup(popupId)\n    }\n\n    const options = {\n      left,\n      top,\n      offsetTop,\n      offsetLeft,\n      width,\n      height,\n      anchor,\n      closeOnOuterClick: true,\n      onClose: () => {\n        modalOpen = false\n        focus()\n      }\n    }\n\n    modalOpen = true\n\n    const popupId = openAbsolutePopup(ContextMenu, props, options)\n  }\n\n  function handleContextMenu(event?: Event) {\n    if (isEditingSelection(selection)) {\n      return\n    }\n\n    if (event) {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n\n    if (event && event.type === 'contextmenu' && event.target !== refHiddenInput) {\n      // right mouse click to open context menu\n      openContextMenu({\n        left: (event as MouseEvent).clientX,\n        top: (event as MouseEvent).clientY,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        showTip: false\n      })\n    } else {\n      // type === 'keydown' (from the quick key Ctrl+Q)\n      // or target is hidden input -> context menu button on keyboard\n      const anchor = refContents?.querySelector('.jse-context-menu-pointer.jse-selected')\n      if (anchor) {\n        openContextMenu({\n          anchor,\n          offsetTop: 2,\n          width: CONTEXT_MENU_WIDTH,\n          height: CONTEXT_MENU_HEIGHT,\n          showTip: false\n        })\n      } else {\n        // fallback on just displaying the TreeContextMenu top left\n        const rect = refContents?.getBoundingClientRect()\n        if (rect) {\n          openContextMenu({\n            top: rect.top + 2,\n            left: rect.left + 2,\n            width: CONTEXT_MENU_WIDTH,\n            height: CONTEXT_MENU_HEIGHT,\n            showTip: false\n          })\n        }\n      }\n    }\n  }\n\n  function handleContextMenuFromTreeMenu(event: MouseEvent) {\n    openContextMenu({\n      anchor: findParentWithNodeName(event.target as HTMLElement, 'BUTTON'),\n      offsetTop: 0,\n      width: CONTEXT_MENU_WIDTH,\n      height: CONTEXT_MENU_HEIGHT,\n      showTip: true\n    })\n  }\n\n  async function handleParsePastedJson() {\n    debug('apply pasted json', pastedJson)\n    if (!pastedJson) {\n      return\n    }\n\n    const { onPasteAsJson } = pastedJson\n    pastedJson = undefined\n\n    onPasteAsJson()\n\n    // TODO: get rid of the setTimeout here\n    setTimeout(focus)\n  }\n\n  function handleClearPastedJson() {\n    debug('clear pasted json')\n    pastedJson = undefined\n    focus()\n  }\n\n  function handleRequestRepair() {\n    onChangeMode(Mode.text)\n  }\n\n  function handleNavigationBarSelect(newSelection: JSONSelection) {\n    selection = newSelection\n\n    focus()\n    scrollTo(getFocusPath(newSelection))\n  }\n\n  export function focus() {\n    debug('focus')\n    // with just .focus(), sometimes the input doesn't react on onpaste events\n    // in Chrome when having a large document open and then doing cut/paste.\n    // Calling both .focus() and .select() did solve this issue.\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n      refHiddenInput.select()\n    }\n  }\n\n  function handleWindowMouseDown(event: MouseEvent & { currentTarget: EventTarget & Window }) {\n    const outsideEditor = !isChildOf(\n      event.target as Element,\n      (element) => element === refJsonEditor\n    )\n    if (outsideEditor) {\n      if (isEditingSelection(selection)) {\n        debug('click outside the editor, exit edit mode')\n        selection = removeEditModeFromSelection(selection)\n\n        if (hasFocus && refHiddenInput) {\n          refHiddenInput.focus()\n          refHiddenInput.blur()\n        }\n\n        debug('blur (outside editor)')\n        if (refHiddenInput) {\n          refHiddenInput.blur()\n        }\n      }\n    }\n  }\n\n  function findNextInside(path: JSONPath): JSONSelection | undefined {\n    return getSelectionNextInside(json, documentState, path)\n  }\n\n  $: autoScrollHandler = refContents ? createAutoScrollHandler(refContents) : undefined\n\n  function handleDrag(event: MouseEvent) {\n    if (autoScrollHandler) {\n      autoScrollHandler.onDrag(event)\n    }\n  }\n\n  function handleDragEnd() {\n    if (autoScrollHandler) {\n      autoScrollHandler.onDragEnd()\n    }\n  }\n\n  // Note that we want the context to change as little as possible since it forces all nodes to re-render,\n  // it should only change when a config option like readOnly or onClassName is changed\n  let context: TreeModeContext\n  $: context = {\n    mode: Mode.tree,\n    readOnly,\n    parser,\n    normalization,\n    getJson,\n    getDocumentState,\n    getSelection,\n    findElement,\n    findNextInside,\n    focus,\n    onPatch: handlePatch,\n    onInsert: handleInsert,\n    onExpand: handleExpand,\n    onSelect: handleSelect,\n    onFind: openFind,\n    onExpandSection: handleExpandSection,\n    onPasteJson: handlePasteJson,\n    onRenderValue,\n    onContextMenu: openContextMenu,\n    onClassName: onClassName || (() => undefined),\n    onDrag: handleDrag,\n    onDragEnd: handleDragEnd\n  }\n\n  $: debug('context changed', context)\n</script>\n\n<svelte:window on:mousedown={handleWindowMouseDown} />\n\n<div\n  role=\"tree\"\n  tabindex=\"-1\"\n  class=\"jse-tree-mode\"\n  class:no-main-menu={!mainMenuBar}\n  on:keydown={handleKeyDown}\n  on:mousedown={handleMouseDown}\n  on:contextmenu={handleContextMenu}\n  bind:this={refJsonEditor}\n>\n  {#if mainMenuBar}\n    <TreeMenu\n      {json}\n      {selection}\n      {readOnly}\n      {history}\n      bind:showSearch\n      onExpandAll={handleExpandAll}\n      onCollapseAll={handleCollapseAll}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      onSort={handleSortAll}\n      onTransform={handleTransformAll}\n      onContextMenu={handleContextMenuFromTreeMenu}\n      onCopy={handleCopy}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if navigationBar}\n    <NavigationBar {json} {selection} onSelect={handleNavigationBarSelect} {onError} {pathParser} />\n  {/if}\n\n  {#if !isSSR}\n    <label class=\"jse-hidden-input-label\">\n      <input\n        type=\"text\"\n        readonly={true}\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n        on:paste={handlePaste}\n      />\n    </label>\n    {#if json === undefined}\n      {#if text === '' || text === undefined}\n        <Welcome\n          {readOnly}\n          onCreateObject={() => {\n            focus()\n            handleInsertCharacter('{')\n          }}\n          onCreateArray={() => {\n            focus()\n            handleInsertCharacter('[')\n          }}\n          onClick={() => {\n            // FIXME: this is a workaround for the editor not putting the focus on refHiddenInput\n            //  when clicking in the welcome screen so you cannot paste a document from clipboard.\n            focus()\n          }}\n        />\n      {:else}\n        <Message\n          type=\"error\"\n          message=\"The loaded JSON document is invalid and could not be repaired automatically.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCode,\n                  text: 'Repair manually',\n                  title: 'Open the document in \"code\" mode and repair it manually',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n        />\n        <JSONPreview {text} {json} {indentation} {parser} />\n      {/if}\n    {:else}\n      <div class=\"jse-search-box-container\">\n        <SearchBox\n          {json}\n          {documentState}\n          {parser}\n          {showSearch}\n          {showReplace}\n          {readOnly}\n          columns={undefined}\n          onSearch={handleSearch}\n          onFocus={handleFocusSearch}\n          onPatch={handlePatch}\n          onClose={handleCloseSearch}\n        />\n      </div>\n      <div class=\"jse-contents\" data-jsoneditor-scrollable-contents={true} bind:this={refContents}>\n        {#if showSearch}\n          <div class=\"jse-search-box-background\"></div>\n        {/if}\n        <JSONNode\n          value={json}\n          pointer={''}\n          state={documentState}\n          {validationErrors}\n          {searchResults}\n          {selection}\n          {context}\n          onDragSelectionStart={noop}\n        />\n      </div>\n\n      {#if pastedJson}\n        <Message\n          type=\"info\"\n          message={`You pasted a JSON ${\n            Array.isArray(pastedJson.contents) ? 'array' : 'object'\n          } as text`}\n          actions={[\n            {\n              icon: faWrench,\n              text: 'Paste as JSON instead',\n              title: 'Replace the value with the pasted JSON',\n              // We use mousedown here instead of click: this message pops up\n              // whilst the user is editing a value. When clicking this button,\n              // the actual value is applied and the event is not propagated\n              // and an onClick on this button never happens.\n              onMouseDown: handleParsePastedJson\n            },\n            {\n              text: 'Leave as is',\n              title: 'Keep the JSON embedded in the value',\n              onClick: handleClearPastedJson\n            }\n          ]}\n        />\n      {/if}\n\n      {#if textIsRepaired}\n        <Message\n          type=\"success\"\n          message=\"The loaded JSON document was invalid but is successfully repaired.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCheck,\n                  text: 'Ok',\n                  title: 'Accept the repaired document',\n                  onClick: acceptAutoRepair\n                },\n                {\n                  icon: faCode,\n                  text: 'Repair manually instead',\n                  title: 'Leave the document unchanged and repair it manually instead',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview\n        validationErrors={validationErrorList}\n        selectError={handleSelectValidationError}\n      />\n    {/if}\n  {:else}\n    <div class=\"jse-contents\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n{#if copyPasteModalOpen}\n  <CopyPasteModal onClose={() => (copyPasteModalOpen = false)} />\n{/if}\n\n{#if jsonRepairModalProps}\n  <JSONRepairModal\n    {...jsonRepairModalProps}\n    onClose={() => {\n      jsonRepairModalProps?.onClose()\n      jsonRepairModalProps = undefined\n    }}\n  />\n{/if}\n\n<style src=\"./TreeMode.scss\"></style>\n","import {\n  faArrowRightArrowLeft,\n  faCaretSquareDown,\n  faCaretSquareUp,\n  faCheckSquare,\n  faClone,\n  faCopy,\n  faCropAlt,\n  faCut,\n  faFilter,\n  faPaste,\n  faPen,\n  faPlus,\n  faSortAmountDownAlt,\n  faSquare,\n  faTrashCan\n} from '@fortawesome/free-solid-svg-icons'\nimport {\n  canConvert,\n  getFocusPath,\n  isAfterSelection,\n  isInsideSelection,\n  isKeySelection,\n  isMultiSelection,\n  isValueSelection,\n  singleItemSelected\n} from '$lib/logic/selection'\nimport type {\n  ConvertType,\n  DocumentState,\n  InsertType,\n  JSONSelection,\n  ContextMenuItem\n} from '$lib/types'\nimport { initial, isEmpty } from 'lodash-es'\nimport { getIn } from 'immutable-json-patch'\nimport { isObject, isObjectOrArray } from '$lib/utils/typeUtils'\nimport { getEnforceString } from '$lib/logic/documentState'\n\nexport default function ({\n  json,\n  documentState,\n  selection,\n  readOnly,\n  onEditKey,\n  onEditValue,\n  onToggleEnforceString,\n  onCut,\n  onCopy,\n  onPaste,\n  onRemove,\n  onDuplicate,\n  onExtract,\n  onInsertBefore,\n  onInsert,\n  onConvert,\n  onInsertAfter,\n  onSort,\n  onTransform\n}: {\n  json: unknown\n  documentState: DocumentState | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  onEditKey: () => void\n  onEditValue: () => void\n  onToggleEnforceString: () => void\n  onCut: (indent: boolean) => void\n  onCopy: (indent: boolean) => void\n  onPaste: () => void\n  onRemove: () => void\n  onDuplicate: () => void\n  onExtract: () => void\n  onInsertBefore: () => void\n  onInsert: (type: InsertType) => void\n  onConvert: (type: ConvertType) => void\n  onInsertAfter: () => void\n  onSort: () => void\n  onTransform: () => void\n}): ContextMenuItem[] {\n  const hasJson = json !== undefined\n  const hasSelection = !!selection\n  const rootSelected = selection ? isEmpty(getFocusPath(selection)) : false\n  const focusValue = selection ? getIn(json, getFocusPath(selection)) : undefined\n  const editValueText = Array.isArray(focusValue)\n    ? 'Edit array'\n    : isObject(focusValue)\n      ? 'Edit object'\n      : 'Edit value'\n\n  const hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  const parent =\n    selection && !rootSelected ? getIn(json, initial(getFocusPath(selection))) : undefined\n\n  const canEditKey =\n    !readOnly && hasJson && singleItemSelected(selection) && !rootSelected && !Array.isArray(parent)\n\n  const canEditValue =\n    !readOnly && hasJson && selection !== undefined && singleItemSelected(selection)\n  const canEnforceString = canEditValue && !isObjectOrArray(focusValue)\n\n  const canCut = !readOnly && hasSelectionContents\n  const canCopy = hasSelectionContents\n  const canPaste = !readOnly && hasSelection\n  const canDuplicate = !readOnly && hasJson && hasSelectionContents && !rootSelected // must not be root\n  const canExtract =\n    !readOnly &&\n    hasJson &&\n    selection !== undefined &&\n    (isMultiSelection(selection) || isValueSelection(selection)) &&\n    !rootSelected // must not be root\n\n  const convertMode = hasSelectionContents\n  const insertOrConvertText = convertMode ? 'Convert to:' : 'Insert:'\n\n  const canInsertOrConvertStructure =\n    !readOnly &&\n    ((isInsideSelection(selection) && Array.isArray(focusValue)) ||\n      (isAfterSelection(selection) && Array.isArray(parent)))\n  const canInsertOrConvertObject =\n    !readOnly && (convertMode ? canConvert(selection) && !isObject(focusValue) : hasSelection)\n  const canInsertOrConvertArray =\n    !readOnly && (convertMode ? canConvert(selection) && !Array.isArray(focusValue) : hasSelection)\n  const canInsertOrConvertValue =\n    !readOnly && (convertMode ? canConvert(selection) && isObjectOrArray(focusValue) : hasSelection)\n\n  const enforceString =\n    selection !== undefined ? getEnforceString(json, documentState, getFocusPath(selection)) : false\n\n  function handleInsertOrConvert(type: InsertType) {\n    if (hasSelectionContents) {\n      if (type !== 'structure') {\n        onConvert(type)\n      }\n    } else {\n      onInsert(type)\n    }\n  }\n\n  return [\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'button',\n          onClick: () => onEditKey(),\n          icon: faPen,\n          text: 'Edit key',\n          title: 'Edit the key (Double-click on the key)',\n          disabled: !canEditKey\n        },\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onEditValue(),\n            icon: faPen,\n            text: editValueText,\n            title: 'Edit the value (Double-click on the value)',\n            disabled: !canEditValue\n          },\n          width: '11em',\n          items: [\n            {\n              type: 'button',\n              icon: faPen,\n              text: editValueText,\n              title: 'Edit the value (Double-click on the value)',\n              onClick: () => onEditValue(),\n              disabled: !canEditValue\n            },\n            {\n              type: 'button',\n              icon: enforceString ? faCheckSquare : faSquare,\n              text: 'Enforce string',\n              title: 'Enforce keeping the value as string when it contains a numeric value',\n              onClick: () => onToggleEnforceString(),\n              disabled: !canEnforceString\n            }\n          ]\n        }\n      ]\n    },\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onCut(true),\n            icon: faCut,\n            text: 'Cut',\n            title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n            disabled: !canCut\n          },\n          width: '10em',\n          items: [\n            {\n              type: 'button',\n              icon: faCut,\n              text: 'Cut formatted',\n              title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n              onClick: () => onCut(true),\n              disabled: !canCut\n            },\n            {\n              type: 'button',\n              icon: faCut,\n              text: 'Cut compacted',\n              title: 'Cut selected contents, without indentation (Ctrl+Shift+X)',\n              onClick: () => onCut(false),\n              disabled: !canCut\n            }\n          ]\n        },\n        {\n          type: 'dropdown-button',\n          main: {\n            type: 'button',\n            onClick: () => onCopy(true),\n            icon: faCopy,\n            text: 'Copy',\n            title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n            disabled: !canCopy\n          },\n          width: '12em',\n          items: [\n            {\n              type: 'button',\n              icon: faCopy,\n              text: 'Copy formatted',\n              title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n              onClick: () => onCopy(true),\n              disabled: !canCopy\n            },\n            {\n              type: 'button',\n              icon: faCopy,\n              text: 'Copy compacted',\n              title: 'Copy selected contents, without indentation (Ctrl+Shift+C)',\n              onClick: () => onCopy(false),\n              disabled: !canCopy\n            }\n          ]\n        },\n        {\n          type: 'button',\n          onClick: () => onPaste(),\n          icon: faPaste,\n          text: 'Paste',\n          title: 'Paste clipboard contents (Ctrl+V)',\n          disabled: !canPaste\n        }\n      ]\n    },\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'column',\n          items: [\n            {\n              type: 'button',\n              onClick: () => onDuplicate(),\n              icon: faClone,\n              text: 'Duplicate',\n              title: 'Duplicate selected contents (Ctrl+D)',\n              disabled: !canDuplicate\n            },\n            {\n              type: 'button',\n              onClick: () => onExtract(),\n              icon: faCropAlt,\n              text: 'Extract',\n              title: 'Extract selected contents',\n              disabled: !canExtract\n            },\n            {\n              type: 'button',\n              onClick: () => onSort(),\n              icon: faSortAmountDownAlt,\n              text: 'Sort',\n              title: 'Sort array or object contents',\n              disabled: readOnly || !hasSelectionContents\n            },\n            {\n              type: 'button',\n              onClick: () => onTransform(),\n              icon: faFilter,\n              text: 'Transform',\n              title: 'Transform array or object contents (filter, sort, project)',\n              disabled: readOnly || !hasSelectionContents\n            },\n            {\n              type: 'button',\n              onClick: () => onRemove(),\n              icon: faTrashCan,\n              text: 'Remove',\n              title: 'Remove selected contents (Delete)',\n              disabled: readOnly || !hasSelectionContents\n            }\n          ]\n        },\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: insertOrConvertText },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('structure'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Structure',\n              title: insertOrConvertText + ' structure like the first item in the array',\n              disabled: !canInsertOrConvertStructure\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('object'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Object',\n              title: insertOrConvertText + ' object',\n              disabled: !canInsertOrConvertObject\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('array'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Array',\n              title: insertOrConvertText + ' array',\n              disabled: !canInsertOrConvertArray\n            },\n            {\n              type: 'button',\n              onClick: () => handleInsertOrConvert('value'),\n              icon: convertMode ? faArrowRightArrowLeft : faPlus,\n              text: 'Value',\n              title: insertOrConvertText + ' value',\n              disabled: !canInsertOrConvertValue\n            }\n          ]\n        }\n      ]\n    },\n    {\n      type: 'separator'\n    },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'button',\n          onClick: () => onInsertBefore(),\n          icon: faCaretSquareUp,\n          text: 'Insert before',\n          title: 'Select area before current entry to insert or paste contents',\n          disabled: readOnly || !hasSelectionContents || rootSelected\n        },\n        {\n          type: 'button',\n          onClick: () => onInsertAfter(),\n          icon: faCaretSquareDown,\n          text: 'Insert after',\n          title: 'Select area after current entry to insert or paste contents',\n          disabled: readOnly || !hasSelectionContents || rootSelected\n        }\n      ]\n    }\n  ]\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faCopy,\n    faEllipsisV,\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { CONTEXT_MENU_EXPLANATION } from '$lib/constants.js'\n  import { faJSONEditorCollapse, faJSONEditorExpand } from '$lib/img/customFontawesomeIcons.js'\n  import { isObjectOrArray } from '$lib/utils/typeUtils.js'\n  import Menu from '../../../controls/Menu.svelte'\n  import type {\n    HistoryItem,\n    History,\n    JSONSelection,\n    MenuItem,\n    OnRenderMenuInternal\n  } from '$lib/types'\n  import { isKeySelection, isMultiSelection, isValueSelection } from '$lib/logic/selection.js'\n\n  export let json: unknown\n  export let selection: JSONSelection | undefined\n\n  export let readOnly: boolean\n  export let showSearch = false\n  export let history: History<HistoryItem>\n\n  export let onExpandAll: () => void\n  export let onCollapseAll: () => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onContextMenu: (event: MouseEvent) => void\n  export let onCopy: () => void\n  export let onRenderMenu: OnRenderMenuInternal\n\n  function handleToggleSearch() {\n    showSearch = !showSearch\n  }\n\n  $: hasJson = json !== undefined\n  $: hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  let expandMenuItem: MenuItem\n  $: expandMenuItem = {\n    type: 'button',\n    icon: faJSONEditorExpand,\n    title: 'Expand all',\n    className: 'jse-expand-all',\n    onClick: onExpandAll,\n    disabled: !isObjectOrArray(json)\n  }\n\n  let collapseMenuItem: MenuItem\n  $: collapseMenuItem = {\n    type: 'button',\n    icon: faJSONEditorCollapse,\n    title: 'Collapse all',\n    className: 'jse-collapse-all',\n    onClick: onCollapseAll,\n    disabled: !isObjectOrArray(json)\n  }\n\n  let searchMenuItem: MenuItem\n  $: searchMenuItem = {\n    type: 'button',\n    icon: faSearch,\n    title: 'Search (Ctrl+F)',\n    className: 'jse-search',\n    onClick: handleToggleSearch,\n    disabled: json === undefined\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        expandMenuItem,\n        collapseMenuItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || json === undefined\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || json === undefined\n        },\n        searchMenuItem,\n        {\n          type: 'button',\n          icon: faEllipsisV,\n          title: CONTEXT_MENU_EXPLANATION,\n          className: 'jse-contextmenu',\n          onClick: onContextMenu\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !history.canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !history.canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        expandMenuItem,\n        collapseMenuItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faCopy,\n          title: 'Copy (Ctrl+C)',\n          className: 'jse-copy',\n          onClick: onCopy,\n          disabled: !hasSelectionContents\n        },\n        {\n          type: 'separator'\n        },\n        searchMenuItem,\n        {\n          type: 'space'\n        }\n      ]\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  export let readOnly: boolean\n  export let onCreateArray: () => void\n  export let onCreateObject: () => void\n  export let onClick: () => void\n</script>\n\n<div class=\"jse-welcome\" on:click={() => onClick()} role=\"none\">\n  <div class=\"jse-space jse-before\"></div>\n  <div class=\"jse-contents\">\n    <div class=\"jse-welcome-title\">Empty document</div>\n    {#if !readOnly}\n      <div class=\"jse-welcome-info\">\n        You can paste clipboard data using <b>Ctrl+V</b>, or use the following options:\n      </div>\n      <button\n        title={\"Create an empty JSON object (press '{')\"}\n        on:click|stopPropagation={() => onCreateObject()}>Create object</button\n      >\n      <button\n        title={\"Create an empty JSON array (press '[')\"}\n        on:click|stopPropagation={() => onCreateArray()}>Create array</button\n      >\n    {/if}\n  </div>\n  <div class=\"jse-space jse-after\"></div>\n</div>\n\n<style src=\"./Welcome.scss\"></style>\n","/**\n * Create a readonly proxy around an object or array.\n *\n * Will throw an error when trying to mutate the object or array\n *\n * Inspired by: https://github.com/kourge/readonly-proxy/\n */\nexport function readonlyProxy(target: unknown): unknown {\n  if (!isObject(target)) {\n    return target\n  }\n\n  return new Proxy(target, {\n    get(target, property, receiver) {\n      const value = Reflect.get(target, property, receiver)\n\n      return readonlyProxy(value)\n    },\n\n    set() {\n      return false\n    },\n\n    deleteProperty() {\n      return false\n    }\n  })\n}\n\nfunction isObject(value: unknown): value is object {\n  return typeof value === 'object' && value !== null\n}\n","import { createDebug } from '../utils/debug.js'\nimport type { HistoryInstance, History } from 'svelte-jsoneditor'\n\nconst MAX_HISTORY_ITEMS = 1000\n\nconst debug = createDebug('jsoneditor:History')\n\nexport interface HistoryOptions<T> {\n  maxItems?: number\n  onChange?: (state: History<T>) => void\n}\n\nexport function createHistoryInstance<T>(options: HistoryOptions<T> = {}): HistoryInstance<T> {\n  const maxItems = options.maxItems || MAX_HISTORY_ITEMS\n\n  /**\n   * items in history are sorted from newest first to oldest last\n   */\n  let reverseItems: T[] = []\n\n  let index = 0\n\n  function canUndo(): boolean {\n    return index < reverseItems.length\n  }\n\n  function canRedo(): boolean {\n    return index > 0\n  }\n\n  function get(): History<T> {\n    return {\n      canUndo: canUndo(),\n      canRedo: canRedo(),\n      items: () => reverseItems.slice().reverse(),\n      add,\n      undo,\n      redo,\n      clear\n    }\n  }\n\n  function handleChange() {\n    if (options.onChange) {\n      options.onChange(get())\n    }\n  }\n\n  function add(item: T) {\n    debug('add', item)\n\n    reverseItems = [item].concat(reverseItems.slice(index)).slice(0, maxItems)\n\n    index = 0\n\n    handleChange()\n  }\n\n  function clear() {\n    debug('clear')\n\n    reverseItems = []\n    index = 0\n\n    handleChange()\n  }\n\n  function undo(): T | undefined {\n    if (canUndo()) {\n      const item = reverseItems[index]\n      index += 1\n\n      debug('undo', item)\n\n      handleChange()\n\n      return item\n    }\n\n    return undefined\n  }\n\n  function redo(): T | undefined {\n    if (canRedo()) {\n      index -= 1\n\n      debug('redo', reverseItems[index])\n\n      handleChange()\n\n      return reverseItems[index]\n    }\n\n    return undefined\n  }\n\n  return {\n    get\n  }\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { uniqueId } from '$lib/utils/uniqueId.js'\n  import { faCaretDown, faCaretRight } from '@fortawesome/free-solid-svg-icons'\n  import { debounce, isEmpty, noop } from 'lodash-es'\n  import Icon from 'svelte-awesome'\n  import { DEBOUNCE_DELAY } from '$lib/constants.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, getIn } from 'immutable-json-patch'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { transformModalStates, transformModalStateShared } from './transformModalStates.js'\n  import TransformWizard from './TransformWizard.svelte'\n  import TransformModalHeader from './TransformModalHeader.svelte'\n  import AbsolutePopup from './popup/AbsolutePopup.svelte'\n  import { createDebug } from '$lib/utils/debug.js'\n  import TreeMode from '../modes/treemode/TreeMode.svelte'\n  import type {\n    Content,\n    HistoryItem,\n    History,\n    JSONParser,\n    JSONPathParser,\n    OnChangeQueryLanguage,\n    OnClassName,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    QueryLanguage,\n    QueryLanguageOptions\n  } from '$lib/types.js'\n  import { onEscape } from '$lib/actions/onEscape.js'\n  import { readonlyProxy } from '$lib/utils/readonlyProxy.js'\n  import Modal from './Modal.svelte'\n  import { onMount } from 'svelte'\n  import { createHistoryInstance } from '$lib/logic/history'\n\n  const debug = createDebug('jsoneditor:TransformModal')\n\n  export let id = 'transform-modal-' + uniqueId()\n  export let json: unknown\n  export let rootPath: JSONPath = []\n\n  export let indentation: number | string\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onClassName: OnClassName\n\n  export let onTransform: (operations: JSONPatchDocument) => void\n  export let onClose: () => void\n\n  let refQueryInput: HTMLTextAreaElement\n\n  const historyInstance = createHistoryInstance<HistoryItem>({\n    onChange: (updatedHistory) => (history = updatedHistory)\n  })\n\n  let history: History<HistoryItem> = historyInstance.get()\n\n  let selectedJson: unknown | undefined\n  $: selectedJson = readonlyProxy(getIn(json, rootPath))\n  let selectedContent: Content\n  $: selectedContent = selectedJson ? { json: selectedJson } : { text: '' }\n\n  let fullscreen = false\n\n  const stateId = `${id}:${compileJSONPointer(rootPath)}`\n  const state = transformModalStates[stateId] ?? {}\n\n  // showWizard is not stored inside a stateId\n  let showWizard = transformModalStateShared.showWizard !== false\n  let showOriginal = transformModalStateShared.showOriginal !== false\n\n  let queryOptions = state.queryOptions ?? {}\n  let query = queryLanguageId === state.queryLanguageId && state.query ? state.query : ''\n  let isManual = state.isManual ?? false\n  let queryError: string | undefined = undefined\n\n  let previewError: string | undefined = undefined\n  let previewContent: Content = { text: '' }\n\n  if (!isManual) {\n    updateQueryByWizard(queryOptions)\n  }\n\n  onMount(() => {\n    refQueryInput?.focus()\n  })\n\n  function getSelectedQueryLanguage(queryLanguageId: string): QueryLanguage {\n    return queryLanguages.find((item) => item.id === queryLanguageId) ?? queryLanguages[0]\n  }\n\n  function updateQueryByWizard(newQueryOptions: QueryLanguageOptions) {\n    try {\n      queryOptions = newQueryOptions\n\n      query = getSelectedQueryLanguage(queryLanguageId).createQuery(selectedJson, newQueryOptions)\n      queryError = undefined\n      isManual = false\n\n      debug('updateQueryByWizard', { queryOptions, query, isManual })\n    } catch (err) {\n      queryError = String(err)\n    }\n  }\n\n  function handleChangeQuery(event: Event) {\n    query = (event.target as HTMLTextAreaElement).value\n    isManual = true\n    debug('handleChangeQuery', { query, isManual })\n  }\n\n  function previewTransform(previewJson: unknown | undefined, query: string) {\n    if (previewJson === undefined) {\n      previewContent = { text: '' }\n      previewError = 'Error: No JSON'\n      return\n    }\n\n    if (query.trim() === '') {\n      previewContent = { json: previewJson }\n      return\n    }\n\n    try {\n      debug('previewTransform', {\n        query\n      })\n\n      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(\n        previewJson,\n        query,\n        parser\n      )\n\n      previewContent = { json: jsonTransformed }\n      previewError = undefined\n    } catch (err) {\n      previewContent = { text: '' }\n      previewError = String(err)\n    }\n  }\n\n  const previewTransformDebounced = debounce(previewTransform, DEBOUNCE_DELAY)\n\n  $: {\n    previewTransformDebounced(selectedJson, query)\n  }\n\n  $: {\n    // remember the selected values for the next time we open the SortModal\n    // just in memory, not persisted\n    transformModalStates[stateId] = {\n      queryOptions,\n      query,\n      queryLanguageId,\n      isManual\n    }\n\n    debug('store state in memory', stateId, transformModalStates[stateId])\n  }\n\n  function handleTransform() {\n    if (selectedJson === undefined) {\n      previewContent = { text: '' }\n      previewError = 'Error: No JSON'\n      return\n    }\n\n    try {\n      debug('handleTransform', { query })\n      const jsonTransformed = getSelectedQueryLanguage(queryLanguageId).executeQuery(\n        selectedJson,\n        query,\n        parser\n      )\n\n      onTransform([\n        {\n          op: 'replace',\n          path: compileJSONPointer(rootPath),\n          value: jsonTransformed\n        }\n      ])\n\n      onClose()\n    } catch (err) {\n      // this should never occur since we can only press the Transform\n      // button when creating a preview was successful\n      console.error(err)\n      previewContent = { text: '' }\n      previewError = String(err)\n    }\n  }\n\n  function toggleShowWizard() {\n    showWizard = !showWizard\n\n    // not stored inside a stateId\n    transformModalStateShared.showWizard = showWizard\n  }\n\n  function toggleShowOriginal() {\n    showOriginal = !showOriginal\n\n    // not stored inside a stateId\n    transformModalStateShared.showOriginal = showOriginal\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    debug('handleChangeQueryLanguage', newQueryLanguageId)\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n\n    updateQueryByWizard(queryOptions)\n  }\n\n  function handleEscape() {\n    if (fullscreen) {\n      fullscreen = !fullscreen\n    } else {\n      onClose()\n    }\n  }\n</script>\n\n<Modal {onClose} className=\"jse-transform-modal\" {fullscreen}>\n  <div class=\"jse-transform-modal-inner\" use:onEscape={handleEscape}>\n    <AbsolutePopup>\n      <TransformModalHeader\n        {queryLanguages}\n        {queryLanguageId}\n        onChangeQueryLanguage={handleChangeQueryLanguage}\n        {onClose}\n        bind:fullscreen\n      />\n      <div class=\"jse-modal-contents\">\n        <div class=\"jse-main-contents\">\n          <div class=\"jse-query-contents\">\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Language</div>\n            </div>\n            <div class=\"jse-description\">\n              <!-- eslint-disable-next-line svelte/no-at-html-tags -->\n              {@html getSelectedQueryLanguage(queryLanguageId).description}\n            </div>\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Path</div>\n            </div>\n            <input\n              class=\"jse-path\"\n              type=\"text\"\n              readonly\n              title=\"Selected path\"\n              value={!isEmpty(rootPath) ? stringifyJSONPath(rootPath) : '(document root)'}\n            />\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">\n                <button type=\"button\" on:click={toggleShowWizard}>\n                  <Icon data={showWizard ? faCaretDown : faCaretRight} />\n                  Wizard\n                </button>\n              </div>\n            </div>\n            {#if showWizard}\n              {#if Array.isArray(selectedJson)}\n                <TransformWizard\n                  {queryOptions}\n                  json={selectedJson}\n                  onChange={updateQueryByWizard}\n                />\n                {#if queryError}\n                  <div class=\"query-error\">\n                    {queryError}\n                  </div>\n                {/if}\n              {:else}\n                (Only available for arrays, not for objects)\n              {/if}\n            {/if}\n\n            <div class=\"jse-label\">\n              <div class=\"jse-label-inner\">Query</div>\n            </div>\n            <textarea\n              bind:this={refQueryInput}\n              class=\"jse-query\"\n              spellcheck=\"false\"\n              on:input={handleChangeQuery}>{query}</textarea\n            >\n          </div>\n          <div class=\"jse-data-contents\" class:jse-hide-original-data={!showOriginal}>\n            <div class=\"jse-original-data\" class:jse-hide={!showOriginal}>\n              <div class=\"jse-label\">\n                <div class=\"jse-label-inner\">\n                  <button type=\"button\" on:click={toggleShowOriginal}>\n                    <Icon data={showOriginal ? faCaretDown : faCaretRight} />\n                    Original\n                  </button>\n                </div>\n              </div>\n              {#if showOriginal}\n                <TreeMode\n                  externalContent={selectedContent}\n                  externalSelection={undefined}\n                  {history}\n                  readOnly={true}\n                  mainMenuBar={false}\n                  navigationBar={false}\n                  {indentation}\n                  {escapeControlCharacters}\n                  {escapeUnicodeCharacters}\n                  {parser}\n                  {parseMemoizeOne}\n                  {onRenderValue}\n                  {onRenderMenu}\n                  {onRenderContextMenu}\n                  onError={console.error}\n                  onChange={noop}\n                  onChangeMode={noop}\n                  onSelect={noop}\n                  onUndo={noop}\n                  onRedo={noop}\n                  onFocus={noop}\n                  onBlur={noop}\n                  onSortModal={noop}\n                  onTransformModal={noop}\n                  onJSONEditorModal={noop}\n                  {onClassName}\n                  validator={undefined}\n                  {validationParser}\n                  {pathParser}\n                />\n              {/if}\n            </div>\n            <div class=\"jse-preview-data\">\n              <div class=\"jse-label\">\n                <div class=\"jse-label-inner\">Preview</div>\n              </div>\n              {#if !previewError}\n                <TreeMode\n                  externalContent={previewContent}\n                  externalSelection={undefined}\n                  {history}\n                  readOnly={true}\n                  mainMenuBar={false}\n                  navigationBar={false}\n                  {indentation}\n                  {escapeControlCharacters}\n                  {escapeUnicodeCharacters}\n                  {parser}\n                  {parseMemoizeOne}\n                  {onRenderValue}\n                  {onRenderMenu}\n                  {onRenderContextMenu}\n                  onError={console.error}\n                  onChange={noop}\n                  onChangeMode={noop}\n                  onSelect={noop}\n                  onUndo={noop}\n                  onRedo={noop}\n                  onFocus={noop}\n                  onBlur={noop}\n                  onSortModal={noop}\n                  onTransformModal={noop}\n                  onJSONEditorModal={noop}\n                  {onClassName}\n                  validator={undefined}\n                  {validationParser}\n                  {pathParser}\n                />\n              {:else}\n                <div class=\"jse-preview jse-error\">\n                  {previewError}\n                </div>\n              {/if}\n            </div>\n          </div>\n        </div>\n\n        <div class=\"jse-actions\">\n          <button\n            type=\"button\"\n            class=\"jse-primary\"\n            on:click={handleTransform}\n            use:focus\n            disabled={!!previewError}\n          >\n            Transform\n          </button>\n        </div>\n      </div>\n    </AbsolutePopup>\n  </div>\n</Modal>\n\n<style src=\"./TransformModal.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { getContext } from 'svelte'\n  import Icon from 'svelte-awesome'\n  import { faCog } from '@fortawesome/free-solid-svg-icons'\n  import SelectQueryLanguage from '../controls/selectQueryLanguage/SelectQueryLanguage.svelte'\n  import type { AbsolutePopupContext, OnChangeQueryLanguage, QueryLanguage } from '$lib/types.js'\n  import Header from './Header.svelte'\n\n  export let queryLanguages: QueryLanguage[]\n  export let queryLanguageId: string\n  export let fullscreen: boolean\n  export let onChangeQueryLanguage: OnChangeQueryLanguage\n  export let onClose: () => void\n\n  let refConfigButton: HTMLButtonElement | undefined\n  let popupId: number | undefined\n\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n\n  function openConfig() {\n    const props = {\n      queryLanguages,\n      queryLanguageId,\n      onChangeQueryLanguage: (queryLanguageId: string) => {\n        closeAbsolutePopup(popupId)\n        onChangeQueryLanguage(queryLanguageId)\n      }\n    }\n\n    popupId = openAbsolutePopup(SelectQueryLanguage, props, {\n      offsetTop: -2,\n      offsetLeft: 0,\n      anchor: refConfigButton,\n      closeOnOuterClick: true\n    })\n  }\n</script>\n\n<Header title=\"Transform\" fullScreenButton={true} bind:fullscreen {onClose}>\n  <button\n    slot=\"actions\"\n    type=\"button\"\n    bind:this={refConfigButton}\n    class=\"jse-config\"\n    class:hide={queryLanguages.length <= 1}\n    on:click={openConfig}\n    title=\"Select a query language\"\n  >\n    <Icon data={faCog} />\n  </button>\n</Header>\n\n<style src=\"./TransformModalHeader.scss\"></style>\n","export function noop() {\n  return undefined\n}\n","/**\n * Return a human readable document size\n * For example formatSize(7570718) outputs '7.6 MB'\n * @param size\n * @param kilo Is 1000 by default, you can specify 1024 if you\n *                             want the output in KiB\n * @return Returns a human readable size\n */\nexport function formatSize(size: number, kilo = 1000): string {\n  if (size < 0.9 * kilo) {\n    return size.toFixed() + ' B'\n  }\n\n  const KB = size / kilo\n  if (KB < 0.9 * kilo) {\n    return KB.toFixed(1) + ' KB'\n  }\n\n  const MB = KB / kilo\n  if (MB < 0.9 * kilo) {\n    return MB.toFixed(1) + ' MB'\n  }\n\n  const GB = MB / kilo\n  if (GB < 0.9 * kilo) {\n    return GB.toFixed(1) + ' GB'\n  }\n\n  const TB = GB / kilo\n  return TB.toFixed(1) + ' TB'\n}\n","import { HighlightStyle, syntaxHighlighting } from '@codemirror/language'\nimport { tags } from '@lezer/highlight'\n\nconst highlightStyle = HighlightStyle.define([\n  { tag: tags.propertyName, color: 'var(--internal-key-color)' }, // keys\n  { tag: tags.number, color: 'var(--internal-value-color-number)' },\n  { tag: tags.bool, color: 'var(--internal-value-color-boolean)' },\n  { tag: tags.string, color: 'var(--internal-value-color-string)' },\n  { tag: tags.keyword, color: 'var(--internal-value-color-null)' } // null\n])\n\nexport const highlighter = syntaxHighlighting(highlightStyle)\n\n// TODO: remove workaround when not needed anymore\n// Workaround for the error \"CodeMirror plugin crashed: TypeError: tags3 is undefined\"\n// thrown when using the json() language from '@codemirror/lang-json'\n//\n// Note that a plain CodeSandbox with parcel and code mirror v6.0.0,\n// so it is maybe related to Vite\n//\n// See https://discuss.codemirror.net/t/highlighting-that-seems-ignored-in-cm6/4320/15\nconst originalStyle = highlightStyle.style\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\n// noinspection JSConstantReassignment\nhighlightStyle.style = (tags) => originalStyle(tags || [])\n","import { getIndentUnit } from \"@codemirror/language\";\nimport { RangeSetBuilder } from \"@codemirror/state\";\nimport { Decoration, ViewPlugin, } from \"@codemirror/view\";\nclass WrappedLineIndent {\n    constructor(view) {\n        this.view = view;\n        this.indentUnit = getIndentUnit(view.state);\n        this.initialPaddingLeft = null;\n        this.isChrome = window === null || window === void 0 ? void 0 : window.navigator.userAgent.includes(\"Chrome\");\n        this.generate(view.state);\n    }\n    update(update) {\n        const indentUnit = getIndentUnit(update.state);\n        if (indentUnit !== this.indentUnit ||\n            update.docChanged ||\n            update.viewportChanged) {\n            this.indentUnit = indentUnit;\n            this.generate(update.state);\n        }\n    }\n    generate(state) {\n        const builder = new RangeSetBuilder();\n        if (this.initialPaddingLeft) {\n            this.addStyleToBuilder(builder, state, this.initialPaddingLeft);\n        }\n        else {\n            this.view.requestMeasure({\n                read: (view) => {\n                    const lineElement = view.contentDOM.querySelector(\".cm-line\");\n                    if (lineElement) {\n                        this.initialPaddingLeft = window\n                            .getComputedStyle(lineElement)\n                            .getPropertyValue(\"padding-left\");\n                        this.addStyleToBuilder(builder, view.state, this.initialPaddingLeft);\n                    }\n                    this.decorations = builder.finish();\n                },\n            });\n        }\n        this.decorations = builder.finish();\n    }\n    addStyleToBuilder(builder, state, initialPaddingLeft) {\n        const visibleLines = this.getVisibleLines(state);\n        for (const line of visibleLines) {\n            const { numColumns, containsTab } = this.numColumns(line.text, state.tabSize);\n            const paddingValue = `calc(${numColumns + this.indentUnit}ch + ${initialPaddingLeft})`;\n            const textIndentValue = this.isChrome\n                ? `calc(-${numColumns + this.indentUnit}ch - ${containsTab ? 1 : 0}px)`\n                : `-${numColumns + this.indentUnit}ch`;\n            builder.add(line.from, line.from, Decoration.line({\n                attributes: {\n                    style: `padding-left: ${paddingValue}; text-indent: ${textIndentValue};`,\n                },\n            }));\n        }\n    }\n    // Get all lines that are currently visible in the viewport.\n    getVisibleLines(state) {\n        const lines = new Set();\n        let lastLine = null;\n        for (const { from, to } of this.view.visibleRanges) {\n            let pos = from;\n            while (pos <= to) {\n                const line = state.doc.lineAt(pos);\n                if (lastLine !== line) {\n                    lines.add(line);\n                    lastLine = line;\n                }\n                pos = line.to + 1;\n            }\n        }\n        return lines;\n    }\n    numColumns(str, tabSize) {\n        let cols = 0;\n        let containsTab = false;\n        loop: for (let i = 0; i < str.length; i++) {\n            switch (str[i]) {\n                case \" \": {\n                    cols += 1;\n                    continue loop;\n                }\n                case \"\\t\": {\n                    cols += tabSize - (cols % tabSize);\n                    containsTab = true;\n                    continue loop;\n                }\n                case \"\\r\": {\n                    continue loop;\n                }\n                default: {\n                    break loop;\n                }\n            }\n        }\n        return { numColumns: cols, containsTab };\n    }\n}\nexport const wrappedLineIndent = [\n    ViewPlugin.fromClass(WrappedLineIndent, {\n        decorations: (v) => v.decorations,\n    }),\n];\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faExclamationTriangle,\n    faEye,\n    faTimes,\n    faWrench\n  } from '@fortawesome/free-solid-svg-icons'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { immutableJSONPatch, revertJSONPatch } from 'immutable-json-patch'\n  import { jsonrepair } from 'jsonrepair'\n  import { debounce, isEqual, uniqueId } from 'lodash-es'\n  import { onDestroy, onMount, tick } from 'svelte'\n  import {\n    JSON_STATUS_INVALID,\n    JSON_STATUS_REPAIRABLE,\n    JSON_STATUS_VALID,\n    MAX_CHARACTERS_TEXT_PREVIEW,\n    MAX_DOCUMENT_SIZE_TEXT_MODE,\n    TEXT_MODE_ONCHANGE_DELAY\n  } from '$lib/constants.js'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    getWindow\n  } from '$lib/utils/domUtils.js'\n  import { formatSize } from '$lib/utils/fileUtils.js'\n  import { findTextLocation, getText, needsFormatting } from '$lib/utils/jsonUtils.js'\n  import { createFocusTracker } from '../../controls/createFocusTracker.js'\n  import Message from '../../controls/Message.svelte'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import TextMenu from './menu/TextMenu.svelte'\n  import {\n    Annotation,\n    ChangeSet,\n    Compartment,\n    EditorSelection,\n    EditorState,\n    type Extension\n  } from '@codemirror/state'\n  import {\n    crosshairCursor,\n    drawSelection,\n    dropCursor,\n    EditorView,\n    highlightActiveLine,\n    highlightActiveLineGutter,\n    highlightSpecialChars,\n    keymap,\n    lineNumbers,\n    rectangularSelection,\n    type ViewUpdate\n  } from '@codemirror/view'\n  import { defaultKeymap, indentWithTab } from '@codemirror/commands'\n  import type { Diagnostic } from '@codemirror/lint'\n  import { linter, lintGutter, lintKeymap } from '@codemirror/lint'\n  import { json as jsonLang } from '@codemirror/lang-json'\n  import {\n    bracketMatching,\n    defaultHighlightStyle,\n    foldGutter,\n    foldKeymap,\n    indentOnInput,\n    indentUnit,\n    syntaxHighlighting\n  } from '@codemirror/language'\n  import {\n    closeSearchPanel,\n    highlightSelectionMatches,\n    openSearchPanel,\n    search,\n    searchKeymap\n  } from '@codemirror/search'\n  import {\n    autocompletion,\n    closeBrackets,\n    closeBracketsKeymap,\n    completionKeymap\n  } from '@codemirror/autocomplete'\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore\n  import jsonSourceMap from 'json-source-map'\n  import StatusBar from './StatusBar.svelte'\n  import { highlighter } from './codemirror/codemirror-theme.js'\n  import type {\n    Content,\n    ContentErrors,\n    History,\n    HistoryItem,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnError,\n    OnFocus,\n    OnRedo,\n    OnRenderMenuInternal,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    OnUndo,\n    ParseError,\n    RichValidationError,\n    TextHistoryItem,\n    TextSelection,\n    TransformModalOptions,\n    ValidationError,\n    Validator\n  } from '$lib/types.js'\n  import { Mode, SelectionType, ValidationSeverity } from '$lib/types.js'\n  import {\n    isContentParseError,\n    isContentValidationErrors,\n    isTextHistoryItem\n  } from '$lib/typeguards.js'\n  import memoizeOne from 'memoize-one'\n  import { validateText } from '$lib/logic/validation.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { faJSONEditorFormat } from '$lib/img/customFontawesomeIcons.js'\n  import { indentationMarkers } from '@replit/codemirror-indentation-markers'\n  import { isTextSelection } from '$lib/logic/selection.js'\n  import { wrappedLineIndent } from 'codemirror-wrapped-line-indent/dist/index.js' // ensure loading ESM, otherwise the vitest test fail\n\n  export let readOnly: boolean\n  export let mainMenuBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let history: History<HistoryItem>\n  export let indentation: number | string\n  export let tabSize: number\n  export let escapeUnicodeCharacters: boolean\n  export let parser: JSONParser\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onUndo: OnUndo\n  export let onRedo: OnRedo\n  export let onError: OnError\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n\n  const debug = createDebug('jsoneditor:TextMode')\n\n  const formatCompactKeyBinding = {\n    key: 'Mod-i',\n    run: handleFormat,\n    shift: handleCompact,\n    preventDefault: true\n  }\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  let codeMirrorRef: HTMLDivElement\n  let domTextMode: HTMLDivElement\n  let codeMirrorView: EditorView\n  let editorState: EditorState\n\n  let acceptTooLarge = false\n  let askToFormatApplied = askToFormat\n\n  let validationErrors: ValidationError[] = []\n  const linterCompartment = new Compartment()\n  const readOnlyCompartment = new Compartment()\n  const indentCompartment = new Compartment()\n  const tabSizeCompartment = new Compartment()\n  const themeCompartment = new Compartment()\n\n  let content: Content = externalContent\n  let text = getText(content, indentation, parser) // text is just a cached version of content.text or parsed content.json\n\n  let historyAnnotation = Annotation.define()\n\n  let historyUpdatesQueue: ViewUpdate[] | null = null\n\n  function addHistoryItem(): boolean {\n    if (!historyUpdatesQueue || historyUpdatesQueue.length === 0) {\n      return false\n    }\n\n    // merge changes and create the inverse changes\n    const startState = historyUpdatesQueue[0].startState\n    const endState = historyUpdatesQueue[historyUpdatesQueue.length - 1].state\n    const mergedChanges = historyUpdatesQueue\n      .map((update) => update.changes)\n      .reduce((mergedChanges, change) => mergedChanges.compose(change))\n    const inverseChanges = mergedChanges.invert(startState.doc)\n\n    // create a history item with undo/redo actions\n    const item: TextHistoryItem = {\n      type: 'text',\n      undo: {\n        changes: inverseChanges.toJSON(),\n        selection: toTextSelection(startState.selection)\n      },\n      redo: {\n        changes: mergedChanges.toJSON(),\n        selection: toTextSelection(endState.selection)\n      }\n    }\n\n    debug('add history item', item)\n\n    history.add(item)\n\n    historyUpdatesQueue = null\n    return true\n  }\n\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters: false,\n    escapeUnicodeCharacters\n  })\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: setCodeMirrorContent(externalContent, false, false)\n  $: applyExternalSelection(externalSelection)\n  $: updateLinter(validator)\n  $: updateIndentation(indentation)\n  $: updateTabSize(tabSize)\n  $: updateReadOnly(readOnly)\n\n  // force updating the text when escapeUnicodeCharacters changes\n  let previousEscapeUnicodeCharacters = escapeUnicodeCharacters\n  $: {\n    if (previousEscapeUnicodeCharacters !== escapeUnicodeCharacters) {\n      previousEscapeUnicodeCharacters = escapeUnicodeCharacters\n      forceUpdateText()\n    }\n  }\n\n  onMount(async () => {\n    if (isSSR) {\n      return\n    }\n\n    try {\n      codeMirrorView = createCodeMirrorView({\n        target: codeMirrorRef,\n        initialText: !disableTextEditor(text, acceptTooLarge)\n          ? normalization.escapeValue(text)\n          : '',\n        readOnly,\n        indentation\n      })\n    } catch (err) {\n      // TODO: report error to the user\n      console.error(err)\n    }\n  })\n\n  onDestroy(() => {\n    flush()\n\n    if (codeMirrorView) {\n      debug('Destroy CodeMirror editor')\n      codeMirrorView.destroy()\n    }\n  })\n\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  export function focus() {\n    if (codeMirrorView) {\n      debug('focus')\n      codeMirrorView.focus()\n    }\n  }\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(domTextMode),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(domTextMode),\n    onFocus,\n    onBlur: () => {\n      flush()\n      onBlur()\n    }\n  })\n\n  export function patch(operations: JSONPatchDocument): JSONPatchResult {\n    return handlePatch(operations, false)\n  }\n\n  export function handlePatch(operations: JSONPatchDocument, emitChange: boolean): JSONPatchResult {\n    debug('handlePatch', operations, emitChange)\n\n    const previousJson = parser.parse(text)\n    const updatedJson = immutableJSONPatch(previousJson, operations)\n    const undo = revertJSONPatch(previousJson, operations)\n    const updatedContent = {\n      text: parser.stringify(updatedJson, null, indentation) as string\n    }\n\n    setCodeMirrorContent(updatedContent, emitChange, false)\n\n    return {\n      json: updatedJson,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handleFormat(): boolean {\n    debug('format')\n\n    if (readOnly) {\n      return false\n    }\n\n    try {\n      const updatedJson = parser.parse(text)\n      const updatedContent = {\n        text: parser.stringify(updatedJson, null, indentation) as string\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      askToFormatApplied = askToFormat // reset to the original value\n\n      return true\n    } catch (err) {\n      onError(err as Error)\n    }\n\n    return false\n  }\n\n  function handleCompact(): boolean {\n    debug('compact')\n\n    if (readOnly) {\n      return false\n    }\n\n    try {\n      const updatedJson = parser.parse(text)\n      const updatedContent = {\n        text: parser.stringify(updatedJson) as string\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      askToFormatApplied = false\n\n      return true\n    } catch (err) {\n      onError(err as Error)\n    }\n\n    return false\n  }\n\n  function handleRepair() {\n    debug('repair')\n\n    if (readOnly) {\n      return\n    }\n\n    try {\n      const updatedContent = {\n        text: jsonrepair(text)\n      }\n\n      setCodeMirrorContent(updatedContent, true, false)\n\n      jsonStatus = JSON_STATUS_VALID\n      jsonParseError = undefined\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleSort() {\n    if (readOnly) {\n      return\n    }\n\n    try {\n      const json = parser.parse(text)\n\n      modalOpen = true\n\n      onSortModal({\n        id: sortModalId,\n        json,\n        rootPath: [],\n        onSort: async ({ operations }) => {\n          debug('onSort', operations)\n          handlePatch(operations, true)\n        },\n        onClose: () => {\n          modalOpen = false\n          focus()\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal({\n    id,\n    rootPath,\n    onTransform,\n    onClose\n  }: TransformModalOptions) {\n    try {\n      const json = parser.parse(text)\n\n      modalOpen = true\n\n      onTransformModal({\n        id: id || transformModalId,\n        json,\n        rootPath: rootPath || [],\n        onTransform: (operations) => {\n          if (onTransform) {\n            onTransform({\n              operations,\n              json,\n              transformedJson: immutableJSONPatch(json, operations)\n            })\n          } else {\n            debug('onTransform', operations)\n            handlePatch(operations, true)\n          }\n        },\n        onClose: () => {\n          modalOpen = false\n          focus()\n          if (onClose) {\n            onClose()\n          }\n        }\n      })\n    } catch (err) {\n      onError(err as Error)\n    }\n  }\n\n  function handleTransform() {\n    if (readOnly) {\n      return\n    }\n\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function handleToggleSearch() {\n    if (codeMirrorView) {\n      // TODO: figure out the proper way to detect whether the search panel is open\n      if (codeMirrorRef && codeMirrorRef.querySelector('.cm-search')) {\n        closeSearchPanel(codeMirrorView)\n      } else {\n        openSearchPanel(codeMirrorView)\n      }\n    }\n  }\n\n  function handleUndo(): boolean {\n    if (readOnly) {\n      return false\n    }\n\n    // first flush any pending changes\n    flush()\n\n    const item = history.undo()\n    debug('undo', item)\n    if (!isTextHistoryItem(item)) {\n      onUndo(item)\n\n      return false\n    }\n\n    codeMirrorView.dispatch({\n      annotations: historyAnnotation.of('undo'),\n      changes: ChangeSet.fromJSON(item.undo.changes),\n      selection: EditorSelection.fromJSON(item.undo.selection),\n      scrollIntoView: true\n    })\n\n    return true\n  }\n\n  function handleRedo(): boolean {\n    if (readOnly) {\n      return false\n    }\n\n    // first flush any pending changes\n    flush()\n\n    const item = history.redo()\n    debug('redo', item)\n    if (!isTextHistoryItem(item)) {\n      onRedo(item)\n\n      return false\n    }\n\n    codeMirrorView.dispatch({\n      annotations: historyAnnotation.of('redo'),\n      changes: ChangeSet.fromJSON(item.redo.changes),\n      selection: EditorSelection.fromJSON(item.redo.selection),\n      scrollIntoView: true\n    })\n\n    return true\n  }\n\n  function handleAcceptTooLarge() {\n    acceptTooLarge = true\n    setCodeMirrorContent(externalContent, true, true)\n  }\n\n  function handleSwitchToTreeMode() {\n    onChangeMode(Mode.tree)\n  }\n\n  function cancelLoadTooLarge() {\n    // copy the latest contents of the text editor again into text\n    onChangeCodeMirrorValue()\n  }\n\n  function handleSelectValidationError(validationError: ValidationError) {\n    debug('select validation error', validationError)\n\n    const { from, to } = toRichValidationError(validationError)\n    if (from === undefined || to === undefined) {\n      return\n    }\n\n    // we take \"to\" as head, not as anchor, because the scrollIntoView will\n    // move to the head, and when a large whole object is selected as a whole,\n    // we want to scroll to the start of the object and not the end\n    setSelection(from, to)\n\n    focus()\n  }\n\n  function handleSelectParseError(parseError: ParseError) {\n    debug('select parse error', parseError)\n\n    const richParseError = toRichParseError(parseError, false)\n    const from = richParseError.from != null ? richParseError.from : 0\n    const to = richParseError.to != null ? richParseError.to : 0\n\n    // we take \"to\" as head, not as anchor, because the scrollIntoView will\n    // move to the head, and when a large whole object is selected as a whole,\n    // we want to scroll to the start of the object and not the end\n    setSelection(from, to)\n\n    focus()\n  }\n\n  function setSelection(anchor: number, head: number) {\n    debug('setSelection', { anchor, head })\n\n    if (codeMirrorView) {\n      codeMirrorView.dispatch(\n        codeMirrorView.state.update({\n          selection: { anchor, head },\n          scrollIntoView: true\n        })\n      )\n    }\n  }\n\n  function handleDoubleClick(_event: MouseEvent, view: EditorView) {\n    // When the user double-clicked right from a bracket [ or {,\n    // select the contents of the array or object\n    if (view.state.selection.ranges.length === 1) {\n      const range = view.state.selection.ranges[0]\n      const selectedText = text.slice(range.from, range.to)\n      if (selectedText === '{' || selectedText === '[') {\n        const jsmap = jsonSourceMap.parse(text)\n        const path = Object.keys(jsmap.pointers).find((path) => {\n          const pointer = jsmap.pointers[path]\n          return pointer.value?.pos === range.from\n        })\n        const pointer = jsmap.pointers[path]\n\n        if (path && pointer && pointer.value && pointer.valueEnd) {\n          debug('pointer found, selecting inner contents of path:', path, pointer)\n          const anchor = pointer.value.pos + 1\n          const head = pointer.valueEnd.pos - 1\n          setSelection(anchor, head)\n        }\n      }\n    }\n  }\n\n  function createLinter() {\n    return linter(linterCallback, { delay: TEXT_MODE_ONCHANGE_DELAY })\n  }\n\n  function createCodeMirrorView({\n    target,\n    initialText,\n    readOnly,\n    indentation\n  }: {\n    target: HTMLDivElement\n    initialText: string\n    readOnly: boolean\n    indentation: number | string\n  }): EditorView {\n    debug('Create CodeMirror editor', { readOnly, indentation })\n\n    const selection = isValidSelection(externalSelection, initialText)\n      ? fromTextSelection(externalSelection)\n      : undefined\n\n    const state = EditorState.create({\n      doc: initialText,\n      selection,\n      extensions: [\n        keymap.of([indentWithTab, formatCompactKeyBinding]),\n        linterCompartment.of(createLinter()),\n        lintGutter(),\n        lineNumbers(),\n        highlightActiveLineGutter(),\n        highlightSpecialChars(),\n        foldGutter(),\n        drawSelection(),\n        dropCursor(),\n        EditorState.allowMultipleSelections.of(true),\n        indentOnInput(),\n        syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n        bracketMatching(),\n        closeBrackets(),\n        autocompletion(),\n        rectangularSelection(),\n        crosshairCursor(),\n        highlightActiveLine(),\n        highlightSelectionMatches(),\n        keymap.of([\n          ...closeBracketsKeymap,\n          ...defaultKeymap,\n          ...searchKeymap,\n          { key: 'Mod-z', run: handleUndo, preventDefault: true },\n          { key: 'Mod-y', mac: 'Mod-Shift-z', run: handleRedo, preventDefault: true },\n          { key: 'Ctrl-Shift-z', run: handleRedo, preventDefault: true },\n          ...foldKeymap,\n          ...completionKeymap,\n          ...lintKeymap\n        ]),\n        highlighter,\n        indentationMarkers({ hideFirstIndent: true }),\n        EditorView.domEventHandlers({\n          dblclick: handleDoubleClick\n        }),\n        EditorView.updateListener.of((update) => {\n          editorState = update.state\n\n          if (update.docChanged) {\n            const isCustomHistoryEvent = update.transactions.some(\n              (transaction) => !!transaction.annotation(historyAnnotation)\n            )\n\n            if (!isCustomHistoryEvent) {\n              historyUpdatesQueue = [...(historyUpdatesQueue ?? []), update]\n            }\n\n            onChangeCodeMirrorValueDebounced()\n          }\n\n          if (update.selectionSet) {\n            // note that emitOnSelect is invoked in onChangeCodeMirrorValue too,\n            // right after firing onChange. Hence, the else if here, we do not want to fire it twice.\n            emitOnSelect()\n          }\n        }),\n        jsonLang(),\n        search({\n          top: true\n        }),\n        EditorView.lineWrapping,\n        readOnlyCompartment.of(EditorState.readOnly.of(readOnly)),\n        tabSizeCompartment.of(EditorState.tabSize.of(tabSize)),\n        indentCompartment.of(createIndent(indentation)),\n        themeCompartment.of(EditorView.theme({}, { dark: hasDarkTheme() }))\n      ]\n    })\n\n    codeMirrorView = new EditorView({\n      state,\n      parent: target\n    })\n\n    if (selection) {\n      // important to do via dispatch, since that is executed on the next tick.\n      // Otherwise, the editor is not scrolled down enough when the statusbar is rendered on the next tick\n      codeMirrorView.dispatch(\n        codeMirrorView.state.update({\n          selection: selection.main,\n          scrollIntoView: true // FIXME: scrollIntoView also affects scroll of the main page, possibly causing the main page to scroll when jsoneditor has an initial selection\n        })\n      )\n    }\n\n    return codeMirrorView\n  }\n\n  function getCodeMirrorValue() {\n    return codeMirrorView ? normalization.unescapeValue(codeMirrorView.state.doc.toString()) : ''\n  }\n\n  function hasDarkTheme() {\n    return codeMirrorRef\n      ? getComputedStyle(codeMirrorRef).getPropertyValue('--jse-theme').includes('dark')\n      : false\n  }\n\n  function isValidSelection(selection: JSONEditorSelection | undefined, text: string): boolean {\n    if (!isTextSelection(selection)) {\n      return false\n    }\n\n    return selection.ranges.every((range) => range.anchor < text.length && range.head < text.length)\n  }\n\n  function toRichValidationError(validationError: ValidationError): RichValidationError {\n    const { path, message, severity } = validationError\n    const { line, column, from, to } = findTextLocation(normalization.escapeValue(text), path)\n\n    return {\n      path,\n      line,\n      column,\n      from,\n      to,\n      message,\n      severity,\n      actions: []\n    }\n  }\n\n  function toRichParseError(parseError: ParseError, isRepairable: boolean): RichValidationError {\n    const { line, column, position, message } = parseError\n\n    return {\n      path: [] as JSONPath,\n      line,\n      column,\n      from: position,\n      to: position,\n      severity: ValidationSeverity.error,\n      message,\n      actions:\n        isRepairable && !readOnly\n          ? [\n              {\n                name: 'Auto repair',\n                apply: () => handleRepair()\n              }\n            ]\n          : undefined\n    }\n  }\n\n  function toDiagnostic(error: RichValidationError): Diagnostic {\n    return {\n      from: error.from || 0,\n      to: error.to || 0,\n      message: error.message || '',\n      actions: error.actions as Diagnostic['actions'],\n      severity: error.severity\n    }\n  }\n\n  function setCodeMirrorContent(newContent: Content, emitChange: boolean, forceUpdate: boolean) {\n    const newText = getText(newContent, indentation, parser)\n    const isChanged = !isEqual(newContent, content)\n    const previousContent = content\n\n    debug('setCodeMirrorContent', { isChanged, emitChange, forceUpdate })\n\n    if (!codeMirrorView || (!isChanged && !forceUpdate)) {\n      return\n    }\n\n    content = newContent\n    text = newText\n\n    if (!disableTextEditor(text, acceptTooLarge)) {\n      // keep state\n      // to reset state: codeMirrorView.setState(EditorState.create({doc: text, extensions: ...}))\n      codeMirrorView.dispatch({\n        changes: {\n          from: 0,\n          to: codeMirrorView.state.doc.length,\n          insert: normalization.escapeValue(text)\n        }\n      })\n    }\n\n    addHistoryItem()\n\n    if (isChanged && emitChange) {\n      emitOnChange(content, previousContent)\n    }\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (!isTextSelection(externalSelection)) {\n      return\n    }\n\n    const selection = fromTextSelection(externalSelection)\n    if (codeMirrorView && selection && (!editorState || !editorState.selection.eq(selection))) {\n      debug('applyExternalSelection', selection)\n\n      // note that we cannot clear the selection (we could maybe set the cursor to 0 but that's not really what we want)\n      codeMirrorView.dispatch({ selection })\n    }\n  }\n\n  function fromTextSelection(\n    selection: JSONEditorSelection | undefined\n  ): EditorSelection | undefined {\n    return isTextSelection(selection) ? EditorSelection.fromJSON(selection) : undefined\n  }\n\n  /**\n   * Force refreshing the editor, for example after changing the font size\n   * to update the positioning of the line numbers in the gutter\n   */\n  export async function refresh(): Promise<void> {\n    debug('refresh')\n\n    // update the theme (light/dark), but also, as a side effect,\n    // refresh the font size of the line numbers in the gutter\n    await updateTheme()\n  }\n\n  function forceUpdateText() {\n    debug('forceUpdateText', { escapeUnicodeCharacters })\n\n    if (codeMirrorView) {\n      codeMirrorView.dispatch({\n        changes: {\n          from: 0,\n          to: codeMirrorView.state.doc.length,\n          insert: normalization.escapeValue(text)\n        }\n      })\n    }\n  }\n\n  function onChangeCodeMirrorValue() {\n    if (!codeMirrorView) {\n      return\n    }\n\n    const codeMirrorText = getCodeMirrorValue()\n\n    const isChanged = codeMirrorText !== text\n    debug('onChangeCodeMirrorValue', { isChanged })\n    if (!isChanged) {\n      return\n    }\n\n    const previousContent = content\n    text = codeMirrorText\n    content = { text }\n\n    addHistoryItem()\n\n    emitOnChange(content, previousContent)\n\n    // We emit OnSelect on the next tick to cater for the case where\n    // the user changes the content directly inside the OnChange callback.\n    // This change will be dispatched by Svelte on the next tick. Before\n    // that tick, emitOnSelect would be fired based on the \"old\" contents,\n    // which may be out of range when the replacement by the user is shorter.\n    tick().then(emitOnSelect)\n  }\n\n  function updateLinter(validator: Validator | undefined) {\n    debug('updateLinter', validator)\n\n    if (!codeMirrorView) {\n      return\n    }\n\n    codeMirrorView.dispatch({\n      effects: linterCompartment.reconfigure(createLinter())\n    })\n  }\n\n  function updateIndentation(indentation: number | string) {\n    if (codeMirrorView) {\n      debug('updateIndentation', indentation)\n\n      codeMirrorView.dispatch({\n        effects: indentCompartment.reconfigure(createIndent(indentation))\n      })\n    }\n  }\n\n  function updateTabSize(tabSize: number) {\n    if (codeMirrorView) {\n      debug('updateTabSize', tabSize)\n\n      codeMirrorView.dispatch({\n        effects: tabSizeCompartment.reconfigure(EditorState.tabSize.of(tabSize))\n      })\n    }\n  }\n\n  function updateReadOnly(readOnly: boolean) {\n    if (codeMirrorView) {\n      debug('updateReadOnly', readOnly)\n\n      codeMirrorView.dispatch({\n        effects: [readOnlyCompartment.reconfigure(EditorState.readOnly.of(readOnly))]\n      })\n    }\n  }\n\n  async function updateTheme(): Promise<void> {\n    // we check the theme on the next tick, to make sure the page\n    // is re-rendered with (possibly) changed CSS variables\n    await tick()\n\n    if (codeMirrorView) {\n      const dark = hasDarkTheme()\n      debug('updateTheme', { dark })\n\n      codeMirrorView.dispatch({\n        effects: [themeCompartment.reconfigure(EditorView.theme({}, { dark }))]\n      })\n    }\n  }\n\n  function createIndent(indentation: number | string): Extension[] {\n    const indent = indentUnit.of(\n      typeof indentation === 'number' ? ' '.repeat(indentation) : indentation\n    )\n\n    // We disable wrappedLineIndent in case of tabs to work around a bug:\n    // https://github.com/fauzi9331/codemirror-wrapped-line-indent/issues/2\n    return indentation === '\\t' ? [indent] : [indent, wrappedLineIndent]\n  }\n\n  // debounce the input: when pressing Enter at the end of a line, two change\n  // events are fired: one with the new Return character, and a second with\n  // indentation added on the new line. This causes a race condition when used\n  // for example in React. Debouncing the onChange events also results in not\n  // firing a change event with every character that a user types, but only as\n  // soon as the user stops typing.\n  const onChangeCodeMirrorValueDebounced = debounce(\n    onChangeCodeMirrorValue,\n    TEXT_MODE_ONCHANGE_DELAY\n  )\n\n  export function flush() {\n    onChangeCodeMirrorValueDebounced.flush()\n  }\n\n  function emitOnChange(content: Content, previousContent: Content) {\n    if (onChange) {\n      onChange(content, previousContent, {\n        contentErrors: validate(),\n        patchResult: undefined\n      })\n    }\n  }\n\n  function emitOnSelect() {\n    onSelect(toTextSelection(editorState.selection))\n  }\n\n  function toTextSelection(selection: EditorSelection): TextSelection {\n    return {\n      type: SelectionType.text,\n      ...selection.toJSON()\n    }\n  }\n\n  function disableTextEditor(text: string, acceptTooLarge: boolean): boolean {\n    const tooLarge = text ? text.length > MAX_DOCUMENT_SIZE_TEXT_MODE : false\n    return tooLarge && !acceptTooLarge\n  }\n\n  let jsonStatus = JSON_STATUS_VALID\n\n  let jsonParseError: ParseError | undefined\n\n  function linterCallback(): Diagnostic[] {\n    if (disableTextEditor(text, acceptTooLarge)) {\n      return []\n    }\n\n    const contentErrors = validate()\n\n    if (isContentParseError(contentErrors)) {\n      const { parseError, isRepairable } = contentErrors\n\n      return [toDiagnostic(toRichParseError(parseError, isRepairable))]\n    }\n\n    if (isContentValidationErrors(contentErrors)) {\n      return contentErrors.validationErrors.map(toRichValidationError).map(toDiagnostic)\n    }\n\n    return []\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate:start')\n\n    flush()\n\n    const contentErrors = memoizedValidateText(\n      normalization.escapeValue(text),\n      validator,\n      parser,\n      validationParser\n    )\n\n    if (isContentParseError(contentErrors)) {\n      jsonStatus = contentErrors.isRepairable ? JSON_STATUS_REPAIRABLE : JSON_STATUS_INVALID\n      jsonParseError = contentErrors.parseError\n      validationErrors = []\n    } else {\n      jsonStatus = JSON_STATUS_VALID\n      jsonParseError = undefined\n      validationErrors = contentErrors?.validationErrors || []\n    }\n\n    debug('validate:end')\n\n    return contentErrors\n  }\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidateText = memoizeOne(validateText)\n\n  function handleShowMe() {\n    if (jsonParseError) {\n      handleSelectParseError(jsonParseError)\n    }\n  }\n\n  const repairActionShowMe = {\n    icon: faEye,\n    text: 'Show me',\n    title: 'Move to the parse error location',\n    onClick: handleShowMe\n  }\n\n  $: repairActions =\n    jsonStatus === JSON_STATUS_REPAIRABLE && !readOnly\n      ? [\n          {\n            icon: faWrench,\n            text: 'Auto repair',\n            title: 'Automatically repair JSON',\n            onClick: handleRepair\n          },\n          repairActionShowMe\n        ]\n      : [repairActionShowMe]\n</script>\n\n<div class=\"jse-text-mode\" class:no-main-menu={!mainMenuBar} bind:this={domTextMode}>\n  {#if mainMenuBar}\n    {@const isNewDocument = text.length === 0}\n\n    <TextMenu\n      {readOnly}\n      onFormat={handleFormat}\n      onCompact={handleCompact}\n      onSort={handleSort}\n      onTransform={handleTransform}\n      onToggleSearch={handleToggleSearch}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      canFormat={!isNewDocument}\n      canCompact={!isNewDocument}\n      canSort={!isNewDocument}\n      canTransform={!isNewDocument}\n      canUndo={history.canUndo}\n      canRedo={history.canRedo}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if !isSSR}\n    {@const editorDisabled = disableTextEditor(text, acceptTooLarge)}\n\n    <div class=\"jse-contents\" class:jse-hidden={editorDisabled} bind:this={codeMirrorRef}></div>\n\n    {#if editorDisabled}\n      <Message\n        icon={faExclamationTriangle}\n        type=\"error\"\n        message={`The JSON document is larger than ${formatSize(\n          MAX_DOCUMENT_SIZE_TEXT_MODE,\n          1024\n        )}, ` +\n          `and may crash your browser when loading it in text mode. Actual size: ${formatSize(\n            text.length,\n            1024\n          )}.`}\n        actions={[\n          {\n            text: 'Open anyway',\n            title: 'Open the document in text mode. This may freeze or crash your browser.',\n            onClick: handleAcceptTooLarge\n          },\n          {\n            text: 'Open in tree mode',\n            title: 'Open the document in tree mode. Tree mode can handle large documents.',\n            onClick: handleSwitchToTreeMode\n          },\n          {\n            text: 'Cancel',\n            title: 'Cancel opening this large document.',\n            onClick: cancelLoadTooLarge\n          }\n        ]}\n        onClose={focus}\n      />\n\n      <div class=\"jse-contents jse-preview\">\n        {truncate(text || '', MAX_CHARACTERS_TEXT_PREVIEW)}\n      </div>\n    {/if}\n\n    {#if !editorDisabled}\n      {#if statusBar}\n        <StatusBar {editorState} />\n      {/if}\n\n      {#if jsonParseError}\n        <Message\n          type=\"error\"\n          icon={faExclamationTriangle}\n          message={jsonParseError.message}\n          actions={repairActions}\n          onClick={handleShowMe}\n          onClose={focus}\n        />\n      {/if}\n\n      {#if !jsonParseError && askToFormatApplied && needsFormatting(text)}\n        <Message\n          type=\"success\"\n          message=\"Do you want to format the JSON?\"\n          actions={[\n            {\n              icon: faJSONEditorFormat,\n              text: 'Format',\n              title: 'Format JSON: add proper indentation and new lines (Ctrl+I)',\n              onClick: handleFormat\n            },\n            {\n              icon: faTimes,\n              text: 'No thanks',\n              title: 'Close this message',\n              onClick: () => (askToFormatApplied = false)\n            }\n          ]}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview {validationErrors} selectError={handleSelectValidationError} />\n    {/if}\n  {:else}\n    <div class=\"jse-contents\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n<style src=\"./TextMode.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import {\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { faJSONEditorCompact, faJSONEditorFormat } from '$lib/img/customFontawesomeIcons.js'\n  import Menu from '../../../controls/Menu.svelte'\n  import type { MenuItem, OnRenderMenuInternal } from '$lib/types'\n\n  export let readOnly = false\n  export let onFormat: () => boolean\n  export let onCompact: () => boolean\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onToggleSearch: () => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let canUndo: boolean\n  export let canRedo: boolean\n  export let canFormat: boolean\n  export let canCompact: boolean\n  export let canSort: boolean\n  export let canTransform: boolean\n  export let onRenderMenu: OnRenderMenuInternal\n\n  const searchItem: MenuItem = {\n    type: 'button',\n    icon: faSearch,\n    title: 'Search (Ctrl+F)',\n    className: 'jse-search',\n    onClick: onToggleSearch\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        {\n          type: 'button',\n          icon: faJSONEditorFormat,\n          title: 'Format JSON: add proper indentation and new lines (Ctrl+I)',\n          className: 'jse-format',\n          onClick: onFormat,\n          disabled: readOnly || !canFormat\n        },\n        {\n          type: 'button',\n          icon: faJSONEditorCompact,\n          title: 'Compact JSON: remove all white spacing and new lines (Ctrl+Shift+I)',\n          className: 'jse-compact',\n          onClick: onCompact,\n          disabled: readOnly || !canCompact\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || !canSort\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || !canTransform\n        },\n        searchItem,\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        searchItem,\n        {\n          type: 'space'\n        }\n      ]\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<script lang=\"ts\">\n  import type { EditorState, Line } from '@codemirror/state'\n\n  export let editorState: EditorState | undefined\n\n  let pos: number | undefined\n  $: pos = editorState?.selection?.main?.head\n\n  let line: Line | undefined\n  $: line = pos !== undefined ? editorState?.doc?.lineAt(pos) : undefined\n\n  let lineNumber: number | undefined\n  $: lineNumber = line !== undefined ? line.number : undefined\n\n  let columnNumber: number | undefined\n  $: columnNumber = line !== undefined && pos !== undefined ? pos - line.from + 1 : undefined\n\n  let charCount: number | undefined\n  $: charCount = editorState?.selection?.ranges?.reduce((count, range) => {\n    return count + range.to - range.from\n  }, 0)\n</script>\n\n<div class=\"jse-status-bar\">\n  {#if lineNumber !== undefined}\n    <div class=\"jse-status-bar-info\">Line: {lineNumber}</div>\n  {/if}\n\n  {#if columnNumber !== undefined}\n    <div class=\"jse-status-bar-info\">Column: {columnNumber}</div>\n  {/if}\n\n  {#if charCount !== undefined && charCount > 0}\n    <div class=\"jse-status-bar-info\">Selection: {charCount} characters</div>\n  {/if}\n</div>\n\n<style src=\"./StatusBar.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import { getIn, isJSONArray, isJSONObject } from 'immutable-json-patch'\n  import type { JSONParser, OnChangeMode } from '$lib/types.js'\n  import { Mode } from '$lib/types.js'\n  import { valueType } from '$lib/utils/typeUtils.js'\n  import { findNestedArrays } from '$lib/logic/table.js'\n  import { isEmpty } from 'lodash-es'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n\n  export let text: string | undefined\n  export let json: unknown | undefined\n  export let readOnly: boolean\n  export let parser: JSONParser\n  export let openJSONEditorModal: (path: JSONPath) => void\n  export let onChangeMode: OnChangeMode\n  export let onClick: () => void\n\n  $: action = readOnly ? 'View' : 'Edit'\n\n  let nestedArrayPaths: JSONPath[]\n  $: nestedArrayPaths = json\n    ? findNestedArrays(json)\n        .slice(0, 99)\n        .filter((path) => path.length > 0)\n    : []\n  $: hasNestedArrays = !isEmpty(nestedArrayPaths)\n  $: isEmptyDocument = json === undefined && (text === '' || text === undefined)\n\n  $: documentType = hasNestedArrays\n    ? 'Object with nested arrays'\n    : isEmptyDocument\n      ? 'An empty document'\n      : isJSONObject(json)\n        ? 'An object'\n        : isJSONArray(json)\n          ? 'An empty array' // note: can also be an array with objects but without properties\n          : `A ${valueType(json, parser)}`\n\n  function countItems(nestedArrayPath: JSONPath): number {\n    return (getIn(json, nestedArrayPath) as JSONPath).length\n  }\n</script>\n\n<div class=\"jse-table-mode-welcome\" on:click={() => onClick()} role=\"none\">\n  <div class=\"jse-space jse-before\"></div>\n\n  <div class=\"jse-nested-arrays\">\n    <div class=\"jse-nested-arrays-title\">{documentType}</div>\n    <div class=\"jse-nested-arrays-info\">\n      {#if hasNestedArrays}\n        An object cannot be opened in table mode. You can open a nested array instead, or open the\n        document in tree mode.\n      {:else}\n        {documentType} cannot be opened in table mode.\n      {/if}\n      {#if isEmptyDocument && !readOnly}\n        You can open the document in tree mode instead, or paste a JSON Array using <b>Ctrl+V</b>.\n      {:else}\n        You can open the document in tree mode instead.\n      {/if}\n    </div>\n    {#each nestedArrayPaths as nestedArrayPath}\n      {@const count = countItems(nestedArrayPath)}\n\n      <button\n        type=\"button\"\n        class=\"jse-nested-array-action\"\n        on:click={() => openJSONEditorModal(nestedArrayPath)}\n      >\n        {action} \"{stringifyJSONPath(nestedArrayPath)}\"\n        <span class=\"jse-nested-array-count\">({count} {count !== 1 ? 'items' : 'item'})</span>\n      </button>\n    {/each}\n    <button type=\"button\" class=\"jse-nested-array-action\" on:click={() => onChangeMode(Mode.tree)}>\n      {action} in tree mode\n    </button>\n  </div>\n\n  <div class=\"jse-space jse-after\"></div>\n</div>\n\n<style src=\"./TableModeWelcome.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type {\n    AbsolutePopupContext,\n    AbsolutePopupOptions,\n    AfterPatchCallback,\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    DocumentState,\n    History,\n    HistoryItem,\n    JSONEditorContext,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONRepairModalProps,\n    JSONSelection,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRedo,\n    OnRenderContextMenuInternal,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    OnUndo,\n    ParseError,\n    PastedJson,\n    SearchResultDetails,\n    SearchResults,\n    SortedColumn,\n    TransformModalOptions,\n    ValidationError,\n    Validator,\n    ValueNormalization\n  } from '$lib/types'\n  import { Mode, SortDirection, ValidationSeverity } from '$lib/types.js'\n  import TableMenu from './menu/TableMenu.svelte'\n  import {\n    compileJSONPointer,\n    existsIn,\n    getIn,\n    immutableJSONPatch,\n    isJSONArray,\n    type JSONPatchDocument,\n    type JSONPath\n  } from 'immutable-json-patch'\n  import {\n    isTextContent,\n    normalizeJsonParseError,\n    parseAndRepair,\n    parsePartialJson,\n    repairPartialJson\n  } from '../../../utils/jsonUtils.js'\n  import {\n    calculateAbsolutePosition,\n    calculateVisibleSection,\n    clearSortedColumnWhenAffectedByOperations,\n    getColumns,\n    groupValidationErrors,\n    maintainColumnOrder,\n    mergeValidationErrors,\n    selectNextColumn,\n    selectNextRow,\n    selectPreviousColumn,\n    selectPreviousRow,\n    toTableCellPosition\n  } from '$lib/logic/table.js'\n  import { isEmpty, isEqual, uniqueId } from 'lodash-es'\n  import {\n    activeElementIsChildOf,\n    createNormalizationFunctions,\n    encodeDataPath,\n    findParentWithNodeName,\n    getDataPathFromTarget,\n    getWindow,\n    isChildOf\n  } from '$lib/utils/domUtils.js'\n  import { createDebug } from '$lib/utils/debug.js'\n  import {\n    createDocumentState,\n    documentStatePatch,\n    getEnforceString,\n    getInRecursiveState,\n    setInDocumentState,\n    syncDocumentState\n  } from '$lib/logic/documentState.js'\n  import { isObjectOrArray, isUrl, stringConvert } from '$lib/utils/typeUtils.js'\n  import InlineValue from './tag/InlineValue.svelte'\n  import {\n    createNestedValueOperations,\n    revertJSONPatchWithMoveOperations\n  } from '$lib/logic/operations.js'\n  import {\n    createValueSelection,\n    getAnchorPath,\n    getFocusPath,\n    isEditingSelection,\n    isJSONSelection,\n    isValueSelection,\n    pathInSelection,\n    pathStartsWith,\n    removeEditModeFromSelection\n  } from '$lib/logic/selection.js'\n  import ColumnHeader from './ColumnHeader.svelte'\n  import { sortJson } from '$lib/logic/sort.js'\n  import { keyComboFromEvent } from '$lib/utils/keyBindings.js'\n  import { createFocusTracker } from '$lib/components/controls/createFocusTracker.js'\n  import { getContext, onDestroy, onMount, tick } from 'svelte'\n  import { jsonrepair } from 'jsonrepair'\n  import Message from '../../controls/Message.svelte'\n  import { faCheck, faCode, faWrench } from '@fortawesome/free-solid-svg-icons'\n  import { measure } from '$lib/utils/timeUtils.js'\n  import memoizeOne from 'memoize-one'\n  import { validateJSON } from '$lib/logic/validation.js'\n  import ValidationErrorsOverview from '../../controls/ValidationErrorsOverview.svelte'\n  import {\n    CONTEXT_MENU_HEIGHT,\n    CONTEXT_MENU_WIDTH,\n    SCROLL_DURATION,\n    SEARCH_BOX_HEIGHT\n  } from '$lib/constants.js'\n  import { noop } from '$lib/utils/noop.js'\n  import { createJump } from '$lib/assets/jump.js/src/jump.js'\n  import ValidationErrorIcon from '../treemode/ValidationErrorIcon.svelte'\n  import {\n    onCopy,\n    onCut,\n    onDuplicateRow,\n    onInsertAfterRow,\n    onInsertBeforeRow,\n    onInsertCharacter,\n    onPaste,\n    onRemove,\n    onRemoveRow\n  } from '$lib/logic/actions.js'\n  import JSONRepairModal from '../../modals/JSONRepairModal.svelte'\n  import { resizeObserver } from '$lib/actions/resizeObserver.js'\n  import CopyPasteModal from '../../../components/modals/CopyPasteModal.svelte'\n  import ContextMenuPointer from '../../../components/controls/contextmenu/ContextMenuPointer.svelte'\n  import SearchBox from '../../controls/SearchBox.svelte'\n  import TableModeWelcome from './TableModeWelcome.svelte'\n  import JSONPreview from '../../controls/JSONPreview.svelte'\n  import RefreshColumnHeader from './RefreshColumnHeader.svelte'\n  import createTableContextMenuItems from './contextmenu/createTableContextMenuItems'\n  import ContextMenu from '../../controls/contextmenu/ContextMenu.svelte'\n  import { flattenSearchResults, toRecursiveSearchResults } from '$lib/logic/search.js'\n  import JSONValue from '../treemode/JSONValue.svelte'\n  import { isTreeHistoryItem } from 'svelte-jsoneditor'\n\n  const debug = createDebug('jsoneditor:TableMode')\n  const { openAbsolutePopup, closeAbsolutePopup } =\n    getContext<AbsolutePopupContext>('absolute-popup')\n  const jump = createJump()\n  const sortModalId = uniqueId()\n  const transformModalId = uniqueId()\n\n  const isSSR = typeof window === 'undefined'\n  debug('isSSR:', isSSR)\n\n  export let readOnly: boolean\n  export let externalContent: Content\n  export let externalSelection: JSONEditorSelection | undefined\n  export let history: History<HistoryItem>\n  export let mainMenuBar: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let indentation: number | string\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onUndo: OnUndo\n  export let onRedo: OnRedo\n  export let onRenderValue: OnRenderValue\n  export let onRenderMenu: OnRenderMenuInternal\n  export let onRenderContextMenu: OnRenderContextMenuInternal\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  let normalization: ValueNormalization\n  $: normalization = createNormalizationFunctions({\n    escapeControlCharacters,\n    escapeUnicodeCharacters\n  })\n\n  let refJsonEditor: HTMLDivElement\n  let refContents: HTMLDivElement | undefined\n  let refHiddenInput: HTMLInputElement\n\n  let jsonRepairModalProps: JSONRepairModalProps | undefined = undefined\n\n  createFocusTracker({\n    onMount,\n    onDestroy,\n    getWindow: () => getWindow(refJsonEditor),\n    hasFocus: () => (modalOpen && document.hasFocus()) || activeElementIsChildOf(refJsonEditor),\n    onFocus: () => {\n      hasFocus = true\n      if (onFocus) {\n        onFocus()\n      }\n    },\n    onBlur: () => {\n      hasFocus = false\n      if (onBlur) {\n        onBlur()\n      }\n    }\n  })\n\n  let json: unknown | undefined\n  let text: string | undefined\n  let parseError: ParseError | undefined = undefined\n\n  let pastedJson: PastedJson | undefined\n\n  let searchResultDetails: SearchResultDetails | undefined\n  let searchResults: SearchResults | undefined\n  let showSearch = false\n  let showReplace = false\n\n  $: applySearchBoxSpacing(showSearch)\n\n  function applySearchBoxSpacing(showSearch: boolean) {\n    if (!refContents) {\n      return\n    }\n\n    const offset = showSearch ? SEARCH_BOX_HEIGHT : -SEARCH_BOX_HEIGHT\n    refContents.scrollTo({\n      top: (refContents.scrollTop += offset),\n      left: refContents.scrollLeft\n    })\n  }\n\n  function handleSearch(result: SearchResultDetails | undefined) {\n    searchResultDetails = result\n    searchResults = searchResultDetails\n      ? toRecursiveSearchResults(json, searchResultDetails.items)\n      : undefined\n  }\n\n  async function handleFocusSearch(path: JSONPath) {\n    selection = undefined // navigation path of current selection would be confusing\n    await scrollTo(path)\n  }\n\n  function handleCloseSearch() {\n    showSearch = false\n    showReplace = false\n    focus()\n  }\n\n  $: applyExternalContent(externalContent)\n  $: applyExternalSelection(externalSelection)\n\n  let maxSampleCount = 10_000\n  let columns: JSONPath[] = []\n  $: columns = isJSONArray(json)\n    ? maintainColumnOrder(getColumns(json, flattenColumns, maxSampleCount), columns)\n    : []\n\n  let containsValidArray: boolean\n  $: containsValidArray = !!(json && !isEmpty(columns))\n  $: showRefreshButton = Array.isArray(json) && json.length > maxSampleCount\n\n  // modalOpen is true when one of the modals is open.\n  // This is used to track whether the editor still has focus\n  let modalOpen = false\n\n  let hasFocus = false\n  let copyPasteModalOpen = false\n\n  let itemHeightsCache: Record<number, number> = {}\n\n  let viewPortHeight = 600\n  let scrollTop = 0\n  let defaultItemHeight = 18 // px\n\n  $: visibleSection = calculateVisibleSection(\n    scrollTop,\n    viewPortHeight,\n    json,\n    itemHeightsCache, // warning: itemHeightsCache is mutated and is not responsive itself\n    defaultItemHeight,\n    showSearch ? SEARCH_BOX_HEIGHT : 0\n  )\n\n  $: refreshScrollTop(json)\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function refreshScrollTop(_json: unknown | undefined) {\n    // When the contents go from lots of items and scrollable contents to only a few items and\n    // no vertical scroll, the actual scrollTop changes to 0 but there is no on:scroll event\n    // triggered, so the internal scrollTop variable is not up-to-date.\n    // This is a workaround to update the scrollTop by triggering an on:scroll event\n    if (refContents) {\n      refContents.scrollTo({\n        top: refContents.scrollTop,\n        left: refContents.scrollLeft\n      })\n    }\n  }\n\n  function handleSelect(updatedSelection: JSONSelection | undefined) {\n    selection = updatedSelection\n  }\n\n  function emitOnSelect(updatedSelection: JSONSelection | undefined) {\n    if (!isEqual(updatedSelection, externalSelection)) {\n      debug('onSelect', updatedSelection)\n      onSelect(updatedSelection)\n    }\n  }\n\n  $: emitOnSelect(selection)\n\n  function clearSelectionWhenNotExisting(json: unknown | undefined) {\n    if (!selection || json === undefined) {\n      return\n    }\n\n    if (existsIn(json, getAnchorPath(selection)) && existsIn(json, getFocusPath(selection))) {\n      return\n    }\n\n    debug('clearing selection: path does not exist anymore', selection)\n    selection = undefined // TODO: try find the closest cell that still exists (similar to getInitialSelection)\n  }\n\n  let documentState: DocumentState | undefined =\n    json !== undefined ? createDocumentState({ json }) : undefined\n  let selection: JSONSelection | undefined = isJSONSelection(externalSelection)\n    ? externalSelection\n    : undefined\n  let sortedColumn: SortedColumn | undefined\n  let textIsRepaired = false\n\n  onMount(() => {\n    if (selection) {\n      scrollIntoView(getFocusPath(selection))\n    }\n  })\n\n  function onSortByHeader(newSortedColumn: SortedColumn) {\n    if (readOnly) {\n      return\n    }\n\n    debug('onSortByHeader', newSortedColumn)\n\n    const rootPath: JSONPath = []\n    const direction = newSortedColumn.sortDirection === SortDirection.desc ? -1 : 1\n    const operations = sortJson(json, rootPath, newSortedColumn.path, direction)\n    handlePatch(operations, (_, patchedState) => {\n      return {\n        state: patchedState,\n        sortedColumn: newSortedColumn\n      }\n    })\n  }\n\n  let context: JSONEditorContext\n  $: context = {\n    mode: Mode.table,\n    readOnly,\n    parser,\n    normalization,\n    getJson: () => json,\n    getDocumentState: () => documentState,\n    findElement,\n    findNextInside,\n    focus,\n    onPatch: (operations, afterPatch) => {\n      // When having flattened table columns and having inserted a new row, it is possible that\n      // we edit a nested value of which the parent object is not existing. Therefore, we call\n      // replaceNestedValue to create the parent object(s) first.\n      return handlePatch(createNestedValueOperations(operations, json), afterPatch)\n    },\n    onSelect: handleSelect,\n    onFind: openFind,\n    onPasteJson: handlePasteJson,\n    onRenderValue\n  }\n\n  function applyExternalContent(content: Content) {\n    const currentContent = { json }\n    const isChanged = isTextContent(content)\n      ? content.text !== text\n      : !isEqual(currentContent.json, content.json)\n\n    debug('update external content', { isChanged })\n\n    if (!isChanged) {\n      // no actual change, don't do anything\n      return\n    }\n\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    if (isTextContent(content)) {\n      try {\n        json = parseMemoizeOne(content.text)\n        documentState = syncDocumentState(json, documentState)\n        text = content.text\n        textIsRepaired = false\n        parseError = undefined\n      } catch (err) {\n        try {\n          json = parseMemoizeOne(jsonrepair(content.text))\n          documentState = syncDocumentState(json, documentState)\n          text = content.text\n          textIsRepaired = true\n          parseError = undefined\n        } catch {\n          // no valid JSON, will show empty document or invalid json\n          json = undefined\n          documentState = undefined\n          text = content.text\n          textIsRepaired = false\n          parseError =\n            text !== ''\n              ? normalizeJsonParseError(text, (err as Error).message || String(err))\n              : undefined\n        }\n      }\n    } else {\n      json = content.json\n      documentState = syncDocumentState(json, documentState)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    }\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    // reset the sorting order (we don't know...)\n    sortedColumn = undefined\n\n    addHistoryItem(previousState)\n  }\n\n  function applyExternalSelection(externalSelection: JSONEditorSelection | undefined) {\n    if (isEqual(selection, externalSelection)) {\n      return\n    }\n\n    debug('applyExternalSelection', { selection, externalSelection })\n\n    if (isJSONSelection(externalSelection)) {\n      selection = externalSelection\n    }\n  }\n\n  interface PreviousState {\n    json: unknown | undefined\n    text: string | undefined\n    documentState: DocumentState | undefined\n    selection: JSONSelection | undefined\n    textIsRepaired: boolean\n    sortedColumn: SortedColumn | undefined\n  }\n\n  function addHistoryItem(previous: PreviousState) {\n    if (previous.json === undefined && previous.text === undefined) {\n      // initialization -> do not create a history item\n      return\n    }\n\n    const canPatch = json !== undefined && previous.json !== undefined\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: previous.json }] : undefined,\n        json: previous.json,\n        text: previous.text,\n        documentState: previous.documentState,\n        textIsRepaired: previous.textIsRepaired,\n        selection: removeEditModeFromSelection(previous.selection),\n        sortedColumn: previous.sortedColumn\n      },\n      redo: {\n        patch: canPatch ? [{ op: 'replace', path: '', value: json }] : undefined,\n        json,\n        text,\n        documentState,\n        textIsRepaired,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn\n      }\n    })\n  }\n\n  let validationErrors: ValidationError[] = []\n  $: updateValidationErrors(json, validator, parser, validationParser)\n  $: groupedValidationErrors = groupValidationErrors(validationErrors, columns)\n\n  // because onChange returns the validation errors and there is also a separate listener,\n  // we would execute validation twice. Memoizing the last result solves this.\n  const memoizedValidate = memoizeOne(validateJSON)\n\n  function updateValidationErrors(\n    json: unknown,\n    validator: Validator | undefined,\n    parser: JSONParser,\n    validationParser: JSONParser\n  ) {\n    measure(\n      () => {\n        let newValidationErrors: ValidationError[]\n        try {\n          newValidationErrors = memoizedValidate(json, validator, parser, validationParser)\n        } catch (err) {\n          newValidationErrors = [\n            {\n              path: [],\n              message: 'Failed to validate: ' + (err as Error).message,\n              severity: ValidationSeverity.warning\n            }\n          ]\n        }\n\n        if (!isEqual(newValidationErrors, validationErrors)) {\n          debug('validationErrors changed:', newValidationErrors)\n          validationErrors = newValidationErrors\n        }\n      },\n      (duration) => debug(`validationErrors updated in ${duration} ms`)\n    )\n  }\n\n  export function validate(): ContentErrors | undefined {\n    debug('validate')\n\n    if (parseError) {\n      return {\n        parseError,\n        isRepairable: false // not applicable, if repairable, we will not have a parseError\n      }\n    }\n\n    // make sure the validation results are up-to-date\n    // normally, they are only updated on the next tick after the json is changed\n    updateValidationErrors(json, validator, parser, validationParser)\n    return !isEmpty(validationErrors) ? { validationErrors } : undefined\n  }\n\n  export function patch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('patch', operations, afterPatch)\n\n    if (json === undefined) {\n      throw new Error('Cannot apply patch: no JSON')\n    }\n\n    const previousJson = json\n    const previousState: PreviousState = {\n      json: undefined, // not needed: we use patch to reconstruct the json\n      text,\n      documentState,\n      selection: removeEditModeFromSelection(selection),\n      sortedColumn,\n      textIsRepaired\n    }\n\n    // execute the patch operations\n    const undo: JSONPatchDocument = revertJSONPatchWithMoveOperations(\n      json,\n      operations\n    ) as JSONPatchDocument\n    const patched = documentStatePatch(json, documentState, operations)\n\n    // Clear the sorted column when needed. We need to do this before `afterPatch`,\n    // else we clear any changed made in the callback. It is a bit odd that\n    // afterPatch does not receive the actual previousDocumentState. Better ideas?\n    const patchedSortedColumn = clearSortedColumnWhenAffectedByOperations(\n      sortedColumn,\n      operations,\n      columns\n    )\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(patched.json, patched.documentState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : patched.json\n    documentState = callback?.state !== undefined ? callback.state : patched.documentState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    sortedColumn =\n      callback?.sortedColumn !== undefined ? callback.sortedColumn : patchedSortedColumn\n    text = undefined\n    textIsRepaired = false\n    pastedJson = undefined\n    parseError = undefined\n\n    history.add({\n      type: 'tree',\n      undo: {\n        patch: undo,\n        ...previousState\n      },\n      redo: {\n        patch: operations,\n        json: undefined, // not needed: we use patch to reconstruct the json\n        text: undefined,\n        documentState,\n        selection: removeEditModeFromSelection(selection),\n        sortedColumn,\n        textIsRepaired\n      }\n    })\n\n    return {\n      json,\n      previousJson,\n      undo,\n      redo: operations\n    }\n  }\n\n  function handlePatch(\n    operations: JSONPatchDocument,\n    afterPatch?: AfterPatchCallback\n  ): JSONPatchResult {\n    debug('handlePatch', operations, afterPatch)\n\n    const previousContent = { json, text }\n    const patchResult = patch(operations, afterPatch)\n\n    emitOnChange(previousContent, patchResult)\n\n    return patchResult\n  }\n\n  function emitOnChange(previousContent: Content, patchResult: JSONPatchResult | undefined) {\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore\n    if (previousContent.json === undefined && previousContent?.text === undefined) {\n      // initialization -> do not fire an onChange event\n      return\n    }\n\n    // make sure we cannot send an invalid contents like having both\n    // json and text defined, or having none defined\n    if (onChange) {\n      if (text !== undefined) {\n        const content = { text, json: undefined }\n        onChange(content, previousContent, {\n          contentErrors: validate(),\n          patchResult\n        })\n      } else if (json !== undefined) {\n        const content = { text: undefined, json }\n        onChange(content, previousContent, {\n          contentErrors: validate(),\n          patchResult\n        })\n      }\n    }\n  }\n\n  function handlePasteJson(newPastedJson: PastedJson) {\n    debug('pasted json as text', newPastedJson)\n\n    pastedJson = newPastedJson\n  }\n\n  function findNextInside(path: JSONPath): JSONSelection {\n    const index = parseInt(path[0], 10)\n    const nextPath = [String(index + 1), ...path.slice(1)]\n\n    return existsIn(json, nextPath) ? createValueSelection(nextPath) : createValueSelection(path)\n  }\n\n  export function focus() {\n    debug('focus')\n    // with just .focus(), sometimes the input doesn't react on onpaste events\n    // in Chrome when having a large document open and then doing cut/paste.\n    // Calling both .focus() and .select() did solve this issue.\n    if (refHiddenInput) {\n      refHiddenInput.focus()\n      refHiddenInput.select()\n    }\n  }\n\n  function handleWindowMouseDown(event: MouseEvent & { currentTarget: EventTarget & Window }) {\n    const outsideEditor = !isChildOf(\n      event.target as Element,\n      (element) => element === refJsonEditor\n    )\n    if (outsideEditor) {\n      if (isEditingSelection(selection)) {\n        debug('click outside the editor, exit edit mode')\n        selection = removeEditModeFromSelection(selection)\n\n        if (hasFocus && refHiddenInput) {\n          refHiddenInput.focus()\n          refHiddenInput.blur()\n        }\n\n        debug('blur (outside editor)')\n        if (refHiddenInput) {\n          refHiddenInput.blur()\n        }\n      }\n    }\n  }\n\n  function handleScroll(event: Event) {\n    scrollTop = (event.target as HTMLElement)['scrollTop']\n  }\n\n  function handleMouseDown(event: MouseEvent) {\n    // only handle when the left or right mouse button is pressed, not the middle mouse button (scroll wheel)\n    if (event.buttons !== 1 && event.buttons !== 2) {\n      return\n    }\n\n    const target = event.target as HTMLElement\n    if (!target.isContentEditable) {\n      focus()\n    }\n\n    const path = getDataPathFromTarget(target)\n    if (path) {\n      // when clicking inside the current selection, editing a value, do nothing\n      if (isEditingSelection(selection) && pathInSelection(json, selection, path)) {\n        return\n      }\n\n      selection = createValueSelection(path)\n\n      event.preventDefault()\n    }\n  }\n\n  function createDefaultSelection(): JSONSelection | undefined {\n    if (isJSONArray(json) && !isEmpty(json) && !isEmpty(columns)) {\n      // Select the first row, first column\n      const path = ['0', ...columns[0]]\n\n      return createValueSelection(path)\n    } else {\n      return undefined\n    }\n  }\n\n  function createDefaultSelectionWhenUndefined() {\n    if (!selection) {\n      selection = createDefaultSelection()\n    }\n  }\n\n  export function acceptAutoRepair() {\n    if (textIsRepaired && json !== undefined) {\n      const previousContent = { json, text }\n      const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n      // json stays as is\n      text = undefined\n      textIsRepaired = false\n\n      clearSelectionWhenNotExisting(json)\n\n      addHistoryItem(previousState)\n\n      // we could work out a patchResult, or use patch(), but only when the previous and new\n      // contents are both json and not text. We go for simplicity and consistency here and\n      // do _not_ return a patchResult ever.\n      const patchResult = undefined\n\n      emitOnChange(previousContent, patchResult)\n    }\n\n    return { json, text }\n  }\n\n  /**\n   * Scroll the window vertically to the node with given path.\n   * Expand the path when needed.\n   */\n  export function scrollTo(path: JSONPath, scrollToWhenVisible = true): Promise<void> {\n    const searchBoxHeight = showSearch ? SEARCH_BOX_HEIGHT : 0\n    const top = calculateAbsolutePosition(path, columns, itemHeightsCache, defaultItemHeight)\n    const roughDistance = top - scrollTop + searchBoxHeight + defaultItemHeight\n    const elem = findElement(path)\n\n    debug('scrollTo', { path, top, scrollTop, elem })\n\n    if (!refContents) {\n      return Promise.resolve()\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    if (elem && !scrollToWhenVisible) {\n      const elemRect = elem.getBoundingClientRect()\n      if (elemRect.bottom > viewPortRect.top && elemRect.top < viewPortRect.bottom) {\n        // element is fully or partially visible, don't scroll to it\n        return Promise.resolve()\n      }\n    }\n\n    const offset = -Math.max(searchBoxHeight + 2 * defaultItemHeight, viewPortRect.height / 4)\n\n    if (elem) {\n      return new Promise((resolve) => {\n        jump(elem, {\n          container: refContents,\n          offset,\n          duration: SCROLL_DURATION,\n          callback: () => {\n            // TODO: improve horizontal scrolling: animate and integrate with the vertical scrolling (jump)\n            scrollToHorizontal(path)\n            resolve()\n          }\n        })\n      })\n    } else {\n      return new Promise((resolve) => {\n        jump(roughDistance, {\n          container: refContents,\n          offset,\n          duration: SCROLL_DURATION,\n          callback: async () => {\n            // ensure the element is rendered now that it is scrolled into view\n            await tick()\n\n            // TODO: improve horizontal scrolling: animate and integrate with the vertical scrolling (jump)\n            scrollToHorizontal(path)\n            resolve()\n          }\n        })\n      })\n    }\n  }\n\n  function scrollToVertical(path: JSONPath) {\n    if (!refContents) {\n      return\n    }\n\n    const { rowIndex } = toTableCellPosition(path, columns)\n    const top = calculateAbsolutePosition(path, columns, itemHeightsCache, defaultItemHeight)\n    const bottom = top + (itemHeightsCache[rowIndex] || defaultItemHeight)\n\n    const headerHeight = defaultItemHeight\n    const viewPortRect = refContents.getBoundingClientRect()\n    const viewPortTop = scrollTop\n    const viewPortBottom = scrollTop + viewPortRect.height - headerHeight\n\n    if (bottom > viewPortBottom) {\n      const diff = bottom - viewPortBottom\n      refContents.scrollTop += diff\n    }\n\n    if (top < viewPortTop) {\n      const diff = viewPortTop - top\n      refContents.scrollTop -= diff\n    }\n  }\n\n  function scrollToHorizontal(path: JSONPath) {\n    const elem = findElement(path)\n    if (!elem || !refContents) {\n      return\n    }\n\n    const viewPortRect = refContents.getBoundingClientRect()\n    const elemRect = elem.getBoundingClientRect() // TODO: scroll to column instead of item (is always rendered)\n\n    if (elemRect.right > viewPortRect.right) {\n      const diff = elemRect.right - viewPortRect.right\n      refContents.scrollLeft += diff\n    }\n\n    if (elemRect.left < viewPortRect.left) {\n      const diff = viewPortRect.left - elemRect.left\n      refContents.scrollLeft -= diff\n    }\n  }\n\n  function scrollIntoView(path: JSONPath) {\n    scrollToVertical(path)\n    scrollToHorizontal(path)\n  }\n\n  /**\n   * Find the DOM element of a given path.\n   * Note that the path can only be found when the node is expanded.\n   */\n  export function findElement(path: JSONPath): Element | undefined {\n    const column = columns.find((c) => pathStartsWith(path.slice(1), c))\n\n    const resolvedPath = column ? path.slice(0, 1).concat(column) : path\n\n    return (\n      refContents?.querySelector(`td[data-path=\"${encodeDataPath(resolvedPath)}\"]`) ?? undefined\n    )\n  }\n\n  function openContextMenu({\n    anchor,\n    left,\n    top,\n    width,\n    height,\n    offsetTop,\n    offsetLeft,\n    showTip\n  }: AbsolutePopupOptions) {\n    const defaultItems: ContextMenuItem[] = createTableContextMenuItems({\n      json,\n      documentState,\n      selection,\n      readOnly,\n\n      onEditValue: handleEditValue,\n      onEditRow: handleEditRow,\n      onToggleEnforceString: handleToggleEnforceString,\n\n      onCut: handleCut,\n      onCopy: handleCopy,\n      onPaste: handlePasteFromMenu,\n\n      onRemove: handleRemove,\n      onDuplicateRow: handleDuplicateRow,\n      onInsertBeforeRow: handleInsertBeforeRow,\n      onInsertAfterRow: handleInsertAfterRow,\n      onRemoveRow: handleRemoveRow\n    })\n\n    const items = onRenderContextMenu(defaultItems) ?? defaultItems\n\n    if (items === false) {\n      return\n    }\n\n    const props = {\n      tip: showTip\n        ? 'Tip: you can open this context menu via right-click or with Ctrl+Q'\n        : undefined,\n      items,\n      onRequestClose: function () {\n        closeAbsolutePopup(popupId)\n        focus()\n      }\n    }\n\n    const options = {\n      left,\n      top,\n      offsetTop,\n      offsetLeft,\n      width,\n      height,\n      anchor,\n      closeOnOuterClick: true,\n      onClose: () => {\n        modalOpen = false\n        focus()\n      }\n    }\n\n    modalOpen = true\n\n    const popupId = openAbsolutePopup(ContextMenu, props, options)\n  }\n\n  function handleContextMenu(event: Event) {\n    if (isEditingSelection(selection)) {\n      return\n    }\n\n    if (event) {\n      event.stopPropagation()\n      event.preventDefault()\n    }\n\n    if (event && event.type === 'contextmenu' && event.target !== refHiddenInput) {\n      // right mouse click to open context menu\n      openContextMenu({\n        left: (event as MouseEvent).clientX,\n        top: (event as MouseEvent).clientY,\n        width: CONTEXT_MENU_WIDTH,\n        height: CONTEXT_MENU_HEIGHT,\n        showTip: false\n      })\n    } else {\n      // type === 'keydown' (from the quick key Ctrl+Q)\n      // or target is hidden input -> context menu button on keyboard\n      const anchor = refContents?.querySelector('.jse-table-cell.jse-selected-value')\n      if (anchor) {\n        openContextMenu({\n          anchor,\n          offsetTop: 2,\n          width: CONTEXT_MENU_WIDTH,\n          height: CONTEXT_MENU_HEIGHT,\n          showTip: false\n        })\n      } else {\n        // fallback on just displaying the TreeContextMenu top left\n        const rect = refContents?.getBoundingClientRect()\n        if (rect) {\n          openContextMenu({\n            top: rect.top + 2,\n            left: rect.left + 2,\n            width: CONTEXT_MENU_WIDTH,\n            height: CONTEXT_MENU_HEIGHT,\n            showTip: false\n          })\n        }\n      }\n    }\n  }\n\n  function handleContextMenuFromTableMenu(event: MouseEvent) {\n    openContextMenu({\n      anchor: findParentWithNodeName(event.target as HTMLElement, 'BUTTON'),\n      offsetTop: 0,\n      width: CONTEXT_MENU_WIDTH,\n      height: CONTEXT_MENU_HEIGHT,\n      showTip: true\n    })\n  }\n\n  function handleEditValue() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const value = getIn(json, path)\n    if (isObjectOrArray(value)) {\n      openJSONEditorModal(path)\n    } else {\n      selection = createValueSelection(path)\n    }\n  }\n\n  function handleEditRow() {\n    if (readOnly || !selection) {\n      return\n    }\n\n    const path = getFocusPath(selection)\n    const pathRow = path.slice(0, 1)\n    openJSONEditorModal(pathRow)\n  }\n\n  function handleToggleEnforceString() {\n    if (readOnly || !isValueSelection(selection)) {\n      return\n    }\n\n    const path = selection.path\n    const pointer = compileJSONPointer(path)\n    const value = getIn(json, path)\n    const enforceString = !getEnforceString(json, documentState, path)\n    const updatedValue = enforceString ? String(value) : stringConvert(String(value), parser)\n\n    debug('handleToggleEnforceString', { enforceString, value, updatedValue })\n\n    handlePatch(\n      [\n        {\n          op: 'replace',\n          path: pointer,\n          value: updatedValue\n        }\n      ],\n      (_, patchedState) => {\n        return {\n          state: setInDocumentState(json, patchedState, path, { type: 'value', enforceString })\n        }\n      }\n    )\n  }\n\n  async function handleParsePastedJson() {\n    debug('apply pasted json', pastedJson)\n    if (!pastedJson) {\n      return\n    }\n\n    const { onPasteAsJson } = pastedJson\n    onPasteAsJson()\n\n    // TODO: get rid of the setTimeout here\n    setTimeout(focus)\n  }\n\n  async function handlePasteFromMenu() {\n    try {\n      const clipboardText = await navigator.clipboard.readText()\n\n      _paste(clipboardText)\n    } catch (err) {\n      console.error(err)\n\n      copyPasteModalOpen = true\n    }\n  }\n\n  function handleClearPastedJson() {\n    debug('clear pasted json')\n    pastedJson = undefined\n    focus()\n  }\n\n  function handleRequestRepair() {\n    onChangeMode(Mode.text)\n  }\n\n  async function handleCut(indent: boolean) {\n    await onCut({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      readOnly,\n      parser,\n      onPatch: handlePatch\n    })\n  }\n\n  async function handleCopy(indent = true) {\n    if (json === undefined) {\n      return\n    }\n\n    await onCopy({\n      json,\n      selection,\n      indentation: indent ? indentation : undefined,\n      parser\n    })\n  }\n\n  function handleRemove() {\n    onRemove({\n      json,\n      text,\n      selection,\n      keepSelection: true,\n      readOnly,\n      onChange,\n      onPatch: handlePatch\n    })\n  }\n\n  function handleDuplicateRow() {\n    onDuplicateRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleInsertBeforeRow() {\n    onInsertBeforeRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleInsertAfterRow() {\n    onInsertAfterRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  function handleRemoveRow() {\n    onRemoveRow({ json, selection, columns, readOnly, onPatch: handlePatch })\n  }\n\n  async function handleInsertCharacter(char: string) {\n    await onInsertCharacter({\n      char,\n      selectInside: false,\n      json,\n      selection: selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onReplaceJson: handleReplaceJson,\n      onSelect: handleSelect\n    })\n  }\n\n  function handleKeyDown(event: KeyboardEvent) {\n    const combo = keyComboFromEvent(event)\n    debug('keydown', { combo, key: event.key })\n\n    if (combo === 'Ctrl+X') {\n      // cut formatted\n      event.preventDefault()\n      handleCut(true)\n    }\n    if (combo === 'Ctrl+Shift+X') {\n      // cut compact\n      event.preventDefault()\n      handleCut(false)\n    }\n    if (combo === 'Ctrl+C') {\n      // copy formatted\n      event.preventDefault()\n      handleCopy(true)\n    }\n    if (combo === 'Ctrl+Shift+C') {\n      // copy compact\n      event.preventDefault()\n      handleCopy(false)\n    }\n    // Note: Ctrl+V (paste) is handled by the on:paste event\n\n    if (combo === 'Ctrl+D') {\n      event.preventDefault()\n      handleDuplicateRow()\n    }\n    if (combo === 'Delete' || combo === 'Backspace') {\n      event.preventDefault()\n      handleRemove()\n    }\n    if (combo === 'Insert') {\n      event.preventDefault()\n      // TODO: implement insert\n    }\n    if (combo === 'Ctrl+A') {\n      event.preventDefault()\n      // selection = selectAll()\n      // TODO: implement select all\n    }\n\n    if (combo === 'Ctrl+Q') {\n      handleContextMenu(event)\n    }\n\n    if (combo === 'ArrowLeft') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectPreviousColumn(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowRight') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectNextColumn(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowUp') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectPreviousRow(columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'ArrowDown') {\n      event.preventDefault()\n\n      createDefaultSelectionWhenUndefined()\n\n      if (selection) {\n        const newSelection = selectNextRow(json, columns, selection)\n        selection = newSelection\n        scrollIntoView(getFocusPath(newSelection))\n      }\n    }\n\n    if (combo === 'Enter' && selection) {\n      if (isValueSelection(selection)) {\n        event.preventDefault()\n\n        const path = selection.path\n        const value = getIn(json, path)\n        if (isObjectOrArray(value)) {\n          // edit nested object/array\n          openJSONEditorModal(path)\n        } else {\n          if (!readOnly) {\n            // go to value edit mode\n            selection = { ...selection, edit: true }\n          }\n        }\n      }\n    }\n\n    const normalizedCombo = combo.replace(/^Shift\\+/, '') // replace 'Shift+A' with 'A'\n    if (normalizedCombo.length === 1 && selection) {\n      // a regular key like a, A, _, etc is entered.\n      // Replace selected contents with a new value having this first character as text\n      event.preventDefault()\n      handleInsertCharacter(event.key)\n      return\n    }\n\n    if (combo === 'Ctrl+Enter' && isValueSelection(selection)) {\n      event.preventDefault()\n\n      const value = getIn(json, selection.path)\n\n      if (isUrl(value)) {\n        // open url in new page\n        window.open(String(value), '_blank')\n      }\n    }\n\n    if (combo === 'Escape' && selection) {\n      event.preventDefault()\n      selection = undefined\n    }\n\n    if (combo === 'Ctrl+F') {\n      event.preventDefault()\n      openFind(false)\n    }\n\n    if (combo === 'Ctrl+H') {\n      event.preventDefault()\n      openFind(true)\n    }\n\n    if (combo === 'Ctrl+Z') {\n      event.preventDefault()\n\n      handleUndo()\n    }\n\n    if (combo === 'Ctrl+Shift+Z') {\n      event.preventDefault()\n\n      handleRedo()\n    }\n  }\n\n  function handlePaste(event: ClipboardEvent) {\n    event.preventDefault()\n\n    const clipboardText = event.clipboardData?.getData('text/plain')\n\n    _paste(clipboardText)\n  }\n\n  function _paste(clipboardText: string | undefined) {\n    if (clipboardText === undefined) {\n      return\n    }\n\n    onPaste({\n      clipboardText,\n      json,\n      selection,\n      readOnly,\n      parser,\n      onPatch: handlePatch,\n      onChangeText: handleChangeText,\n      openRepairModal\n    })\n  }\n\n  // TODO: this function is duplicated from TreeMode. See if we can reuse the code instead\n  function handleReplaceJson(updatedJson: unknown, afterPatch?: AfterPatchCallback) {\n    const previousContent = { json, text }\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    const updatedState = syncDocumentState(updatedJson, documentState)\n\n    const callback =\n      typeof afterPatch === 'function'\n        ? afterPatch(updatedJson, updatedState, selection)\n        : undefined\n\n    json = callback?.json !== undefined ? callback.json : updatedJson\n    documentState = callback?.state !== undefined ? callback.state : updatedState\n    selection = callback?.selection !== undefined ? callback.selection : selection\n    sortedColumn = undefined // we can't know whether the new json is still sorted or not\n    text = undefined\n    textIsRepaired = false\n    parseError = undefined\n\n    // make sure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // we could work out a patchResult, or use patch(), but only when the previous and new\n    // contents are both json and not text. We go for simplicity and consistency here and\n    // do _not_ return a patchResult ever.\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  // TODO: this function is duplicated from TreeMode. See if we can reuse the code instead\n  function handleChangeText(updatedText: string, afterPatch?: AfterPatchCallback) {\n    debug('handleChangeText')\n\n    const previousContent = { json, text }\n    const previousState = { json, documentState, selection, sortedColumn, text, textIsRepaired }\n\n    try {\n      json = parseMemoizeOne(updatedText)\n      documentState = syncDocumentState(json, documentState)\n      text = undefined\n      textIsRepaired = false\n      parseError = undefined\n    } catch (err) {\n      try {\n        json = parseMemoizeOne(jsonrepair(updatedText))\n        documentState = syncDocumentState(json, documentState)\n        text = updatedText\n        textIsRepaired = true\n        parseError = undefined\n      } catch {\n        // no valid JSON, will show empty document or invalid json\n        json = undefined\n        documentState = undefined\n        text = updatedText\n        textIsRepaired = false\n        parseError =\n          text !== ''\n            ? normalizeJsonParseError(text, (err as Error).message || String(err))\n            : undefined\n      }\n    }\n\n    if (typeof afterPatch === 'function') {\n      const callback = afterPatch(json, documentState, selection)\n\n      json = callback?.json !== undefined ? callback.json : json\n      documentState = callback?.state !== undefined ? callback.state : documentState\n      selection = callback?.selection !== undefined ? callback.selection : selection\n    }\n\n    // ensure the selection is valid\n    clearSelectionWhenNotExisting(json)\n\n    addHistoryItem(previousState)\n\n    // no JSON patch actions available in text mode\n    const patchResult = undefined\n\n    emitOnChange(previousContent, patchResult)\n  }\n\n  function handleSelectValidationError(error: ValidationError) {\n    debug('select validation error', error)\n\n    selection = createValueSelection(error.path)\n\n    scrollTo(error.path)\n  }\n\n  function openSortModal(rootPath: JSONPath) {\n    if (readOnly || json === undefined) {\n      return\n    }\n\n    modalOpen = true\n\n    onSortModal({\n      id: sortModalId,\n      json,\n      rootPath,\n      onSort: ({ operations, itemPath, direction }) => {\n        debug('onSort', operations, rootPath, itemPath, direction)\n\n        handlePatch(operations, (_, patchedState) => {\n          return {\n            state: patchedState,\n            sortedColumn: {\n              path: itemPath,\n              sortDirection: direction === -1 ? SortDirection.desc : SortDirection.asc\n            }\n          }\n        })\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  /**\n   * This method is exposed via JSONEditor.transform\n   */\n  export function openTransformModal(options: TransformModalOptions) {\n    if (json === undefined) {\n      return\n    }\n\n    const { id, onTransform, onClose } = options\n    const rootPath = options.rootPath || []\n\n    modalOpen = true\n\n    onTransformModal({\n      id: id || transformModalId,\n      json,\n      rootPath: rootPath || [],\n      onTransform: (operations) => {\n        if (onTransform) {\n          onTransform({\n            operations,\n            json: json,\n            transformedJson: immutableJSONPatch(json, operations)\n          })\n        } else {\n          debug('onTransform', rootPath, operations)\n\n          handlePatch(operations)\n        }\n      },\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n        if (onClose) {\n          onClose()\n        }\n      }\n    })\n  }\n\n  function openJSONEditorModal(path: JSONPath) {\n    debug('openJSONEditorModal', { path })\n\n    modalOpen = true\n\n    // open a popup where you can edit the nested object/array\n    onJSONEditorModal({\n      content: {\n        json: getIn(json, path)\n      },\n      path,\n      onPatch: handlePatch,\n      onClose: () => {\n        modalOpen = false\n        setTimeout(focus)\n      }\n    })\n  }\n\n  function openRepairModal(text: string, onApply: (repairedText: string) => void) {\n    jsonRepairModalProps = {\n      text,\n      onParse: (text) => parsePartialJson(text, (t) => parseAndRepair(t, parser)),\n      onRepair: repairPartialJson,\n      onApply,\n      onClose: focus\n    }\n  }\n\n  function handleSortAll() {\n    const rootPath: JSONPath = []\n    openSortModal(rootPath)\n  }\n\n  function handleTransformAll() {\n    openTransformModal({\n      rootPath: []\n    })\n  }\n\n  function openFind(findAndReplace: boolean): void {\n    debug('openFind', { findAndReplace })\n\n    showSearch = false\n    showReplace = false\n\n    tick().then(() => {\n      // trick to make sure the focus goes to the search box\n      showSearch = true\n      showReplace = findAndReplace\n    })\n  }\n\n  function handleUndo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canUndo) {\n      return\n    }\n\n    const item = history.undo()\n    if (!isTreeHistoryItem(item)) {\n      onUndo(item)\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.undo.patch ? immutableJSONPatch(json, item.undo.patch) : item.undo.json\n    documentState = item.undo.documentState\n    selection = item.undo.selection\n    sortedColumn = item.undo.sortedColumn\n    text = item.undo.text\n    textIsRepaired = item.undo.textIsRepaired\n    parseError = undefined\n\n    debug('undo', { item, json })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.undo.patch,\n            undo: item.redo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function handleRedo() {\n    if (readOnly) {\n      return\n    }\n\n    if (!history.canRedo) {\n      return\n    }\n\n    const item = history.redo()\n    if (!isTreeHistoryItem(item)) {\n      onRedo(item)\n      return\n    }\n\n    const previousContent = { json, text }\n\n    json = item.redo.patch ? immutableJSONPatch(json, item.redo.patch) : item.redo.json\n    documentState = item.redo.documentState\n    selection = item.redo.selection\n    sortedColumn = item.redo.sortedColumn\n    text = item.redo.text\n    textIsRepaired = item.redo.textIsRepaired\n    parseError = undefined\n\n    debug('redo', { item, json })\n\n    const patchResult =\n      item.undo.patch && item.redo.patch\n        ? {\n            json,\n            previousJson: previousContent.json,\n            redo: item.redo.patch,\n            undo: item.undo.patch\n          }\n        : undefined\n\n    emitOnChange(previousContent, patchResult)\n\n    focus()\n    if (selection) {\n      scrollTo(getFocusPath(selection), false)\n    }\n  }\n\n  function handleResizeContents(element: Element) {\n    viewPortHeight = element.getBoundingClientRect().height\n  }\n\n  function handleResizeRow(element: Element, rowIndex: number) {\n    itemHeightsCache[rowIndex] = element.getBoundingClientRect().height\n  }\n</script>\n\n<svelte:window on:mousedown={handleWindowMouseDown} />\n\n<!-- svelte-ignore a11y-no-noninteractive-element-interactions -->\n<div\n  role=\"table\"\n  class=\"jse-table-mode\"\n  class:no-main-menu={!mainMenuBar}\n  on:mousedown={handleMouseDown}\n  on:keydown={handleKeyDown}\n  on:contextmenu={handleContextMenu}\n  bind:this={refJsonEditor}\n>\n  {#if mainMenuBar}\n    <TableMenu\n      {containsValidArray}\n      {readOnly}\n      bind:showSearch\n      {history}\n      onSort={handleSortAll}\n      onTransform={handleTransformAll}\n      onUndo={handleUndo}\n      onRedo={handleRedo}\n      onContextMenu={handleContextMenuFromTableMenu}\n      {onRenderMenu}\n    />\n  {/if}\n\n  {#if !isSSR}\n    <label class=\"jse-hidden-input-label\">\n      <input\n        type=\"text\"\n        readonly={true}\n        tabindex=\"-1\"\n        class=\"jse-hidden-input\"\n        bind:this={refHiddenInput}\n        on:paste={handlePaste}\n      />\n    </label>\n    {#if containsValidArray}\n      <div class=\"jse-search-box-container\">\n        <SearchBox\n          {json}\n          {documentState}\n          {parser}\n          {showSearch}\n          {showReplace}\n          {readOnly}\n          {columns}\n          onSearch={handleSearch}\n          onFocus={handleFocusSearch}\n          onPatch={handlePatch}\n          onClose={handleCloseSearch}\n        />\n      </div>\n      <div\n        class=\"jse-contents\"\n        bind:this={refContents}\n        use:resizeObserver={handleResizeContents}\n        on:scroll={handleScroll}\n      >\n        <table class=\"jse-table-main\">\n          <tbody>\n            <tr class=\"jse-table-row jse-table-row-header\">\n              <th class=\"jse-table-cell jse-table-cell-header\">\n                {#if !isEmpty(groupedValidationErrors?.root)}\n                  {@const validationError = mergeValidationErrors(\n                    [],\n                    groupedValidationErrors?.root\n                  )}\n                  {#if validationError}\n                    <div class=\"jse-table-root-error\">\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    </div>\n                  {/if}\n                {/if}\n              </th>\n              {#each columns as column}\n                <th class=\"jse-table-cell jse-table-cell-header\">\n                  <ColumnHeader path={column} {sortedColumn} {readOnly} onSort={onSortByHeader} />\n                </th>\n              {/each}\n              {#if showRefreshButton}\n                <th class=\"jse-table-cell jse-table-cell-header\">\n                  <RefreshColumnHeader\n                    count={Array.isArray(json) ? json.length : 0}\n                    {maxSampleCount}\n                    {readOnly}\n                    onRefresh={() => (maxSampleCount = Infinity)}\n                  />\n                </th>\n              {/if}\n            </tr>\n            <tr\n              class=\"jse-table-invisible-start-section\"\n              class:jse-search-box-background={showSearch}\n            >\n              <td style:height={visibleSection.startHeight + 'px'} colspan={columns.length}></td>\n            </tr>\n            {#each visibleSection.visibleItems as item, visibleIndex}\n              {@const rowIndex = visibleSection.startIndex + visibleIndex}\n              {@const validationErrorsByRow = groupedValidationErrors.rows[rowIndex]}\n              {@const validationError = mergeValidationErrors(\n                [String(rowIndex)],\n                validationErrorsByRow?.row\n              )}\n              {@const searchResultByRow = getInRecursiveState(json, searchResults, [\n                String(rowIndex)\n              ])}\n              <tr class=\"jse-table-row\">\n                {#key rowIndex}\n                  <th\n                    class=\"jse-table-cell jse-table-cell-gutter\"\n                    use:resizeObserver={(element) => handleResizeRow(element, rowIndex)}\n                  >\n                    {rowIndex}\n                    {#if validationError}\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    {/if}\n                  </th>\n                {/key}\n                {#each columns as column, columnIndex}\n                  {@const path = [String(rowIndex)].concat(column)}\n                  {@const value = getIn(item, column)}\n                  {@const isSelected =\n                    isValueSelection(selection) && pathStartsWith(selection.path, path)}\n                  {@const validationErrorsByColumn = validationErrorsByRow?.columns[columnIndex]}\n                  {@const validationError = mergeValidationErrors(path, validationErrorsByColumn)}\n                  <td class=\"jse-table-cell\" data-path={encodeDataPath(path)}>\n                    <div class=\"jse-value-outer\" class:jse-selected-value={isSelected}>\n                      {#if isObjectOrArray(value)}\n                        {@const searchResultsByCell = flattenSearchResults(\n                          getInRecursiveState(item, searchResultByRow, column)\n                        )}\n\n                        {@const containsActiveSearchResult = searchResultsByCell\n                          ? searchResultsByCell.some((item) => item.active)\n                          : false}\n\n                        <InlineValue\n                          {path}\n                          {value}\n                          {parser}\n                          {isSelected}\n                          containsSearchResult={!isEmpty(searchResultsByCell)}\n                          {containsActiveSearchResult}\n                          onEdit={openJSONEditorModal}\n                        />{:else}\n                        {@const searchResultItemsByCell = getInRecursiveState(\n                          json,\n                          searchResults,\n                          path\n                        )?.searchResults}\n\n                        <JSONValue\n                          {path}\n                          value={value !== undefined ? value : ''}\n                          enforceString={getEnforceString(json, documentState, path)}\n                          selection={isSelected ? selection : undefined}\n                          searchResultItems={searchResultItemsByCell}\n                          {context}\n                        />{/if}{#if !readOnly && isSelected && !isEditingSelection(selection)}\n                        <div class=\"jse-context-menu-anchor\">\n                          <ContextMenuPointer selected={true} onContextMenu={openContextMenu} />\n                        </div>\n                      {/if}\n                    </div>\n                    {#if validationError}\n                      <ValidationErrorIcon {validationError} onExpand={noop} />\n                    {/if}\n                  </td>\n                {/each}\n                {#if showRefreshButton}\n                  <td class=\"jse-table-cell\"></td>\n                {/if}\n              </tr>\n            {/each}\n\n            <tr class=\"jse-table-invisible-end-section\">\n              <td style:height={visibleSection.endHeight + 'px'} colspan={columns.length}></td>\n            </tr>\n          </tbody>\n        </table>\n      </div>\n\n      {#if pastedJson}\n        <Message\n          type=\"info\"\n          message={`You pasted a JSON ${\n            Array.isArray(pastedJson.contents) ? 'array' : 'object'\n          } as text`}\n          actions={[\n            {\n              icon: faWrench,\n              text: 'Paste as JSON instead',\n              title: 'Paste the text as JSON instead of a single value',\n              // We use mousedown here instead of click: this message pops up\n              // whilst the user is editing a value. When clicking this button,\n              // the actual value is applied and the event is not propagated\n              // and an onClick on this button never happens.\n              onMouseDown: handleParsePastedJson\n            },\n            {\n              text: 'Leave as is',\n              title: 'Keep the pasted content as a single value',\n              onClick: handleClearPastedJson\n            }\n          ]}\n        />\n      {/if}\n\n      {#if textIsRepaired}\n        <Message\n          type=\"success\"\n          message=\"The loaded JSON document was invalid but is successfully repaired.\"\n          actions={!readOnly\n            ? [\n                {\n                  icon: faCheck,\n                  text: 'Ok',\n                  title: 'Accept the repaired document',\n                  onClick: acceptAutoRepair\n                },\n                {\n                  icon: faCode,\n                  text: 'Repair manually instead',\n                  title: 'Leave the document unchanged and repair it manually instead',\n                  onClick: handleRequestRepair\n                }\n              ]\n            : []}\n          onClose={focus}\n        />\n      {/if}\n\n      <ValidationErrorsOverview {validationErrors} selectError={handleSelectValidationError} />\n    {:else if parseError && text !== undefined && text !== ''}\n      <Message\n        type=\"error\"\n        message=\"The loaded JSON document is invalid and could not be repaired automatically.\"\n        actions={!readOnly\n          ? [\n              {\n                icon: faCode,\n                text: 'Repair manually',\n                title: 'Open the document in \"code\" mode and repair it manually',\n                onClick: handleRequestRepair\n              }\n            ]\n          : []}\n      />\n      <JSONPreview {text} {json} {indentation} {parser} />\n    {:else}\n      <TableModeWelcome\n        {text}\n        {json}\n        {readOnly}\n        {parser}\n        {openJSONEditorModal}\n        {onChangeMode}\n        onClick={() => {\n          // FIXME: this is a workaround for the editor not putting the focus on refHiddenInput\n          //  when clicking in the welcome screen so you cannot paste a document from clipboard.\n          focus()\n        }}\n      />\n    {/if}\n  {:else}\n    <div class=\"jse-contents jse-contents-loading\">\n      <div class=\"jse-loading-space\"></div>\n      <div class=\"jse-loading\">loading...</div>\n    </div>\n  {/if}\n</div>\n\n{#if copyPasteModalOpen}\n  <CopyPasteModal onClose={() => (copyPasteModalOpen = false)} />\n{/if}\n\n{#if jsonRepairModalProps}\n  <JSONRepairModal\n    {...jsonRepairModalProps}\n    onClose={() => {\n      jsonRepairModalProps?.onClose()\n      jsonRepairModalProps = undefined\n    }}\n  />\n{/if}\n\n<style src=\"./TableMode.scss\"></style>\n","import type { ContextMenuItem, DocumentState, JSONSelection } from 'svelte-jsoneditor'\nimport {\n  faCheckSquare,\n  faClone,\n  faCopy,\n  faCut,\n  faPaste,\n  faPen,\n  faPlus,\n  faSquare,\n  faTrashCan\n} from '@fortawesome/free-solid-svg-icons'\nimport { isKeySelection, isMultiSelection, isValueSelection } from '$lib/logic/selection'\nimport { getIn } from 'immutable-json-patch'\nimport { getFocusPath, singleItemSelected } from '$lib/logic/selection'\nimport { isObjectOrArray } from '$lib/utils/typeUtils'\nimport { getEnforceString } from '$lib/logic/documentState'\n\nexport default function ({\n  json,\n  documentState,\n  selection,\n  readOnly,\n  onEditValue,\n  onEditRow,\n  onToggleEnforceString,\n  onCut,\n  onCopy,\n  onPaste,\n  onRemove,\n  onDuplicateRow,\n  onInsertBeforeRow,\n  onInsertAfterRow,\n  onRemoveRow\n}: {\n  json: unknown | undefined\n  documentState: DocumentState | undefined\n  selection: JSONSelection | undefined\n  readOnly: boolean\n  onEditValue: () => void\n  onEditRow: () => void\n  onToggleEnforceString: () => void\n  onCut: (indent: boolean) => void\n  onCopy: (indent: boolean) => void\n  onPaste: () => void\n  onRemove: () => void\n  onDuplicateRow: () => void\n  onInsertBeforeRow: () => void\n  onInsertAfterRow: () => void\n  onRemoveRow: () => void\n}): ContextMenuItem[] {\n  const hasJson = json !== undefined\n  const hasSelection = !!selection\n  const focusValue =\n    json !== undefined && selection ? getIn(json, getFocusPath(selection)) : undefined\n\n  const hasSelectionContents =\n    hasJson &&\n    (isMultiSelection(selection) || isKeySelection(selection) || isValueSelection(selection))\n\n  const canEditValue =\n    !readOnly && hasJson && selection !== undefined && singleItemSelected(selection)\n  const canEnforceString = canEditValue && !isObjectOrArray(focusValue)\n\n  const canCut = !readOnly && hasSelectionContents\n\n  const enforceString =\n    selection !== undefined ? getEnforceString(json, documentState, getFocusPath(selection)) : false\n\n  return [\n    { type: 'separator' },\n    {\n      type: 'row',\n      items: [\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: 'Table cell:' },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onEditValue(),\n                icon: faPen,\n                text: 'Edit',\n                title: 'Edit the value (Double-click on the value)',\n                disabled: !canEditValue\n              },\n              width: '11em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faPen,\n                  text: 'Edit',\n                  title: 'Edit the value (Double-click on the value)',\n                  onClick: () => onEditValue(),\n                  disabled: !canEditValue\n                },\n                {\n                  type: 'button',\n                  icon: enforceString ? faCheckSquare : faSquare,\n                  text: 'Enforce string',\n                  title: 'Enforce keeping the value as string when it contains a numeric value',\n                  onClick: () => onToggleEnforceString(),\n                  disabled: !canEnforceString\n                }\n              ]\n            },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onCut(true),\n                icon: faCut,\n                text: 'Cut',\n                title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n                disabled: !canCut\n              },\n              width: '10em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faCut,\n                  text: 'Cut formatted',\n                  title: 'Cut selected contents, formatted with indentation (Ctrl+X)',\n                  onClick: () => onCut(true),\n                  disabled: readOnly || !hasSelectionContents\n                },\n                {\n                  type: 'button',\n                  icon: faCut,\n                  text: 'Cut compacted',\n                  title: 'Cut selected contents, without indentation (Ctrl+Shift+X)',\n                  onClick: () => onCut(false),\n                  disabled: readOnly || !hasSelectionContents\n                }\n              ]\n            },\n            {\n              type: 'dropdown-button',\n              main: {\n                type: 'button',\n                onClick: () => onCopy(true),\n                icon: faCopy,\n                text: 'Copy',\n                title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n                disabled: !hasSelectionContents\n              },\n              width: '12em',\n              items: [\n                {\n                  type: 'button',\n                  icon: faCopy,\n                  text: 'Copy formatted',\n                  title: 'Copy selected contents, formatted with indentation (Ctrl+C)',\n                  onClick: () => onCopy(false),\n                  disabled: !hasSelectionContents\n                },\n                {\n                  type: 'button',\n                  icon: faCopy,\n                  text: 'Copy compacted',\n                  title: 'Copy selected contents, without indentation (Ctrl+Shift+C)',\n                  onClick: () => onCopy(false),\n                  disabled: !hasSelectionContents\n                }\n              ]\n            },\n            {\n              type: 'button',\n              onClick: () => onPaste(),\n              icon: faPaste,\n              text: 'Paste',\n              title: 'Paste clipboard contents (Ctrl+V)',\n              disabled: readOnly || !hasSelection\n            },\n            {\n              type: 'button',\n              onClick: () => onRemove(),\n              icon: faTrashCan,\n              text: 'Remove',\n              title: 'Remove selected contents (Delete)',\n              disabled: readOnly || !hasSelectionContents\n            }\n          ]\n        },\n        {\n          type: 'column',\n          items: [\n            { type: 'label', text: 'Table row:' },\n            {\n              type: 'button',\n              onClick: () => onEditRow(),\n              icon: faPen,\n              text: 'Edit row',\n              title: 'Edit the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onDuplicateRow(),\n              icon: faClone,\n              text: 'Duplicate row',\n              title: 'Duplicate the current row (Ctrl+D)',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onInsertBeforeRow(),\n              icon: faPlus,\n              text: 'Insert before',\n              title: 'Insert a row before the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onInsertAfterRow(),\n              icon: faPlus,\n              text: 'Insert after',\n              title: 'Insert a row after the current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            },\n            {\n              type: 'button',\n              onClick: () => onRemoveRow(),\n              icon: faTrashCan,\n              text: 'Remove row',\n              title: 'Remove current row',\n              disabled: readOnly || !hasSelection || !hasJson\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { HistoryItem, History, MenuItem, OnRenderMenuInternal } from '$lib/types'\n  import Menu from '../../../controls/Menu.svelte'\n  import {\n    faEllipsisV,\n    faFilter,\n    faRedo,\n    faSearch,\n    faSortAmountDownAlt,\n    faUndo\n  } from '@fortawesome/free-solid-svg-icons'\n  import { CONTEXT_MENU_EXPLANATION } from '$lib/constants.js'\n\n  export let containsValidArray: boolean\n  export let readOnly: boolean\n  export let showSearch = false\n  export let history: History<HistoryItem>\n  export let onSort: () => void\n  export let onTransform: () => void\n  export let onContextMenu: (event: MouseEvent) => void\n  export let onUndo: () => void\n  export let onRedo: () => void\n  export let onRenderMenu: OnRenderMenuInternal\n\n  function handleToggleSearch() {\n    showSearch = !showSearch\n  }\n\n  let defaultItems: MenuItem[]\n  $: defaultItems = !readOnly\n    ? [\n        {\n          type: 'button',\n          icon: faSortAmountDownAlt,\n          title: 'Sort',\n          className: 'jse-sort',\n          onClick: onSort,\n          disabled: readOnly || !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faFilter,\n          title: 'Transform contents (filter, sort, project)',\n          className: 'jse-transform',\n          onClick: onTransform,\n          disabled: readOnly || !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faSearch,\n          title: 'Search (Ctrl+F)',\n          className: 'jse-search',\n          onClick: handleToggleSearch,\n          disabled: !containsValidArray\n        },\n        {\n          type: 'button',\n          icon: faEllipsisV,\n          title: CONTEXT_MENU_EXPLANATION,\n          className: 'jse-contextmenu',\n          onClick: onContextMenu\n        },\n        {\n          type: 'separator'\n        },\n        {\n          type: 'button',\n          icon: faUndo,\n          title: 'Undo (Ctrl+Z)',\n          className: 'jse-undo',\n          onClick: onUndo,\n          disabled: !history.canUndo\n        },\n        {\n          type: 'button',\n          icon: faRedo,\n          title: 'Redo (Ctrl+Shift+Z)',\n          className: 'jse-redo',\n          onClick: onRedo,\n          disabled: !history.canRedo\n        },\n        {\n          type: 'space'\n        }\n      ]\n    : [\n        {\n          type: 'space'\n        }\n      ]\n\n  let items: MenuItem[]\n  $: items = onRenderMenu(defaultItems) || defaultItems\n</script>\n\n<Menu {items} />\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { SortedColumn } from '$lib/types.js'\n  import { SortDirection } from '$lib/types.js'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import Icon from 'svelte-awesome'\n  import { faCaretDown, faCaretUp } from '@fortawesome/free-solid-svg-icons'\n  import { isEmpty, isEqual } from 'lodash-es'\n  import { MAX_HEADER_NAME_CHARACTERS, SORT_DIRECTION_NAMES } from '$lib/constants.js'\n  import { truncate } from '$lib/utils/stringUtils.js'\n\n  export let path: JSONPath\n  export let sortedColumn: SortedColumn | undefined\n  export let readOnly: boolean\n  export let onSort: (sortedColumn: SortedColumn) => void\n\n  // TODO: improve truncating of long column names when they are a deeply nested path: the last item from the path should be visible, and halfway the path is least interesting\n  $: columnName = !isEmpty(path) ? stringifyJSONPath(path) : 'values'\n\n  $: sortDirection =\n    sortedColumn && isEqual(path, sortedColumn?.path) ? sortedColumn.sortDirection : undefined\n\n  $: sortDirectionName = sortDirection ? SORT_DIRECTION_NAMES[sortDirection] : undefined\n\n  function handleSort() {\n    if (readOnly) {\n      return\n    }\n\n    onSort({\n      path,\n      sortDirection: sortDirection === SortDirection.asc ? SortDirection.desc : SortDirection.asc\n    })\n  }\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-column-header\"\n  class:jse-readonly={readOnly}\n  on:click={handleSort}\n  title={!readOnly ? columnName + ' (Click to sort the data by this column)' : columnName}\n>\n  <span class=\"jse-column-name\">\n    {truncate(columnName, MAX_HEADER_NAME_CHARACTERS)}\n  </span>\n  {#if sortDirection !== undefined}\n    <span class=\"jse-column-sort-icon\" title={`Currently sorted in ${sortDirectionName} order`}>\n      <Icon data={sortDirection === SortDirection.asc ? faCaretDown : faCaretUp} />\n    </span>\n  {/if}\n</button>\n\n<style src=\"./ColumnHeader.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import Icon from 'svelte-awesome'\n  import { faRotate } from '@fortawesome/free-solid-svg-icons'\n\n  export let count: number\n  export let maxSampleCount: number\n  export let readOnly: boolean\n  export let onRefresh: () => void\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-column-header\"\n  class:jse-readonly={readOnly}\n  title={`The Columns are created by sampling ${maxSampleCount} items out of ${count}. ` +\n    \"If you're missing a column, click here to sample all of the items instead of a subset. \" +\n    'This is slower.'}\n  on:click={() => onRefresh()}\n>\n  <Icon data={faRotate} />\n</button>\n\n<style src=\"./RefreshColumnHeader.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import type { JSONPath } from 'immutable-json-patch'\n  import type { JSONParser } from '$lib/types'\n  import { truncate } from '$lib/utils/stringUtils.js'\n  import { MAX_INLINE_OBJECT_CHARS } from '$lib/constants.js'\n\n  export let path: JSONPath\n  export let value: unknown\n  export let parser: JSONParser\n  export let isSelected: boolean\n  export let containsSearchResult: boolean\n  export let containsActiveSearchResult: boolean\n  export let onEdit: (path: JSONPath) => void\n</script>\n\n<button\n  type=\"button\"\n  class=\"jse-inline-value\"\n  class:jse-selected={isSelected}\n  class:jse-highlight={containsSearchResult}\n  class:jse-active={containsActiveSearchResult}\n  on:dblclick={() => onEdit(path)}\n>\n  {truncate(parser.stringify(value) ?? '', MAX_INLINE_OBJECT_CHARS)}\n</button>\n\n<style src=\"./InlineValue.scss\"></style>\n","<script lang=\"ts\">\n  import type {\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    HistoryItem,\n    History,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    MenuItem,\n    MenuSeparator,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnJSONEditorModal,\n    OnRenderContextMenu,\n    OnRenderContextMenuInternal,\n    OnRenderMenu,\n    OnRenderMenuInternal,\n    OnRenderValue,\n    OnSelect,\n    OnSortModal,\n    OnTransformModal,\n    TransformModalOptions,\n    Validator,\n    ModeHistoryItem\n  } from '$lib/types'\n  import { Mode } from '$lib/types.js'\n  import TextMode from './textmode/TextMode.svelte'\n  import TableMode from './tablemode/TableMode.svelte'\n  import TreeMode from './treemode/TreeMode.svelte'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { isMenuSpace, isModeHistoryItem } from '$lib/typeguards.js'\n  import { cloneDeep } from 'lodash-es'\n  import { createHistoryInstance } from '$lib/logic/history'\n  import { createDebug } from '$lib/utils/debug'\n\n  export let content: Content\n  export let selection: JSONEditorSelection | undefined\n\n  export let readOnly: boolean\n  export let indentation: number | string\n  export let tabSize: number\n  export let externalMode: Mode\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let parseMemoizeOne: JSONParser['parse']\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n  export let insideModal: boolean\n\n  export let onChange: OnChange\n  export let onChangeMode: OnChangeMode\n  export let onSelect: OnSelect\n  export let onRenderValue: OnRenderValue\n  export let onClassName: OnClassName\n  export let onRenderMenu: OnRenderMenu\n  export let onRenderContextMenu: OnRenderContextMenu\n  export let onError: OnError\n  export let onFocus: OnFocus\n  export let onBlur: OnBlur\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n  export let onJSONEditorModal: OnJSONEditorModal\n\n  let refTreeMode: TreeMode | undefined\n  let refTableMode: TableMode | undefined\n  let refTextMode: TextMode | undefined\n\n  const debug = createDebug('jsoneditor:JSONEditorRoot')\n\n  const historyInstance = createHistoryInstance<HistoryItem>({\n    onChange: (updatedHistory) => (history = updatedHistory)\n  })\n\n  let history: History<HistoryItem> = historyInstance.get()\n\n  let mode = externalMode\n\n  function applyExternalMode(externalMode: Mode) {\n    if (externalMode === mode) {\n      return\n    }\n\n    const item: ModeHistoryItem = {\n      type: 'mode',\n      undo: { mode, selection: undefined },\n      redo: { mode: externalMode, selection: undefined }\n    }\n\n    if (mode === 'text' && refTextMode) {\n      // flush pending changes before adding a new history item\n      refTextMode.flush()\n    }\n\n    debug('add history item', item)\n    history.add(item)\n\n    mode = externalMode\n  }\n\n  // eslint-disable-next-line svelte/no-unused-svelte-ignore\n  // svelte-ignore reactive_declaration_non_reactive_property\n  $: applyExternalMode(externalMode)\n\n  function handleUndo(item: HistoryItem | undefined) {\n    if (isModeHistoryItem(item)) {\n      mode = item.undo.mode // important to prevent a new history item from being created\n\n      // find the selection of the previous history item (if any), and use that as initial selection\n      const items = history.items()\n      const index = items.findIndex((i) => i === item)\n      const prevItem = index !== -1 ? items[index - 1] : undefined\n      debug('handleUndo', { index, item, items, prevItem })\n      if (prevItem) {\n        selection = prevItem.redo.selection\n      }\n\n      onChangeMode(mode)\n    }\n  }\n\n  function handleRedo(item: HistoryItem | undefined) {\n    if (isModeHistoryItem(item)) {\n      // prevent a new history item from being created\n      mode = item.redo.mode\n\n      // find the selection of the next history item (if any), and use that as initial selection\n      const items = history.items()\n      const index = items.findIndex((i) => i === item)\n      const nextItem = index !== -1 ? items[index + 1] : undefined\n      debug('handleRedo', { index, item, items, nextItem })\n      if (nextItem) {\n        selection = nextItem.undo.selection\n      }\n\n      onChangeMode(mode)\n    }\n  }\n\n  let modeMenuItems: MenuItem[]\n  $: modeMenuItems = [\n    {\n      type: 'button',\n      text: 'text',\n      title: `Switch to text mode (current mode: ${mode})`,\n      className: 'jse-group-button jse-first' + (mode === Mode.text ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.text)\n    },\n    {\n      type: 'button',\n      text: 'tree',\n      title: `Switch to tree mode (current mode: ${mode})`,\n      className: 'jse-group-button ' + (mode === Mode.tree ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.tree)\n    },\n    {\n      type: 'button',\n      text: 'table',\n      title: `Switch to table mode (current mode: ${mode})`,\n      className: 'jse-group-button jse-last' + (mode === Mode.table ? ' jse-selected' : ''),\n      onClick: () => onChangeMode(Mode.table)\n    }\n  ]\n\n  const separatorMenuItem: MenuSeparator = {\n    type: 'separator'\n  }\n\n  let handleRenderMenu: OnRenderMenuInternal\n  $: handleRenderMenu = (items: MenuItem[]) => {\n    const updatedItems = isMenuSpace(items[0])\n      ? modeMenuItems.concat(items) // menu is empty, readOnly mode\n      : modeMenuItems.concat(separatorMenuItem, items)\n\n    const updatedItemsOriginal = cloneDeep(updatedItems) // the user may change updatedItems in the callback\n\n    return (\n      onRenderMenu(updatedItems, { mode, modal: insideModal, readOnly }) || updatedItemsOriginal\n    )\n  }\n\n  let handleRenderContextMenu: OnRenderContextMenuInternal\n  $: handleRenderContextMenu = (items: ContextMenuItem[]) => {\n    const itemsOriginal = cloneDeep(items) // the user may change items in the callback\n\n    return (\n      onRenderContextMenu(items, { mode, modal: insideModal, readOnly, selection }) ??\n      (readOnly ? false : itemsOriginal)\n    )\n  }\n\n  export function patch(operations: JSONPatchDocument): JSONPatchResult {\n    if (refTreeMode) {\n      // Note that tree mode has an optional afterPatch callback.\n      // right now we don's support this in the public API.\n      return refTreeMode.patch(operations)\n    }\n\n    if (refTableMode) {\n      // Note that tree mode has an optional afterPatch callback.\n      // right now we don's support this in the public API.\n      return refTableMode.patch(operations)\n    }\n\n    if (refTextMode) {\n      return refTextMode.patch(operations)\n    }\n\n    throw new Error(`Method patch is not available in mode \"${mode}\"`)\n  }\n\n  export function expand(path: JSONPath, callback?: OnExpand): void {\n    if (refTreeMode) {\n      return refTreeMode.expand(path, callback)\n    } else {\n      throw new Error(`Method expand is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function collapse(path: JSONPath, recursive: boolean): void {\n    if (refTreeMode) {\n      return refTreeMode.collapse(path, recursive)\n    } else {\n      throw new Error(`Method collapse is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * Open the transform modal\n   */\n  export function transform(options: TransformModalOptions): void {\n    if (refTextMode) {\n      refTextMode.openTransformModal(options)\n    } else if (refTreeMode) {\n      refTreeMode.openTransformModal(options)\n    } else if (refTableMode) {\n      refTableMode.openTransformModal(options)\n    } else {\n      throw new Error(`Method transform is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * Validate the contents of the editor using the configured validator.\n   * Returns a parse error or a list with validation warnings\n   */\n  export function validate(): ContentErrors | undefined {\n    if (refTextMode) {\n      return refTextMode.validate()\n    } else if (refTreeMode) {\n      return refTreeMode.validate()\n    } else if (refTableMode) {\n      return refTableMode.validate()\n    } else {\n      throw new Error(`Method validate is not available in mode \"${mode}\"`)\n    }\n  }\n\n  /**\n   * In tree mode, invalid JSON is automatically repaired when loaded. When the\n   * repair was successful, the repaired contents are rendered but not yet\n   * applied to the document itself until the user clicks \"Ok\" or starts editing\n   * the data. Instead of accepting the repair, the user can also click\n   * \"Repair manually instead\". Invoking `.acceptAutoRepair()` will\n   * programmatically accept the repair. This will trigger an update,\n   * and the method itself also returns the updated contents. In case of text\n   * mode or when the editor is not in an \"accept auto repair\" status, nothing\n   * will happen, and the contents will be returned as is.\n   */\n  export function acceptAutoRepair(): Content {\n    if (refTreeMode) {\n      return refTreeMode.acceptAutoRepair()\n    } else {\n      return content\n    }\n  }\n\n  export function scrollTo(path: JSONPath): Promise<void> {\n    if (refTreeMode) {\n      return refTreeMode.scrollTo(path)\n    } else if (refTableMode) {\n      return refTableMode.scrollTo(path)\n    } else {\n      // TODO: implement scrollTo for text mode\n      throw new Error(`Method scrollTo is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function findElement(path: JSONPath): Element | undefined {\n    if (refTreeMode) {\n      return refTreeMode.findElement(path)\n    } else if (refTableMode) {\n      return refTableMode.findElement(path)\n    } else {\n      throw new Error(`Method findElement is not available in mode \"${mode}\"`)\n    }\n  }\n\n  export function focus() {\n    if (refTextMode) {\n      refTextMode.focus()\n    } else if (refTreeMode) {\n      refTreeMode.focus()\n    } else if (refTableMode) {\n      refTableMode.focus()\n    }\n  }\n\n  export async function refresh(): Promise<void> {\n    if (refTextMode) {\n      await refTextMode.refresh()\n    } else {\n      // nothing to do in tree or table mode (also: don't throw an exception or so,\n      // that annoying having to reckon with that when using .refresh()).\n    }\n  }\n</script>\n\n{#if mode === Mode.text || String(mode) === 'code'}\n  <TextMode\n    bind:this={refTextMode}\n    externalContent={content}\n    externalSelection={selection}\n    {history}\n    {readOnly}\n    {indentation}\n    {tabSize}\n    {mainMenuBar}\n    {statusBar}\n    {askToFormat}\n    {escapeUnicodeCharacters}\n    {parser}\n    {validator}\n    {validationParser}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    onUndo={handleUndo}\n    onRedo={handleRedo}\n    {onError}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    {onSortModal}\n    {onTransformModal}\n  />\n{:else if mode === Mode.table}\n  <TableMode\n    bind:this={refTableMode}\n    externalContent={content}\n    externalSelection={selection}\n    {history}\n    {readOnly}\n    {mainMenuBar}\n    {escapeControlCharacters}\n    {escapeUnicodeCharacters}\n    {flattenColumns}\n    {parser}\n    {parseMemoizeOne}\n    {validator}\n    {validationParser}\n    {indentation}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    onUndo={handleUndo}\n    onRedo={handleRedo}\n    {onRenderValue}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    onRenderContextMenu={handleRenderContextMenu}\n    {onSortModal}\n    {onTransformModal}\n    {onJSONEditorModal}\n  />\n{:else}\n  <!-- mode === Mode.tree -->\n  <TreeMode\n    bind:this={refTreeMode}\n    externalContent={content}\n    externalSelection={selection}\n    {history}\n    {readOnly}\n    {indentation}\n    {mainMenuBar}\n    {navigationBar}\n    {escapeControlCharacters}\n    {escapeUnicodeCharacters}\n    {parser}\n    {parseMemoizeOne}\n    {validator}\n    {validationParser}\n    {pathParser}\n    {onError}\n    {onChange}\n    {onChangeMode}\n    {onSelect}\n    onUndo={handleUndo}\n    onRedo={handleRedo}\n    {onRenderValue}\n    {onClassName}\n    {onFocus}\n    {onBlur}\n    onRenderMenu={handleRenderMenu}\n    onRenderContextMenu={handleRenderContextMenu}\n    {onSortModal}\n    {onTransformModal}\n    {onJSONEditorModal}\n  />\n{/if}\n","import type { NumberOption, PathOption } from '$lib/types.js'\n\nexport interface SortModalState {\n  selectedProperty: PathOption\n  selectedDirection: NumberOption\n}\n\nexport const sortModalStates: Record<string, SortModalState> = {}\n","<svelte:options accessors={false} immutable={true} />\n\n<script lang=\"ts\">\n  import { createDebug } from '../utils/debug.js'\n  import { uniqueId } from '../utils/uniqueId.js'\n  import { isEqualParser, isJSONContent, validateContentType } from '../utils/jsonUtils.js'\n  import AbsolutePopup from './modals/popup/AbsolutePopup.svelte'\n  import { jsonQueryLanguage } from '$lib/plugins/query/jsonQueryLanguage.js'\n  import { renderValue } from '$lib/plugins/value/renderValue.js'\n  import { tick } from 'svelte'\n  import TransformModal from './modals/TransformModal.svelte'\n  import type {\n    Content,\n    ContentErrors,\n    ContextMenuItem,\n    JSONEditorModalCallback,\n    JSONEditorModalProps,\n    JSONEditorPropsOptional,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPatchResult,\n    JSONPathParser,\n    MenuItem,\n    OnBlur,\n    OnChange,\n    OnChangeMode,\n    OnChangeQueryLanguage,\n    OnChangeStatus,\n    OnClassName,\n    OnError,\n    OnExpand,\n    OnFocus,\n    OnRenderMenu,\n    OnRenderValue,\n    OnSelect,\n    QueryLanguage,\n    SortModalCallback,\n    TransformModalCallback,\n    TransformModalOptions,\n    TransformModalProps,\n    Validator\n  } from '$lib/types'\n  import type { OnRenderContextMenu } from '$lib/types.js'\n  import { Mode } from '$lib/types.js'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { noop } from '../utils/noop.js'\n  import { parseJSONPath, stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import JSONEditorRoot from './modes/JSONEditorRoot.svelte'\n  import JSONEditorModal from './modals/JSONEditorModal.svelte'\n  import memoizeOne from 'memoize-one'\n  import { cloneDeep } from 'lodash-es'\n  import SortModal from './modals/SortModal.svelte'\n\n  // TODO: document how to enable debugging in the readme: localStorage.debug=\"jsoneditor:*\", then reload\n  const debug = createDebug('jsoneditor:JSONEditor')\n\n  const contentDefault = { text: '' }\n  const selectionDefault = undefined\n  const readOnlyDefault = false\n  const indentationDefault = 2\n  const tabSizeDefault = 4\n  const modeDefault = Mode.tree\n  const mainMenuBarDefault = true\n  const navigationBarDefault = true\n  const statusBarDefault = true\n  const askToFormatDefault = true\n  const escapeControlCharactersDefault = false\n  const escapeUnicodeCharactersDefault = false\n  const flattenColumnsDefault = true\n  const parserDefault = JSON\n  const validatorDefault = undefined\n  const validationParserDefault = JSON\n  const pathParserDefault = {\n    parse: parseJSONPath,\n    stringify: stringifyJSONPath\n  }\n  const queryLanguagesDefault = [jsonQueryLanguage]\n  const queryLanguageIdDefault = queryLanguagesDefault[0].id\n  const onChangeQueryLanguageDefault = noop\n  const onChangeDefault = undefined\n  const onSelectDefault = undefined\n  const onRenderValueDefault = renderValue\n  const onClassNameDefault = noop\n  const onRenderMenuDefault = noop\n  const onRenderContextMenuDefault = noop\n  const onChangeModeDefault = noop\n  const onErrorDefault: OnError = (err) => {\n    console.error(err)\n    alert(err.toString()) // TODO: create a nice alert modal\n  }\n  const onFocusDefault = noop\n  const onBlurDefault = noop\n\n  export let content: Content = contentDefault\n  export let selection: JSONEditorSelection | undefined = selectionDefault\n  export let readOnly: boolean = readOnlyDefault\n  export let indentation: number | string = indentationDefault\n  export let tabSize: number = tabSizeDefault\n  export let mode: Mode = modeDefault\n  export let mainMenuBar: boolean = mainMenuBarDefault\n  export let navigationBar: boolean = navigationBarDefault\n  export let statusBar: boolean = statusBarDefault\n  export let askToFormat: boolean = askToFormatDefault\n  export let escapeControlCharacters: boolean = escapeControlCharactersDefault\n  export let escapeUnicodeCharacters: boolean = escapeUnicodeCharactersDefault\n  export let flattenColumns: boolean = flattenColumnsDefault\n  export let parser: JSONParser = parserDefault\n  export let validator: Validator | undefined = validatorDefault\n  export let validationParser: JSONParser = validationParserDefault\n  export let pathParser: JSONPathParser = pathParserDefault\n  export let queryLanguages: QueryLanguage[] = queryLanguagesDefault\n  export let queryLanguageId: string = queryLanguageIdDefault\n  export let onChangeQueryLanguage: OnChangeQueryLanguage = onChangeQueryLanguageDefault\n  export let onChange: OnChange | undefined = onChangeDefault\n  export let onSelect: OnSelect | undefined = onSelectDefault\n  export let onRenderValue: OnRenderValue = onRenderValueDefault\n  export let onClassName: OnClassName = onClassNameDefault\n  export let onRenderMenu: OnRenderMenu = onRenderMenuDefault\n  export let onRenderContextMenu: OnRenderContextMenu = onRenderContextMenuDefault\n  export let onChangeMode: OnChangeMode = onChangeModeDefault\n  export let onError: OnError = onErrorDefault\n  export let onFocus: OnFocus = onFocusDefault\n  export let onBlur: OnBlur = onBlurDefault\n\n  let instanceId = uniqueId()\n  let hasFocus = false\n  let refJSONEditorRoot: JSONEditorRoot\n  let jsonEditorModalProps: JSONEditorModalProps | undefined = undefined\n  let sortModalProps: SortModalCallback | undefined\n  let transformModalProps: TransformModalProps | undefined\n\n  $: {\n    const contentError = validateContentType(content)\n    if (contentError) {\n      console.error('Error: ' + contentError)\n    }\n  }\n\n  // backward compatibility warning since v1.0.0\n  $: if (selection === null) {\n    console.warn('selection is invalid: it is null but should be undefined')\n  }\n\n  // We memoize the last parse result for the case when the content is text and very large.\n  // In that case parsing takes a few seconds. When the user switches between tree and table mode,\n  // without having made a change, we do not want to parse the text again.\n  $: parseMemoizeOne = memoizeOne(parser.parse)\n\n  // rerender the full editor when the parser changes. This is needed because\n  // numeric state is hold at many places in the editor.\n  let previousParser = parser\n  $: {\n    if (!isEqualParser(parser, previousParser)) {\n      debug('parser changed, recreate editor')\n\n      if (isJSONContent(content)) {\n        const text = previousParser.stringify(content.json)\n        content = {\n          json: text !== undefined ? parser.parse(text) : undefined\n        }\n      }\n\n      previousParser = parser\n\n      // new editor id -> will re-create the editor\n      instanceId = uniqueId()\n    }\n  }\n\n  export function get(): Content {\n    return content\n  }\n\n  export async function set(newContent: Content): Promise<void> {\n    debug('set')\n\n    const contentError = validateContentType(newContent)\n    if (contentError) {\n      throw new Error(contentError)\n    }\n\n    // new editor id -> will re-create the editor\n    instanceId = uniqueId()\n\n    // update content *after* re-render, so that the new editor will trigger an onChange event\n    content = newContent\n  }\n\n  export async function update(updatedContent: Content): Promise<void> {\n    debug('update')\n\n    const contentError = validateContentType(updatedContent)\n    if (contentError) {\n      throw new Error(contentError)\n    }\n\n    content = updatedContent\n\n    await tick() // await rerender\n  }\n\n  export async function patch(operations: JSONPatchDocument): Promise<JSONPatchResult> {\n    // Note that patch has an optional afterPatch callback.\n    // right now we don's support this in the public API.\n    const result = refJSONEditorRoot.patch(operations)\n\n    await tick() // await rerender\n\n    return result\n  }\n\n  export async function select(newSelection: JSONEditorSelection | undefined) {\n    selection = newSelection\n\n    await tick() // await rerender\n  }\n\n  export async function expand(path: JSONPath, callback?: OnExpand): Promise<void> {\n    refJSONEditorRoot.expand(path, callback)\n\n    await tick() // await rerender\n  }\n\n  export async function collapse(path: JSONPath, recursive = false): Promise<void> {\n    refJSONEditorRoot.collapse(path, recursive)\n\n    await tick() // await rerender\n  }\n\n  /**\n   * Open the transform modal\n   */\n  export function transform(options: TransformModalOptions): void {\n    refJSONEditorRoot.transform(options)\n  }\n\n  /**\n   * Validate the contents of the editor using the configured validator.\n   * Returns a parse error or a list with validation warnings\n   */\n  export function validate(): ContentErrors | undefined {\n    return refJSONEditorRoot.validate()\n  }\n\n  /**\n   * In tree mode, invalid JSON is automatically repaired when loaded. When the\n   * repair was successful, the repaired contents are rendered but not yet\n   * applied to the document itself until the user clicks \"Ok\" or starts editing\n   * the data. Instead of accepting the repair, the user can also click\n   * \"Repair manually instead\". Invoking `.acceptAutoRepair()` will\n   * programmatically accept the repair. This will trigger an update,\n   * and the method itself also returns the updated contents. In case of text\n   * mode or when the editor is not in an \"accept auto repair\" status, nothing\n   * will happen, and the contents will be returned as is.\n   */\n  export async function acceptAutoRepair(): Promise<Content> {\n    const content = refJSONEditorRoot.acceptAutoRepair()\n\n    await tick() // await rerender\n\n    return content\n  }\n\n  export async function scrollTo(path: JSONPath): Promise<void> {\n    await refJSONEditorRoot.scrollTo(path)\n  }\n\n  export function findElement(path: JSONPath): Element | undefined {\n    return refJSONEditorRoot.findElement(path)\n  }\n\n  export async function focus(): Promise<void> {\n    refJSONEditorRoot.focus()\n\n    await tick() // await rerender\n  }\n\n  export async function refresh(): Promise<void> {\n    await refJSONEditorRoot.refresh()\n  }\n\n  export async function updateProps(props: JSONEditorPropsOptional): Promise<void> {\n    const names = Object.keys(props) as (keyof JSONEditorPropsOptional)[]\n\n    for (const name of names) {\n      switch (name) {\n        case 'content':\n          content = props[name] ?? contentDefault\n          break\n        case 'selection':\n          selection = props[name] ?? selectionDefault\n          break\n        case 'readOnly':\n          readOnly = props[name] ?? readOnlyDefault\n          break\n        case 'indentation':\n          indentation = props[name] ?? indentationDefault\n          break\n        case 'tabSize':\n          tabSize = props[name] ?? tabSizeDefault\n          break\n        case 'mode':\n          mode = props[name] ?? modeDefault\n          break\n        case 'mainMenuBar':\n          mainMenuBar = props[name] ?? mainMenuBarDefault\n          break\n        case 'navigationBar':\n          navigationBar = props[name] ?? navigationBarDefault\n          break\n        case 'statusBar':\n          statusBar = props[name] ?? statusBarDefault\n          break\n        case 'askToFormat':\n          askToFormat = props[name] ?? askToFormatDefault\n          break\n        case 'escapeControlCharacters':\n          escapeControlCharacters = props[name] ?? escapeControlCharactersDefault\n          break\n        case 'escapeUnicodeCharacters':\n          escapeUnicodeCharacters = props[name] ?? escapeUnicodeCharactersDefault\n          break\n        case 'flattenColumns':\n          flattenColumns = props[name] ?? flattenColumnsDefault\n          break\n        case 'parser':\n          parser = props[name] ?? parserDefault\n          break\n        case 'validator':\n          validator = props[name] ?? validatorDefault\n          break\n        case 'validationParser':\n          validationParser = props[name] ?? validationParserDefault\n          break\n        case 'pathParser':\n          pathParser = props[name] ?? pathParserDefault\n          break\n        case 'queryLanguages':\n          queryLanguages = props[name] ?? queryLanguagesDefault\n          break\n        case 'queryLanguageId':\n          queryLanguageId = props[name] ?? queryLanguageIdDefault\n          break\n        case 'onChangeQueryLanguage':\n          onChangeQueryLanguage = props[name] ?? onChangeQueryLanguageDefault\n          break\n        case 'onChange':\n          onChange = props[name] ?? onChangeDefault\n          break\n        case 'onRenderValue':\n          onRenderValue = props[name] ?? onRenderValueDefault\n          break\n        case 'onClassName':\n          onClassName = props[name] ?? onClassNameDefault\n          break\n        case 'onRenderMenu':\n          onRenderMenu = props[name] ?? onRenderMenuDefault\n          break\n        case 'onRenderContextMenu':\n          onRenderContextMenu = props[name] ?? onRenderContextMenuDefault\n          break\n        case 'onChangeMode':\n          onChangeMode = props[name] ?? onChangeModeDefault\n          break\n        case 'onSelect':\n          onSelect = props[name] ?? onSelectDefault\n          break\n        case 'onError':\n          onError = props[name] ?? onErrorDefault\n          break\n        case 'onFocus':\n          onFocus = props[name] ?? onFocusDefault\n          break\n        case 'onBlur':\n          onBlur = props[name] ?? onBlurDefault\n          break\n\n        default:\n          // We should never reach this default case\n          unknownProperty(name)\n      }\n    }\n\n    if (!queryLanguages.some((queryLanguage) => queryLanguage.id === queryLanguageId)) {\n      queryLanguageId = queryLanguages[0].id\n    }\n\n    function unknownProperty(name: never) {\n      debug(`Unknown property \"${name}\"`)\n    }\n\n    await tick() // await rerender\n  }\n\n  export async function destroy() {\n    throw new Error(\n      'class method destroy() is deprecated. ' +\n        'It is replaced with a method destroy() in the vanilla library.'\n    )\n  }\n\n  function handleChange(updatedContent: Content, previousContent: Content, status: OnChangeStatus) {\n    content = updatedContent\n\n    if (onChange) {\n      onChange(updatedContent, previousContent, status)\n    }\n  }\n\n  function handleSelect(updatedSelection: JSONEditorSelection | undefined) {\n    selection = updatedSelection\n\n    if (onSelect) {\n      onSelect(cloneDeep(updatedSelection))\n    }\n  }\n\n  function handleFocus() {\n    hasFocus = true\n    if (onFocus) {\n      onFocus()\n    }\n  }\n\n  function handleBlur() {\n    hasFocus = false\n    if (onBlur) {\n      onBlur()\n    }\n  }\n\n  async function toggleMode(newMode: Mode) {\n    if (mode === newMode) {\n      return\n    }\n\n    mode = newMode\n\n    await tick()\n    await focus()\n\n    onChangeMode(newMode)\n  }\n\n  function handleChangeQueryLanguage(newQueryLanguageId: string) {\n    debug('handleChangeQueryLanguage', newQueryLanguageId)\n    queryLanguageId = newQueryLanguageId\n    onChangeQueryLanguage(newQueryLanguageId)\n  }\n\n  // The onTransformModal method is located in JSONEditor to prevent circular references:\n  //     TreeMode -> TransformModal -> TreeMode\n  function onTransformModal({ id, json, rootPath, onTransform, onClose }: TransformModalCallback) {\n    if (readOnly) {\n      return\n    }\n\n    transformModalProps = {\n      id,\n      json,\n      rootPath,\n      indentation,\n      escapeControlCharacters,\n      escapeUnicodeCharacters,\n      parser,\n      parseMemoizeOne,\n      validationParser,\n      pathParser,\n      queryLanguages,\n      queryLanguageId,\n      onChangeQueryLanguage: handleChangeQueryLanguage,\n      onRenderValue,\n      onRenderMenu: (items: MenuItem[]) => onRenderMenu(items, { mode, modal: true, readOnly }),\n      onRenderContextMenu: (items: ContextMenuItem[]) =>\n        onRenderContextMenu(items, { mode, modal: true, readOnly, selection }),\n      onClassName,\n      onTransform,\n      onClose\n    }\n  }\n\n  // The onSortModal is positioned here for consistency with TransformModal\n  function onSortModal(props: SortModalCallback) {\n    if (readOnly) {\n      return\n    }\n\n    sortModalProps = props\n  }\n\n  // The onJSONEditorModal method is located in JSONEditor to prevent circular references:\n  //     JSONEditor -> TableMode -> JSONEditorModal -> JSONEditor\n  function onJSONEditorModal({ content, path, onPatch, onClose }: JSONEditorModalCallback) {\n    debug('onJSONEditorModal', { content, path })\n\n    jsonEditorModalProps = {\n      content,\n      path,\n      onPatch,\n\n      readOnly,\n      indentation,\n      tabSize,\n      mainMenuBar,\n      navigationBar,\n      statusBar,\n      askToFormat,\n      escapeControlCharacters,\n      escapeUnicodeCharacters,\n      flattenColumns,\n      parser,\n      validator: undefined, // TODO: support partial JSON validation?\n      validationParser,\n      pathParser,\n      onRenderValue,\n      onClassName,\n      onRenderMenu,\n      onRenderContextMenu,\n      onSortModal,\n      onTransformModal,\n      onClose\n    }\n  }\n\n  $: debug('mode changed to', mode)\n</script>\n\n<AbsolutePopup>\n  <div class=\"jse-main\" class:jse-focus={hasFocus}>\n    {#key instanceId}\n      <JSONEditorRoot\n        bind:this={refJSONEditorRoot}\n        externalMode={mode}\n        {content}\n        {selection}\n        {readOnly}\n        {indentation}\n        {tabSize}\n        {statusBar}\n        {askToFormat}\n        {mainMenuBar}\n        {navigationBar}\n        {escapeControlCharacters}\n        {escapeUnicodeCharacters}\n        {flattenColumns}\n        {parser}\n        {parseMemoizeOne}\n        {validator}\n        {validationParser}\n        {pathParser}\n        insideModal={false}\n        {onError}\n        onChange={handleChange}\n        onChangeMode={toggleMode}\n        onSelect={handleSelect}\n        {onRenderValue}\n        {onClassName}\n        onFocus={handleFocus}\n        onBlur={handleBlur}\n        {onRenderMenu}\n        {onRenderContextMenu}\n        {onSortModal}\n        {onTransformModal}\n        {onJSONEditorModal}\n      />\n    {/key}\n  </div>\n\n  {#if sortModalProps}\n    <SortModal\n      {...sortModalProps}\n      onClose={() => {\n        sortModalProps?.onClose()\n        sortModalProps = undefined\n      }}\n    />\n  {/if}\n\n  {#if transformModalProps}\n    <TransformModal\n      {...transformModalProps}\n      onClose={() => {\n        transformModalProps?.onClose()\n        transformModalProps = undefined\n      }}\n    />\n  {/if}\n\n  {#if jsonEditorModalProps}\n    <JSONEditorModal\n      {...jsonEditorModalProps}\n      onClose={() => {\n        jsonEditorModalProps?.onClose()\n        jsonEditorModalProps = undefined\n      }}\n    />\n  {/if}\n</AbsolutePopup>\n\n<style src=\"./JSONEditor.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { isEmpty } from 'lodash-es'\n  import Select from 'svelte-select'\n  import Header from './Header.svelte'\n  import { getNestedPaths } from '$lib/utils/arrayUtils.js'\n  import { pathToOption, stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { sortJson } from '$lib/logic/sort.js'\n  import { sortModalStates } from './sortModalStates'\n  import type { JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, getIn } from 'immutable-json-patch'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type { OnSort } from '$lib/types.js'\n  import Modal from './Modal.svelte'\n\n  const debug = createDebug('jsoneditor:SortModal')\n\n  export let id: string\n  export let json: unknown // the whole document\n  export let rootPath: JSONPath\n  export let onSort: OnSort\n  export let onClose: () => void\n\n  $: selectedJson = getIn(json, rootPath)\n  $: jsonIsArray = Array.isArray(selectedJson)\n  $: paths = jsonIsArray ? getNestedPaths(selectedJson) : undefined\n  $: properties = paths ? paths.map(pathToOption) : undefined\n\n  const asc = {\n    value: 1,\n    label: 'ascending'\n  }\n  const desc = {\n    value: -1,\n    label: 'descending'\n  }\n  const directions = [asc, desc]\n\n  const stateId = `${id}:${compileJSONPointer(rootPath)}`\n  let selectedProperty = sortModalStates[stateId]?.selectedProperty\n  let selectedDirection = sortModalStates[stateId]?.selectedDirection || asc\n  let sortError: string | undefined = undefined\n\n  $: {\n    // remember the selected values for the next time we open the SortModal\n    // just in memory, not persisted\n    sortModalStates[stateId] = {\n      selectedProperty,\n      selectedDirection\n    }\n\n    debug('store state in memory', stateId, sortModalStates[stateId])\n  }\n\n  function handleSort() {\n    try {\n      sortError = undefined\n\n      const itemPath: JSONPath = selectedProperty?.value || properties?.[0]?.value || []\n      const direction = selectedDirection?.value\n      const operations = sortJson(json, rootPath, itemPath, direction)\n      if (onSort !== undefined && rootPath !== undefined) {\n        onSort({ operations, rootPath, itemPath, direction })\n      }\n\n      onClose()\n    } catch (err) {\n      sortError = String(err)\n    }\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n</script>\n\n<Modal {onClose} className=\"jse-sort-modal\">\n  <Header title={jsonIsArray ? 'Sort array items' : 'Sort object keys'} {onClose} />\n\n  <div class=\"jse-modal-contents\">\n    <table>\n      <colgroup>\n        <col width=\"25%\" />\n        <col width=\"75%\" />\n      </colgroup>\n      <tbody>\n        <tr>\n          <th>Path</th>\n          <td>\n            <input\n              class=\"jse-path\"\n              type=\"text\"\n              readonly\n              title=\"Selected path\"\n              value={rootPath && !isEmpty(rootPath)\n                ? stringifyJSONPath(rootPath)\n                : '(document root)'}\n            />\n          </td>\n        </tr>\n        {#if jsonIsArray && ((properties && properties?.length > 1) || selectedProperty === undefined)}\n          <tr>\n            <th>Property</th>\n            <td>\n              <Select showChevron items={properties} bind:value={selectedProperty} />\n            </td>\n          </tr>\n        {/if}\n        <tr>\n          <th>Direction</th>\n          <td>\n            <Select\n              showChevron\n              clearable={false}\n              items={directions}\n              bind:value={selectedDirection}\n            />\n          </td>\n        </tr>\n      </tbody>\n    </table>\n\n    <div class=\"jse-space\">\n      {#if sortError}\n        <div class=\"jse-error\">\n          {sortError}\n        </div>\n      {/if}\n    </div>\n\n    <div class=\"jse-actions\">\n      <button\n        type=\"button\"\n        class=\"jse-primary\"\n        on:click={handleSort}\n        use:focus\n        disabled={jsonIsArray && properties && properties?.length > 1 ? !selectedProperty : false}\n      >\n        Sort\n      </button>\n    </div>\n  </div>\n</Modal>\n\n<style src=\"./SortModal.scss\"></style>\n","<svelte:options immutable={true} />\n\n<script lang=\"ts\">\n  import { onMount, tick } from 'svelte'\n  import Header from './Header.svelte'\n  import type { JSONPatchDocument, JSONPath } from 'immutable-json-patch'\n  import { compileJSONPointer, immutableJSONPatch, isJSONArray } from 'immutable-json-patch'\n  import { createDebug } from '$lib/utils/debug.js'\n  import type {\n    Content,\n    JSONEditorModalCallback,\n    JSONEditorSelection,\n    JSONParser,\n    JSONPathParser,\n    OnClassName,\n    OnPatch,\n    OnRenderContextMenu,\n    OnRenderMenu,\n    OnRenderValue,\n    OnSortModal,\n    OnTransformModal,\n    Validator\n  } from '$lib/types'\n  import { Mode } from '$lib/types.js'\n  import JSONEditorRoot from '../modes/JSONEditorRoot.svelte'\n  import { noop } from '$lib/utils/noop.js'\n  import { stringifyJSONPath } from '$lib/utils/pathUtils.js'\n  import { initial, isEmpty, last } from 'lodash-es'\n  import { isJSONContent, toJSONContent } from '$lib/utils/jsonUtils.js'\n  import Icon from 'svelte-awesome'\n  import { faCaretLeft } from '@fortawesome/free-solid-svg-icons'\n  import memoizeOne from 'memoize-one'\n  import { getFocusPath, isJSONSelection } from '$lib/logic/selection.js'\n  import Modal from './Modal.svelte'\n  import AbsolutePopup from './popup/AbsolutePopup.svelte'\n\n  const debug = createDebug('jsoneditor:JSONEditorModal')\n\n  export let content: Content // the nested document\n  export let path: JSONPath\n  export let onPatch: OnPatch\n\n  export let readOnly: boolean\n  export let indentation: number | string\n  export let tabSize: number\n  export let mainMenuBar: boolean\n  export let navigationBar: boolean\n  export let statusBar: boolean\n  export let askToFormat: boolean\n  export let escapeControlCharacters: boolean\n  export let escapeUnicodeCharacters: boolean\n  export let flattenColumns: boolean\n  export let parser: JSONParser\n  export let validator: Validator | undefined\n  export let validationParser: JSONParser\n  export let pathParser: JSONPathParser\n\n  export let onRenderValue: OnRenderValue\n  export let onClassName: OnClassName\n  export let onRenderMenu: OnRenderMenu\n  export let onRenderContextMenu: OnRenderContextMenu\n\n  export let onSortModal: OnSortModal\n  export let onTransformModal: OnTransformModal\n\n  export let onClose: () => void\n\n  interface ModalState {\n    mode: Mode\n    content: Content\n    selection: JSONEditorSelection | undefined\n    relativePath: JSONPath\n  }\n\n  let refEditor: JSONEditorRoot\n  let fullscreen: boolean\n\n  const rootState: ModalState = {\n    mode: determineMode(content),\n    content,\n    selection: undefined,\n    relativePath: path\n  }\n  let stack: ModalState[] = [rootState]\n\n  $: currentState = last(stack) || rootState\n  $: absolutePath = stack.flatMap((state) => state.relativePath)\n  $: pathDescription = !isEmpty(absolutePath) ? stringifyJSONPath(absolutePath) : '(document root)'\n\n  // not relevant in this Modal setting, but well\n  $: parseMemoizeOne = memoizeOne(parser.parse)\n\n  let error: string | undefined = undefined\n\n  onMount(() => {\n    refEditor?.focus()\n  })\n\n  function determineMode(content: Content): Mode {\n    return isJSONContent(content) && isJSONArray(content.json) ? Mode.table : Mode.tree\n  }\n\n  function scrollToSelection() {\n    const selection: JSONEditorSelection | undefined = last(stack)?.selection\n    if (isJSONSelection(selection)) {\n      refEditor.scrollTo(getFocusPath(selection))\n    }\n  }\n\n  function handleApply() {\n    debug('handleApply')\n\n    if (readOnly) {\n      return\n    }\n\n    try {\n      error = undefined\n\n      const path = currentState.relativePath\n      const content = currentState.content\n      const operations: JSONPatchDocument = [\n        {\n          op: 'replace',\n          path: compileJSONPointer(path),\n          value: toJSONContent(content, parser).json // this can throw an error\n        }\n      ]\n\n      if (stack.length > 1) {\n        const parentContent = stack[stack.length - 2].content\n        const parentJson = toJSONContent(parentContent, parser).json\n        const updatedParentContent = {\n          json: immutableJSONPatch(parentJson, operations)\n        }\n\n        // after successfully updated, remove from the stack and apply the change to the parent\n        const parentState = stack[stack.length - 2] || rootState\n        const updatedParentState: ModalState = { ...parentState, content: updatedParentContent }\n        stack = [...stack.slice(0, stack.length - 2), updatedParentState]\n        tick().then(scrollToSelection)\n      } else {\n        onPatch(operations)\n\n        onClose()\n      }\n    } catch (err) {\n      error = String(err)\n    }\n  }\n\n  function handleClose() {\n    debug('handleClose')\n\n    if (fullscreen) {\n      // exit fullscreen\n      fullscreen = false\n    } else if (stack.length > 1) {\n      // remove the last item from the stack\n      stack = initial(stack)\n      tick().then(() => {\n        refEditor?.focus()\n        scrollToSelection()\n      })\n\n      // clear any error from the just closed state\n      error = undefined\n    } else {\n      // this is the first modal, the root state, close the modal\n      onClose()\n    }\n  }\n\n  function handleChange(updatedContent: Content) {\n    debug('handleChange', updatedContent)\n    updateState((state) => ({ ...state, content: updatedContent }))\n  }\n\n  function handleChangeSelection(newSelection: JSONEditorSelection | undefined) {\n    debug('handleChangeSelection', newSelection)\n    updateState((state) => ({ ...state, selection: newSelection }))\n  }\n\n  function handleChangeMode(newMode: Mode) {\n    debug('handleChangeMode', newMode)\n    updateState((state) => ({ ...state, mode: newMode }))\n  }\n\n  function updateState(callback: (state: ModalState) => ModalState) {\n    const state = last(stack) as ModalState\n    const updatedState = callback(state)\n    stack = [...initial(stack), updatedState]\n  }\n\n  function handleError(newError: Error) {\n    error = newError.toString()\n    console.error(newError)\n  }\n\n  function handleJSONEditorModal({ content, path }: JSONEditorModalCallback) {\n    debug('handleJSONEditorModal', { content, path })\n\n    const nestedModalState = {\n      mode: determineMode(content),\n      content,\n      selection: undefined,\n      relativePath: path\n    }\n    stack = [...stack, nestedModalState]\n\n    tick().then(() => refEditor?.focus())\n  }\n\n  function focus(element: HTMLElement) {\n    element.focus()\n  }\n</script>\n\n<Modal onClose={handleClose} className=\"jse-jsoneditor-modal\" {fullscreen}>\n  <div class=\"jse-modal-wrapper\">\n    <AbsolutePopup>\n      <Header\n        title=\"Edit nested content {stack.length > 1 ? ` (${stack.length})` : ''}\"\n        fullScreenButton={true}\n        bind:fullscreen\n        onClose={handleClose}\n      />\n\n      <div class=\"jse-modal-contents\">\n        <div class=\"jse-label\">\n          <div class=\"jse-label-inner\">Path</div>\n        </div>\n        <input\n          class=\"jse-path\"\n          type=\"text\"\n          readonly\n          title=\"Selected path\"\n          value={pathDescription}\n        />\n\n        <div class=\"jse-label\">\n          <div class=\"jse-label-inner\">Contents</div>\n        </div>\n\n        <div class=\"jse-modal-inline-editor\">\n          <JSONEditorRoot\n            bind:this={refEditor}\n            externalMode={currentState.mode}\n            content={currentState.content}\n            selection={currentState.selection}\n            {readOnly}\n            {indentation}\n            {tabSize}\n            {statusBar}\n            {askToFormat}\n            {mainMenuBar}\n            {navigationBar}\n            {escapeControlCharacters}\n            {escapeUnicodeCharacters}\n            {flattenColumns}\n            {parser}\n            {parseMemoizeOne}\n            {validator}\n            {validationParser}\n            {pathParser}\n            insideModal={true}\n            onError={handleError}\n            onChange={handleChange}\n            onChangeMode={handleChangeMode}\n            onSelect={handleChangeSelection}\n            {onRenderValue}\n            {onClassName}\n            onFocus={noop}\n            onBlur={noop}\n            {onRenderMenu}\n            {onRenderContextMenu}\n            {onSortModal}\n            {onTransformModal}\n            onJSONEditorModal={handleJSONEditorModal}\n          />\n        </div>\n\n        <div class=\"jse-actions\">\n          {#if error}\n            <div class=\"jse-error\">\n              {error}\n            </div>\n          {/if}\n\n          {#if stack.length > 1}\n            <button type=\"button\" class=\"jse-secondary\" on:click={handleClose}>\n              <Icon data={faCaretLeft} /> Back\n            </button>\n          {/if}\n          {#if !readOnly}\n            <button type=\"button\" class=\"jse-primary\" on:click={handleApply} use:focus>\n              Apply\n            </button>\n          {:else}\n            <button type=\"button\" class=\"jse-primary\" on:click={handleClose}> Close </button>\n          {/if}\n        </div>\n      </div>\n    </AbsolutePopup>\n  </div>\n</Modal>\n\n<style src=\"./JSONEditorModal.scss\"></style>\n","import JsonEditor from './components/JSONEditor.svelte'\nimport type { JSONEditorPropsOptional } from '$lib/types'\nimport { mount, unmount } from 'svelte'\n\n// Note: index.ts exports `JSONEditor`, but we will override this on purpose\n//  since we cannot use it in the vanilla environment starting in Svelte 5.\nexport * from './index'\n\nexport interface CreateJSONEditorProps {\n  target: HTMLDivElement\n  props: JSONEditorPropsOptional\n}\n\nexport { JsonEditor }\n\nexport function createJSONEditor({ target, props }: Parameters<typeof mount>[1]): JsonEditor {\n  const editor = mount(JsonEditor, { target, props })\n\n  editor.destroy = async () => {\n    unmount(editor)\n\n    return new Promise((resolve) => setTimeout(resolve))\n  }\n\n  return editor as JsonEditor\n}\n\n/**\n * @deprecated The constructor \"new JSONEditor(...)\" is deprecated. Please use \"createJSONEditor(...)\" instead.\n */\nexport function JSONEditor({ target, props }: CreateJSONEditorProps) {\n  // TODO: deprecation warning since v1. Remove some day\n  console.warn(\n    'WARNING: the constructor \"new JSONEditor(...)\" is deprecated since v1. ' +\n      'Please use \"createJSONEditor(...)\" instead.'\n  )\n\n  return createJSONEditor({ target, props })\n}\n"],"names":["window","_window","__svelte","v","Set","add","legacy_mode_flag","UNINITIALIZED","Symbol","DEV","BRANCH_EFFECT","BOUNDARY_EFFECT","UNOWNED","DISCONNECTED","CLEAN","DIRTY","MAYBE_DIRTY","INERT","DESTROYED","EFFECT_TRANSPARENT","LEGACY_DERIVED_PROP","EFFECT_HAS_DERIVED","STATE_SYMBOL","LEGACY_PROPS","LOADING_ATTR_SYMBOL","is_array","Array","isArray","index_of","prototype","indexOf","array_from","from","define_property","Object","defineProperty","get_descriptor","getOwnPropertyDescriptor","get_descriptors","getOwnPropertyDescriptors","object_prototype","array_prototype","get_prototype_of","getPrototypeOf","is_function","thing","run","fn","run_all","arr","i","length","is_micro_task_queued","current_queued_micro_tasks","process_micro_tasks","tasks","slice","queue_micro_task","queueMicrotask","push","equals","value","this","safe_not_equal","a","b","not_equal","safe_equals","source","stack","f","reactions","rv","wv","mutable_source","initial_value","_component_context$l","_component_context$l$","immutable","arguments","undefined","s","component_context","l","mutable_state","active_reaction","untracking","derived_sources","push_derived_source","mutate","set","untrack","get","is_runes","DERIVED","includes","Error","e.state_unsafe_mutation","internal_set","increment_write_version","mark_reactions","active_effect","untracked_writes","set_untracked_writes","update","d","result","signal","status","runes","reaction","flags","set_signal_status","schedule_effect","derived","parent_derived","ctx","deps","effects","parent","derived_safe_equal","destroy_derived_effects","destroy_effect","update_derived","prev_active_effect","set_active_effect","get_derived_parent_effect","update_reaction","execute_derived","skip_reaction","$window","is_firefox","first_child_getter","next_sibling_getter","hydrating","proxy","metadata","sources","Map","is_proxied_array","version","Proxy","_","prop","descriptor","configurable","enumerable","writable","e.state_descriptors_fixed","deleteProperty","target","ls","n","Number","isInteger","update_version","receiver","_get_descriptor","exists","Reflect","has","_get_descriptor2","_get_descriptor3","other_s","call","ownKeys","own_keys","filter","key","setPrototypeOf","e.state_prototype_fixed","get_proxied_value","create_text","document","createTextNode","get_first_child","node","get_next_sibling","child","is_text","first_child","fragment","first","Comment","data","sibling","count","next_sibling","FLUSH_MICROTASK","is_throwing_error","scheduler_mode","last_scheduled_effect","is_flushing_effect","is_destroying_effect","set_is_flushing_effect","set_is_destroying_effect","queued_root_effects","flush_count","set_active_reaction","effect","new_deps","skipped_deps","write_version","read_version","captured_signals","check_dirtiness","dependencies","is_unowned","dependency","is_disconnected","is_unowned_connected","_dependency","_dependency2","_dependency2$reaction","handle_error","error","previous_effect","should_rethrow_error","current","_unused","propagate_error","schedule_possible_effect_self_invalidation","root","previous_deps","previous_skipped_deps","previous_untracked_writes","previous_reaction","previous_skip_reaction","prev_derived_sources","previous_component_context","previous_untracking","set_component_context","remove_reactions","_deps$i","_deps$i$reactions","remove_reaction","index","new_length","pop","start_index","update_effect","next","destroy_block_effect_children","destroy_effect_children","execute_effect_teardown","teardown","infinite_loop_guard","e.effect_update_depth_exceeded","flush_queued_root_effects","root_effects","previously_flushing_effect","flush_queued_effects","process_effects","nodes_start","unlink_effect","process_deferred","previous_queued_root_effects","ROOT_EFFECT","current_effect","main_loop","is_branch","is_skippable_branch","previous_active_reaction","parent_sibling","flush_sync","previous_scheduler_mode","tick","_tick","apply","_asyncToGenerator","Promise","resolve","is_derived","e.state_unsafe_local_read","invalidate_inner_signals","captured","previous_captured_signals","capture_signals","dep","STATUS_MASK","deep_read_state","EventTarget","deep_read","visited","Date","getTime","e","proto","descriptors","validate_effect","rune","e.effect_orphan","e.effect_in_unowned_derived","e.effect_in_teardown","create_effect","type","sync","is_root","parent_effect","nodes_end","last","prev","transitions","parent_last","push_effect","_derived$effects","user_effect","m","_context$e","context","legacy_pre_effect","token","ran","r1","render_effect","r2","legacy_pre_effect_reset","template_effect","deriveds","map","block","RENDER_EFFECT","branch","previously_destroying_effect","remove_dom","removed","end","remove","transition","stop","pause_effect","callback","pause_children","run_out_transitions","remaining","check","out","local","is_global","resume_effect","resume_children","in","lifecycle_outside_component","name","getContext","get_or_init_context_map","props","p","c","x","u","component","context_stack_item","component_effects","component_effect","_component_context","_component_context$c","context_map","get_parent_context","DELEGATED_EVENTS","ATTRIBUTE_ALIASES","formnovalidate","ismap","nomodule","playsinline","readonly","defaultvalue","defaultchecked","srcobject","novalidate","allowfullscreen","disablepictureinpicture","disableremoteplayback","PASSIVE_EVENTS","is_passive_event","listening_to_form_reset","without_reactive_context","listen_to_event_and_reset_event","element","event","handler","on_reset","addEventListener","__on_r","evt","then","defaultPrevented","elements","_e$__on_r","capture","all_registered_events","root_event_handles","create_event","event_name","dom","options","target_handler","handle_event_propagation","cancelBubble","startsWith","passive","body","removeEventListener","_event$composedPath","handler_element","owner_document","ownerDocument","path","composedPath","current_target","path_idx","handled_at","__root","at_idx","handler_idx","throw_error","other_errors","parent_element","assignedSlot","parentNode","host","delegated","_loop","currentTarget","create_fragment_from_html","html","elem","createElement","innerHTML","content","assign_nodes","start","template","is_fragment","use_import_node","has_start","clone","importNode","cloneNode","lastChild","ns_template","ns","wrapped","concat","createDocumentFragment","appendChild","text","t","comment","frag","createComment","anchor","append","before","set_text","_text$__t","str","__t","nodeValue","mount","Component","_ref2","events","intro","test","navigator","userAgent","element_prototype","Element","node_prototype","Node","__click","__className","__attributes","__styles","__e","Text","init_operations","registered_events","event_handle","document_listeners","unmount","fulfil","outro","component_root","anchor_node","$$events","delete","_anchor_node$parentNo","removeChild","mounted_components","_mount","WeakMap","if_block","consequent_effect","alternate_effect","condition","has_branch","set_branch","update_branch","new_condition","key_block","get_key","render_fn","changed","each","get_collection","fallback_fn","state","items","fallback","was_empty","each_array","collection","array","seen","to_animate","item","is_animated","should_update","matched","stashed","_item$a","measure","_item$a2","update_item","unfix","j","move","link","k","create_item","to_destroy","destroy_length","controlled_anchor","_to_destroy$i$a","_to_destroy$i$a2","fix","items_map","is_controlled","parent_node","textContent","clear","pause_effects","_item$a3","reconcile","dest","next_node","get_value","svg","mathml","skip_warning","_get_value","slot","$$props","slot_props","_$$props$$$slots","slot_fn","$$slots","is_interop","get_component","action","payload","inited","destroy","r","o","clsx","_clsx","set_value","_element$__attributes","attributes","nodeName","set_attribute","attribute","_element$__attributes2","removeAttribute","get_setters","setAttribute","set_attributes","css_hash","_element$__attributes3","preserve_attribute_case","is_custom_element","is_option_element","tagName","class","prev_value","prefix","is_default","setters","_loop2","_key2","__value","opts","event_handle_key","is_delegated","endsWith","is_capture_event","delegate","handle","style","cssText","autofocus","activeElement","focus","Boolean","selected","hasAttribute","set_selected","_ATTRIBUTE_ALIASES$na","toLowerCase","normalize_attribute","input","use_default","previous","defaultValue","defaultChecked","checked","setters_cache","element_proto","set_class","hash","prev_class_name","next_class_name","to_class","className","toggle_class","class_name","classList","contains","set_style","important","_dom$__styles","styles","removeProperty","setProperty","bind_value","is_reset","is_numberlike_input","to_number","selectionStart","selectionEnd","Math","min","bind_prop","desc","select_option","select","mounting","multiple","option","get_option_value","select_options","option_value","is","selectedIndex","bind_select_value","query","querySelectorAll","_select$querySelector","selected_option","querySelector","observer","MutationObserver","observe","childList","subtree","attributeFilter","disconnect","init_select","is_bound_this","bound_value","element_or_component","bind_this","old_parts","parts","stopPropagation","_len2","args","_key4","preventDefault","_len3","_key5","init","callbacks","observe_all","fns","reactive_import","bubble_event","_$$props$$$events","onMount","init_update_callbacks","cleanup","onDestroy","createEventDispatcher","active_component_context","detail","_active_component_con","bubbles","cancelable","CustomEvent","create_custom_event","beforeUpdate","e.lifecycle_legacy_only","_l$u","is_store_binding","legacy_rest_props_handler","exclude","special","legacy_rest_props","spread_props_handler","keys","spread_props","_len4","_key6","_get_descriptor$set","_get_descriptor4","prop_value","bindable","lazy","is_store_sub","previous_is_store_binding","capture_store_binding","getter","is_entry_props","setter","fallback_value","fallback_dirty","fallback_used","get_fallback","e.props_invalid_value","derived_getter","legacy_parent","$$legacy","mutation","from_child","was_from_child","inner_current_value","current_value","parent_value","child_value","new_value","createDebug","namespace","enabled","debug","localStorage","_unused2","tryReadLocalStorage","enableDebug","noop","color","charCodeAt","colors","abs","selectColor","_len5","_key7","console","log","id","uniqueId","int","parseInt","containsNumber","NUMBER_REGEX","isObject","constructor","isObjectOrArray","isBoolean","isTimestamp","isFinite","floor","isNaN","valueOf","_unused3","getColorCSS","colorTestDiv","applied","replace","isColor","valueType","parser","valueStr","stringify","isUrlRegex","isUrl","stringConvert","strTrim","trim","parse","INTEGER_REGEX","ROOT_PATH","strictShallowEqual","getNestedPaths","includeObjects","pointersMap","TypeError","recurseNestedPaths","obj","compileJSONPointer","forEach","max","sort","parseJSONPointer","forEachIndex","iteratee","limit","arrayToObject","_objectSpread","objectToArray","object","values","moveItems","offset","copy","moving","splice","insertItemsAt","parseAndRepair","jsonText","_unused4","jsonrepair","parseAndRepairOrUndefined","partialJson","_unused5","parsePartialJson","END_WITH_COMMA_AND_OPTIONAL_WHITESPACES_REGEX","_unused6","_unused7","_unused8","repairPartialJson","_unused9","repaired","substring","_unused10","_unused11","normalizeJsonParseError","parseErrorMessage","positionMatch","POSITION_REGEX","exec","position","line","character","charAt","countCharacterOccurrences","column","lastIndexOf","message","lineMatch","LINE_REGEX","lineOneBased","columnMatch","COLUMN_REGEX","columnOneBased","calculatePosition","validateContentType","json","isContent","isTextContent","isJSONContent","toTextContent","indentation","JSON","toJSONContent","getText","isLargeContent","maxSize","estimateSerializedSize","Infinity","estimatedSize","recurse","String","isEqualParser","Mode","SelectionType","CaretType","ValidationSeverity","SearchField","SortDirection","UpdateSelectionAfterChange","DELIMITER_WITHOUT_SPACING_REGEX","createNormalizationFunctions","_ref3","escapeControlCharacters","escapeUnicodeCharacters","normalizeControlAndUnicode","normalizeControl","normalizeUnicode","normalizeNothing","escapeValue","jsonEscapeUnicode","jsonEscapeControl","unescapeValue","jsonUnescapeControl","jsonUnescapeUnicode","_x$codePointAt","codePointAt","toString","unescaped","controlCharacters","_unused14","escapedControlCharacters","addNewLineSuffix","isChildOfNodeName","isChildOf","toUpperCase","isChildOfAttribute","getAttribute","predicate","findParent","getWindow","_element$ownerDocumen","_element$ownerDocumen2","defaultView","activeElementIsChildOf","findParentWithNodeName","getSelectionTypeFromTarget","inside","after","multi","encodeDataPath","encodeURIComponent","getDataPathFromTarget","_parent$getAttribute","dataPath","decodeURIComponent","findNearestElement","_ref4","allElements","currentElement","direction","hasPrio","margin","all","rect","getBoundingClientRect","width","height","calculateCenter","left","y","top","distance","weightY","diffX","diffY","sqrt","distanceToCurrent","candidate","candidatesLeft","button","isLeft","isRight","right","candidatesLeftOnRow","isOnSameRow","nearest","minBy","candidates","isAbove","isBelow","prioCandidates","isMacDevice","_ref5","_navigator$platform$t","_navigator","_navigator2","platform","userAgentData","keyComboFromEvent","separator","combi","isCtrlKeyDown","altKey","shiftKey","keyName","metaKeys","join","isMac","ctrlKey","metaKey","Ctrl","Command","Control","Alt","Option","Shift","styleInject","css","ref","insertAt","head","getElementsByTagName","firstChild","insertBefore","styleSheet","popup","$.prop","closeAbsolutePopup","refRootPopup","$.mutable_state","refHiddenInput","closeWhenOutside","closeOnOuterClick","$.get","handleKeyDown","$.bind_this","$$value","$.set","$.component","$$anchor","$$component","$.spread_props","rootRect","positionAbove","positionLeft","offsetTop","offsetLeft","bottom","innerHeight","innerWidth","calculateStyle","$$render","consequent","div","popups","popupId","popupIndex","findIndex","onClose","openAbsolutePopup","$.each","findUniqueName","keysSet","nameWithoutCopySuffix","validName","truncate","maxLength","maxTextLength","ellipsis","parseString","lower","num","numFloat","parseFloat","jsonQueryLanguage","_json","queryOptions","projection","queryFunctions","relation","operator","paths","executeQuery","jsonquery","cursor","raw","getRaw","rawData","ids","match","rawId","pointerId","iconData","scale","spin","inverse","pulse","flip","label","combinedStyle","box","normalisedScale","numScale","warn","calculateRatio","iconName","icon","normaliseData","combined","size","_className","$$restProps","$.toggle_class","_get2","$.index","_get3","polygons","polygon","_get4","readOnly","onPatch","expression","$.derived_safe_equal","faCheckSquare","faSquare","$.set_attribute","op","onChange","showOnTop","destroyColorPicker","_yield$import","colorPicker","import","default","onDone","hex","rgba","show","title","_get5","_getWindow$1$innerHei","_getWindow$","ColorPickerPopup","MAX_SEARCH_RESULTS","ARRAY_SECTION_SIZE","MAX_CHARACTERS_TEXT_PREVIEW","DEFAULT_VISIBLE_SECTIONS","MAX_AUTO_REPAIRABLE_SIZE","MAX_DOCUMENT_SIZE_TEXT_MODE","INSERT_EXPLANATION","CONTEXT_MENU_EXPLANATION","HOVER_INSERT_INSIDE","HOVER_INSERT_AFTER","HOVER_COLLECTION","JSON_STATUS_VALID","JSON_STATUS_REPAIRABLE","CONTEXT_MENU_HEIGHT","CONTEXT_MENU_WIDTH","SEARCH_BOX_HEIGHT","SORT_DIRECTION_NAMES","asc","mergeSections","sections","sortedSections","sortBy","section","mergedSections","sortedIndex","mergedIndex","nextRoundNumber","currentRoundNumber","isMenuSpace","isMenuSeparator","isMenuLabel","isMenuButton","isMenuDropDownButton","isContextMenuRow","isContextMenuColumn","isContentParseError","contentErrors","isContentValidationErrors","isValidationError","isNestedValidationError","isChildError","isSvelteComponentRenderer","isSvelteActionRenderer","isObjectRecursiveState","isArrayRecursiveState","isValueRecursiveState","isExpandableState","hasSearchResults","searchResults","isTreeHistoryItem","historyItem","isTextHistoryItem","isModeHistoryItem","createDocumentState","_ref8","expand","documentState","_ref7","factory","createArrayDocumentState","createObjectDocumentState","createValueDocumentState","createRecursiveState","documentStateFactory","expandPath","expanded","visibleSections","properties","ensureRecursiveState","_ref9","arrayState","itemState","setIn","objectState","syncDocumentState","_transformDocumentState","nestedJson","nestedState","updatedState","forEachVisibleIndex","itemPath","updatedItem","propPath","updatedProp","jsonArray","_ref10","toRecursiveStatePath","recursiveStatePath","partialPath","updateInDocumentState","some","inVisibleSection","newVisibleSection","expandVisibleSection","_loop3","nestedValue","nestedPath","_expandRecursively","collapsePath","recursive","_collapse","_collapseRecursively","documentStatePatch","operations","initial","reduce","operation","immutableJSONPatch","_documentStatePatch","isJSONPatchAdd","documentStateAdd","isJSONPatchRemove","documentStateRemove","isJSONPatchReplace","parsePath","enforceString","getEnforceString","setInDocumentState","isJSONPatchCopy","isJSONPatchMove","stateValue","getInRecursiveState","documentStateMoveOrCopy","getIn","_unused15","updateInRecursiveState","transform","ensuredState","updateIn","recursiveState","setInRecursiveState","_parent","shiftVisibleSections","parentPath","recursivePath","existsIn","deleteIn","deleteInDocumentState","merged","mergeAdjacentSections","getNextKeys","includeKey","getVisiblePaths","_recurse","isJSONArray","isJSONObject","getVisibleCaretPositions","includeInside","valueState","propertyPath","getNextVisiblePath","visiblePaths","expandSmart","expandMinimal","expandAll","expandSmartIfCollapsed","relativePath","expandSelf","expandNone","isAfterSelection","selection","isInsideSelection","isKeySelection","isValueSelection","isMultiSelection","isMultiSelectionWithOneItem","isEqual","focusPath","anchorPath","isJSONSelection","isTextSelection","getSelectionPaths","getAnchorPath","getFocusPath","sharedPath","findSharedPath","createMultiSelection","startPath","getStartPath","endPath","getEndPath","startIndex","getChildIndex","endIndex","iterateOverSelection","getParentPath","anchorIndex","getSelectionUp","keepAnchorPath","previousPath","visiblePathPointers","pathPointer","getPreviousVisiblePath","createValueSelection","isEmpty","createKeySelection","findCaretAndSiblings","caret","visibleCaretPositions","getInitialSelection","createSelectionFromOperations","every","firstOp","otherOps","path1","path2","singleItemSelected","findRootPath","pathStartsWith","removeEditModeFromSelection","isEditingSelection","createEditKeySelection","initialValue","edit","createEditValueSelection","createInsideSelection","createAfterSelection","isParent","selectionToPartialJson","hasSelectionContents","canConvert","fromCaretPosition","caretPosition","fromSelectionType","selectionType","selectionIfOverlapping","pathInSelection","pathIndex","classnames","classes","_len6","_key8","arg","hasOwnProperty","getValueClass","mode","table","shortText","onCancel","onFind","onPaste","onValueClass","domValue","valueClass","closed","getDomValue","removeNewLineSuffix","innerText","setDomValue","updatedValue","$.mutate","range","createRange","getSelection","setStart","collapse","removeAllRanges","addRange","setCursorToEnd","newValue","no","combo","nextInside","clipboardData","clipboardText","getData","hasFocus","self","normalization","onPasteJson","onSelect","findNextInside","convert","handleCancelChange","expression_1","updateSelection","patchedState","patchedSelection","pastedText","pastedJson","contents","onPasteAsJson","patchedJson","_unused16","entry","afterKey","nextKeys","newProp","moveDown","rename","oldKey","newKey","newKeyUnique","duplicate","lastPath","beforeKey","insert","clipboard","_unused17","newValues","clipboardToValues","firstPath","removeAll","removeKeys","filteredKeys","nextKey","firstKey","reverse","textIsObject","textIsArray","clipboardOriginal","clipboardRepaired","createRemoveOperations","newSelection","previousKey","revertJSONPatchWithMoveOperations","comparator","dedupeKeepLast","revertJSONPatch","revertOperations","createRevertMoveOperations","searchNext","searchResult","nextActiveIndex","activeIndex","nextActiveItem","active","activeItem","search","searchText","_options$maxResults","searchTextLowerCase","maxResults","columns","results","onMatch","searchRecursive","level","findCaseInsensitiveMatches","field","textLower","fieldIndex","replaceText","replacementText","replaceAllText","occurrences","updatedText","forEachRight","occurrence","createSearchAndReplaceOperations","searchResultItem","currentValue","currentValueText","getSearchResultPath","searchResultsFactory","toRecursiveSearchResults","searchResultItems","updateInSearchResults","flattenSearchResults","_node$searchResults","nested","flatMap","matches","previousEnd","precedingText","matchingText","lastMatch","splitValue","part","$.template_effect","$.set_text","text_1","span","alternate","valueIsUrl","open","tooltip","_ref11","handleMouseEnter","Tooltip","handleMouseLeave","absolutePopupContext","faClock","renderValue","renderers","isEditing","BooleanToggle","ColorPicker","EditableValue","ReadonlyValue","TimestampTag","stringifyJSONPath","integerNumberRegex","escapeQuotes","parseJSONPath","pathStr","parseProp","eatCharacter","isEnd","unescape","char","SyntaxError","pathToOption","stringifyLodashProperty","javaScriptPropertyRegex","propStr","createPropertySelector","transformModalStates","transformModalStateShared","showWizard","showOriginal","round","createCoords","oppositeSideMap","oppositeAlignmentMap","clamp","evaluate","param","getSide","placement","split","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getOppositeAlignmentPlacement","alignment","getOppositePlacement","side","getPaddingObject","padding","expandPaddingObject","rectToClientRect","computeCoordsFromPlacement","_ref","rtl","coords","reference","floating","sideAxis","alignmentAxis","alignLength","isVertical","commonX","commonY","commonAlign","computePosition","_ref12","config","strategy","middleware","validMiddleware","isRTL","rects","getElementRects","statefulPlacement","middlewareData","resetCount","nextX","nextY","reset","initialPlacement","_x","_x2","_x3","detectOverflow","_x4","_x5","_detectOverflow","_await$platform$isEle","boundary","rootBoundary","elementContext","altBoundary","paddingObject","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","_convertValueToCoords","mainAxisMulti","crossAxisMulti","rawValue","mainAxis","crossAxis","hasWindow","getNodeName","isNode","_node$ownerDocument","documentElement","isHTMLElement","HTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","overflow","overflowX","overflowY","display","getComputedStyle","isTableElement","isTopLayer","selector","isContainingBlock","elementOrCss","webkit","isWebKit","containerType","backdropFilter","willChange","contain","CSS","supports","isLastTraversableNode","getNodeScroll","scrollLeft","scrollTop","scrollX","scrollY","getParentNode","getNearestOverflowAncestor","getOverflowAncestors","list","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","frameElement","getFrameElement","visualViewport","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","noOffsets","getVisualOffsets","includeScale","isFixedStrategy","clientRect","visualOffsets","isFixed","floatingOffsetParent","shouldAddVisualOffsets","offsetWin","currentWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","getWindowScrollBarX","leftScroll","getHTMLOffset","scroll","ignoreScrollbarX","htmlRect","getClientRectFromClippingAncestor","clippingAncestor","clientWidth","clientHeight","visualViewportBased","getViewportRect","scrollWidth","scrollHeight","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsets","offsetRect","htmlOffset","isStaticPositioned","getTrueOffsetParent","polyfill","rawOffsetParent","svgOffsetParent","currentNode","getContainingBlock","topLayer","clippingAncestors","cache","cachedResult","el","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","getClippingElementAncestors","_c","firstClippingAncestor","clippingRect","accRect","_ref13","getOffsetParentFn","getDimensionsFn","getDimensions","floatingDimensions","_x8","getClientRects","rectsAreEqual","autoUpdate","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","frameId","cleanupIo","onMove","timeoutId","io","_io","clearTimeout","refresh","skip","threshold","elementRectForRootMargin","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","setTimeout","observeMove","reobserveFrame","resizeObserver","firstEntry","unobserve","cancelAnimationFrame","requestAnimationFrame","_resizeObserver","prevRefRect","frameLoop","nextRefRect","_resizeObserver2","_middlewareData$offse","_middlewareData$arrow","diffCoords","_x6","_x7","convertValueToCoords","arrow","alignmentOffset","shift","_evaluate2","checkMainAxis","checkCrossAxis","limiter","detectOverflowOptions","_objectWithoutProperties","_excluded2","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","_middlewareData$flip","_evaluate","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","_excluded","initialSideAxis","isBasePlacement","oppositePlacement","getExpandedPlacements","hasFallbackAxisSideDirection","isStart","lr","rl","getSideList","getOppositeAxisPlacements","placements","overflows","overflowsData","sides","mainAlignmentSide","getAlignmentSides","_middlewareData$flip2","_overflowsData$filter","nextIndex","nextPlacement","resetPlacement","_overflowsData$filter2","currentSideAxis","acc","createFloatingActions","initOptions","referenceElement","floatingElement","defaultOptions","getOptions","mixin","updatePosition","updateOptions","mergedOptions","platformWithCache","computePosition$1","_options","assign","onComputed","setupVirtualElementObserver","subscribe","$node","contentAction","contentOptions","autoUpdateDestroy","destroyAutoUpdate","initAutoUpdate","_autoUpdate","_ref14","loadOptions","filterText","itemId","groupBy","filterSelectedItems","itemFilter","convertStringItemsToObjects","filterGroupedItems","filterResults","matchesFilter","getItems","_x9","_getItems","_ref15","dispatch","res","catch","err","details","cancelled","filteredItems","loading","focused","listOpen","sanitized","children","timeout","justValue","_filter","container","multiFullItemClearable","disabled","placeholder","placeholderAlwaysShow","groupFilter","groups","groupHeaderSelectable","containerStyles","hasError","required","closeListOnChange","clearFilterTextOnBlur","createGroupHeaderItem","groupValue","getFilteredItems","searchable","inputStyles","clearable","debounce","wait","debounceWait","hideEmptyState","inputAttributes","listAutoWidth","showChevron","listOffset","hoverItemIndex","floatingConfig","containerClasses","activeValue","prev_filterText","prev_multiple","_inputAttributes","_items","groupValues","groupHeader","selectable","groupItem","sortedGroupedItems","checkHoverSelectable","startingIndex","ignoreGroup","setHoverIndex","checkValueForDuplicates","noDuplicates","uniqueValues","val","findItem","matchTo","find","handleMultiItemClear","_x10","_handleMultiItemClear","itemToRemove","closeList","hoverItem","handleSelect","handleFocus","_document","_input","handleBlur","_x11","_handleBlur","_input2","isScrolling","blur","handleClick","handleClear","ariaValues","ariaListOpen","ariaFocused","isScrollingTimer","handleListScroll","_get7","itemSelected","handleHover","increment","hasOwn","hover","isItemActive","activeScroll","scrollAction","hoverScroll","scrollIntoView","behavior","_floatingConfig","floatingRef","floatingContent","floatingUpdate","prefloat","setValue","autocapitalize","autocomplete","autocorrect","spellcheck","tabindex","hasValue","hideSelectedItem","showClear","placeholderText","_value5","_multiple","ariaSelection","ariaContext","_item","handleAriaContent","updateValueDisplay","handleFilterEvent","listDom","listMounted","setListWidth","scrollToHoverItem","_floatingConfig2","_get6","_get8","div_3","_get9","$.event","div_2","$.stopPropagation","isItemSelectable","handleItemClick","consequent_3","consequent_2","consequent_1","alternate_1","consequent_4","div_1","consequent_5","consequent_6","text_3","div_8","$.preventDefault","ClearIcon","consequent_7","div_7","text_4","consequent_8","alternate_2","consequent_9","input_1","consequent_10","consequent_11","consequent_12","consequent_13","_containerClasses","filterRelationOptions","sortDirectionOptions","filterPath","_queryOptions","filterRelation","_queryOptions$filter","_filterRelationOption","filterValue","_queryOptions2","sortPath","_queryOptions3","sortDirection","_sortDirectionOptions","_queryOptions$sort","jsonIsArray","pathsIncludingObjects","fieldOptions","projectionOptions","projectionPaths","_queryOptions10","_queryOptions4","_get10","_queryOptions5","_get11","_queryOptions6","_queryOptions7","_get12","_queryOptions8","_get13","_queryOptions9","changeProjectionPaths","$.bind_value","queryLanguages","queryLanguageId","onChangeQueryLanguage","queryLanguage","_get$name","handleChangeQueryLanguage","newQueryLanguageId","fullScreenButton","fullscreen","faDownLeftAndUpRightToCenter","faUpRightAndDownLeftFromCenter","faTimes","_onClose","createAutoScrollHandler","scrollableElement","autoScrollSpeed","autoScrollTimer","calculateSpeed","diff","autoScrollCallback","startAutoScroll","speed","stopAutoScroll","setInterval","clearInterval","onDrag","clientY","onDragEnd","easeInOutQuad","createJump","easing","a11y","duration","timeStart","timeElapsed","scrolling","scrollTo","loop","timeCurrent","done","onDuration","now","validationErrorsFactory","updateInValidationErrors","errors","validateJSON","validator","validationParser","validateText","validationErrors","severity","info","convertedJSON","isRepairable","_unused18","canAutoRepair","parseError","createFocusTracker","_ref18","blurTimeoutHandle","onFocus","onBlur","handleFocusIn","newFocus","handleFocusOut","actions","onClick","_get$text","onMouseDown","_type","_message","selectError","node_2","validationError","faExclamationTriangle","faAngleDown","$.set_class","tr","_get$severity","_ref19","text_2","faAngleRight","_get14","getMaxSeverity","warning","onEscape","dialog","close","showModal","dialog_1","_len","_key3","ctrl","_onClose2","$$args","node_1","_get$className","_get$onClick","$0","unknownMenuItem","onParse","onRepair","onApply","domTextArea","goToError","setSelectionRange","handleApply","handleRepair","_unused20","getErrorMessage","repairable","_unused19","gotoAction","faArrowDown","repairAction","faWrench","errorActions","successActions","faCheck","textarea","repairedText","handleCancel","sectionIndex","total","onExpandSection","visibleSection","getJson","expandItemsSections","section1","start2","section2","currentIndex","previousIndex","section3","showSection2","getExpandItemsSections","expandItemsSection","_get$start","_get$end","_get15","_get16","onContextMenu","faCaretDown","buttonElem","showTip","onRenderValue","renderer","$.action","$$node","$$action_arg","_get17","singleton","selecting","selectionAnchor","selectionAnchorType","selectionFocus","dragging","onMoveSelection","_ref20","deltaY","updatedSelection","dragInsideAction","_ref21","initialPath","initialIndex","prevHeight","_items2","cumulativeHeight","beforePath","findSwapPathUp","_ref22","_items$beforeIndex","nextHeight","_items3","beforeIndex","findSwapPathDown","startKey","endKey","toKey","toIndex","times","moveInsideParent","_ref23","_items4","_items5","createUpdatedArraySelection","onExpand","_onExpand","_validationError$seve","pointer","onDragSelectionStart","hoverTimer","isNodeSelected","toggleExpand","handleExpand","handleUpdateKey","handleMouseMoveGlobal","handleMouseUpGlobal","$$_import_singleton","findContentTop","_context$findElement","findElement","calculateDeltaY","contentOffset","initialContentTop","initialClientY","handleDragSelectionStart","selectionParentPath","addHeight","currentSection","getVisibleItemsWithHeights","selectionStartIndex","initialTarget","selectionItemsCount","didMoveItems","handleDragSelection","handleDragSelectionEnd","handleInsertInside","handleInsertAfter","handleInsertInsideOpenContextMenu","contextMenuProps","handleInsertAfterOpenContextMenu","_validationErrors","faCaretRight","_value$length","_ref24","_value$length2","_ref25","div_10","node_13","indices","gutterIndex","nestedValidationErrors","nestedSelection","appendToJSONPointer","expression_4","alternate_3","alternate_4","consequent_14","consequent_15","consequent_17","consequent_16","alternate_5","div_25","consequent_18","getKeys","propPointer","nestedSearchResults","expression_7","filterKeySearchResults","filtered","onUpdateKey","handleKeyDoubleClick","isEditingKey","handleChangeValue","updatedKey","updatedPath","isKeySelected","expression_2","consequent_19","consequent_20","consequent_22","expression_9","filterValueSearchResults","consequent_23","consequent_24","consequent_25","consequent_21","alternate_6","alternate_7","div_35","consequent_26","$.set_style","onClassName","buttons","contentEditable","anchorType","getDocumentState","fullSelection","lastCaretPosition","empty","faJSONEditorExpand","faJSONEditorCollapse","faJSONEditorFormat","faJSONEditorCompact","caseInsensitiveNaturalCompare","aLower","bLower","naturalCompare","sortJson","rootPath","valueA","valueB","createObjectComparator","sortArray","sortedKeys","keyA","keyB","sortedObject","sortObjectKeys","selectedItem","refNavigationBarItem","handleSelectItem","button_1","NavigationBarDropdown","copyToClipBoard","_document$queryComman","_document2","writeText","queryCommandSupported","opacity","execCommand","pathParser","onError","pathExists","inputRef","inputPath","validationActive","copiedTimer","copied","parseAndValidate","validatePathExists","inputValidationError","faCopy","refNavigationBar","editing","handleCloseEditor","handleChangePath","hasNextItem","faClose","faEdit","showSearch","showReplace","onSearch","appliedText","searching","applyChangedSearchTextDebounced","_x13","_applyChangedSearchText","applyChangedJsonDebounced","_x14","_applyChangedJson","toggleShowReplace","flush","handleNext","handlePrevious","handleReplace","handleClose","handleReplaceKeyDown","handlePaste","_handlePaste","_handleReplace","_get21","handleReplaceAll","_handleReplaceAll","deduplicatedMatches","previousItem","lastNewSelection","allOperations","createSearchAndReplaceAllOperations","initSearchInput","_handleNext","_handlePrevious","previousActiveIndex","previousActiveItem","searchPrevious","_handleFocus","_get22","_applyChangedShowSearch","applySearch","_x15","_x16","_x17","_applySearch","newResultItems","previousResult","activePath","matchingActiveIndex","updateSearchResult","cancel","resultCount","_get18","_get19","formattedResultCount","_x12","applyChangedShowSearch","faCircleNotch","faSearch","$.effect","faChevronDown","faChevronUp","div_4","_ref26","_get20","endOfPath","getColumns","flatten","maxSampleCount","step","forEachSample","_recurseObject","_collectPaths","valueMerged","calculateVisibleSection","viewPortHeight","itemHeights","defaultItemHeight","searchBoxOffset","itemCount","averageItemHeight","calculateAverageItemHeight","viewPortTop","viewPortBottom","getItemHeight","startHeight","visibleHeight","endHeight","visibleItems","calculateAbsolutePosition","rowIndex","toTableCellPosition","columnIndex","fromTableCellPosition","groupValidationErrors","arrayErrors","rootErrors","partition","errorsByRow","findRowIndex","groupedErrorsByRow","mapValues","groupByRow","row","findColumnIndex","rows","mergeValidationErrors","clearSortedColumnWhenAffectedByOperations","sortedColumn","columms","mustBeCleared","selectedColumnIndex","operationAffectsSortedColumn","findNestedArrays","maxLevel","onCut","_x18","_onCut","_ref27","copyToClipboard","onCopy","_x19","_onCopy","_ref28","_ref29","onChangeText","openRepairModal","doPaste","_unused21","ensureSelection","onRemove","_ref30","keepSelection","removeSelection","patchResult","onInsert","_ref35","insertType","selectInside","onReplaceJson","jsonExample","cloneDeepWith","createNewValue","onInsertCharacter","_x20","_onInsertCharacter","_ref36","_x21","_onInsertValueWithCharacter","onInsertValueWithCharacter","_ref37","truncated","onRequestClose","visible","allItemsDisabled","$.clsx","_get$text2","_width3","wasVisible","main","_item$main$text","tip","refContextMenu","firstEnabledButton","directionByCombo","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","rowItem","columnItem","alternate_8","alternate_9","alternate_10","alternate_11","faLightbulb","refSelect","bindValue","applyFocus","option_1_value","option_1","$.bind_select_value","getJSONSchemaOptions","schema","schemaDefinitions","schemaForPath","findSchema","composite","enum","findEnum","topLevelSchema","currentSchema","nextPath","possibleSchemas","subSchemas","oneOf","anyOf","allOf","$ref","_ref$match","schemaUrl","referencedSchema","auxNextPath","refPath","segment","patternProperties","additionalProperties","renderJSONSchemaEnum","enumValues","enumValue","optionsWithValue","EnumValue","createAjvValidator","ajv","ajvOptions","AjvDist","allErrors","verbose","$data","addSchema","createAjvInstance","onCreateAjv","validateAjv","compile","improveAjvError","ajvError","instancePath","normalizeAjvError","keyword","enums","more","params","additionalProperty","jmespathQueryLanguage","description","examplePath","exampleValue","filterValueStr","stringifyPathForJmespath","stringifyProp","preprocessedJson","stringifyAndParse","jmespath","jsonpathQueryLanguage","pathToString","output","JSONPathPlus","lettersOnlyRegex","lodashQueryLanguage","queryParts","actualValueGetter","isSafeInteger","createLodashPropertySelector","_query$match","_query$match2","chainCount","valueCount","validate","Function","queryFn","javascriptQueryLanguage","createQuery","onResize","isSSR","sortModalId","transformModalId","refContents","refJsonEditor","jump","externalContent","externalSelection","history","mainMenuBar","navigationBar","parseMemoizeOne","onChangeMode","onUndo","onRedo","onRenderMenu","onRenderContextMenu","onSortModal","onTransformModal","onJSONEditorModal","modalOpen","copyPasteModalOpen","jsonRepairModalProps","documentStateInitialized","searchResultDetails","handleSearch","handleFocusSearch","_x22","_handleFocusSearch","handleCloseSearch","handleSelectValidationError","isSelectionInsidePath","textIsRepaired","validationErrorList","memoizedValidate","memoizeOne","updateValidationErrors","newValidationErrorList","toRecursiveValidationErrors","applyExternalContent","updatedContent","updatedJson","isChanged","currentlyText","previousState","expandWhenNotInitialized","clearSelectionWhenNotExisting","addHistoryItem","applyExternalJson","_unused22","applyExternalText","canPatch","undo","patch","redo","afterPatch","_createSelectionFromO","previousJson","patched","handleEditKey","handleEditValue","openJSONEditorModal","handleToggleEnforceString","handlePatch","acceptAutoRepair","handleReplaceJson","handleCut","_handleCut","indent","handleCopy","_handleCopy","_event$clipboardData","_paste","handlePasteFromMenu","_handlePasteFromMenu","readText","handleChangeText","handleRemove","handleDuplicate","handleExtract","extract","handleInsert","handleInsertFromContextMenu","handleConvert","convertedValue","parsedValue","_unused12","_unused13","convertValue","handleInsertBefore","selectionBefore","handleContextMenu","handleInsertCharacter","_x23","_handleInsertCharacter","handleUndo","canUndo","previousContent","emitOnChange","handleRedo","canRedo","openSortModal","_onSort","onSort","_ref39","_x24","handleSortSelection","handleSortAll","openTransformModal","onTransform","transformedJson","handleTransformSelection","handleTransformAll","_x25","_scrollTo","scrollToWhenVisible","viewPortRect","elemRect","_get$querySelector","_get23","elemHeight","_onChange","_onChange2","_unused23","handleExpandAll","handleCollapseAll","openFind","findAndReplace","handleExpandSection","_value","expandSection","handlePasteJson","newPastedJson","openContextMenu","_ref40","_onRenderContextMenu","defaultItems","_ref38","onEditKey","onEditValue","onToggleEnforceString","onDuplicate","onExtract","onInsertBefore","onConvert","onInsertAfter","hasJson","hasSelection","rootSelected","focusValue","editValueText","canEditKey","canEditValue","canEnforceString","canCut","canCopy","canPaste","canDuplicate","canExtract","convertMode","insertOrConvertText","canInsertOrConvertStructure","canInsertOrConvertObject","canInsertOrConvertArray","canInsertOrConvertValue","handleInsertOrConvert","faPen","faCut","faPaste","faClone","faCropAlt","faSortAmountDownAlt","faFilter","faTrashCan","faArrowRightArrowLeft","faPlus","faCaretSquareUp","faCaretSquareDown","createTreeContextMenuItems","ContextMenu","clientX","_get24","_get25","handleContextMenuFromTreeMenu","handleParsePastedJson","_handleParsePastedJson","handleClearPastedJson","handleRequestRepair","handleNavigationBarSelect","childPath","nextPathInside","getSelectionNextInside","handleDrag","autoScrollHandler","handleDragEnd","overflowAnchor","applySearchBoxSpacing","applyExternalSelection","tree","onExpandAll","onCollapseAll","handleToggleSearch","expandMenuItem","collapseMenuItem","searchMenuItem","faEllipsisV","faUndo","faRedo","onCreateArray","onCreateObject","faCode","_get26","collapsedState","nextPathAfter","getSelectionDown","getSelectionLeft","getSelectionRight","isContentEditable","readonlyProxy","property","createHistoryInstance","maxItems","reverseItems","handleChange","refQueryInput","updatedHistory","selectedJson","selectedContent","stateId","_$$_import_transformM","$$_import_transformModalStateShared","_state$queryOptions","isManual","_state$isManual","queryError","previewError","previewContent","getSelectedQueryLanguage","_queryLanguages$find","updateQueryByWizard","newQueryOptions","handleChangeQuery","_get27","previewTransformDebounced","previewJson","jsonTransformed","handleTransform","toggleShowWizard","toggleShowOriginal","handleEscape","refConfigButton","openConfig","SelectQueryLanguage","faCog","formatSize","kilo","toFixed","KB","MB","GB","highlightStyle","HighlightStyle","define","tag","tags","propertyName","number","bool","string","highlighter","syntaxHighlighting","originalStyle","wrappedLineIndent","ViewPlugin","fromClass","view","indentUnit","getIndentUnit","initialPaddingLeft","isChrome","generate","docChanged","viewportChanged","builder","RangeSetBuilder","addStyleToBuilder","requestMeasure","read","lineElement","contentDOM","getPropertyValue","decorations","finish","visibleLines","getVisibleLines","numColumns","containsTab","tabSize","paddingValue","textIndentValue","Decoration","lines","lastLine","to","visibleRanges","pos","doc","lineAt","cols","statusBar","askToFormat","formatCompactKeyBinding","handleFormat","handleCompact","codeMirrorView","codeMirrorRef","domTextMode","editorState","acceptTooLarge","askToFormatApplied","linterCompartment","Compartment","readOnlyCompartment","indentCompartment","tabSizeCompartment","themeCompartment","historyAnnotation","Annotation","historyUpdatesQueue","startState","endState","mergedChanges","changes","change","compose","invert","toJSON","toTextSelection","previousEscapeUnicodeCharacters","_ref44","initialText","ranges","isValidSelection","fromTextSelection","EditorState","create","extensions","keymap","of","indentWithTab","createLinter","lintGutter","lineNumbers","highlightActiveLineGutter","highlightSpecialChars","foldGutter","drawSelection","dropCursor","allowMultipleSelections","indentOnInput","defaultHighlightStyle","bracketMatching","closeBrackets","autocompletion","rectangularSelection","crosshairCursor","highlightActiveLine","highlightSelectionMatches","closeBracketsKeymap","defaultKeymap","searchKeymap","mac","foldKeymap","completionKeymap","lintKeymap","indentationMarkers","hideFirstIndent","EditorView","domEventHandlers","dblclick","handleDoubleClick","updateListener","transactions","transaction","annotation","onChangeCodeMirrorValueDebounced","selectionSet","emitOnSelect","jsonLang","lineWrapping","createIndent","theme","dark","hasDarkTheme","createCodeMirrorView","disableTextEditor","emitChange","setCodeMirrorContent","jsonStatus","jsonParseError","handleSort","_onSort2","_ref42","_x26","_ref43","closeSearchPanel","openSearchPanel","annotations","ChangeSet","fromJSON","EditorSelection","handleAcceptTooLarge","handleSwitchToTreeMode","cancelLoadTooLarge","onChangeCodeMirrorValue","toRichValidationError","setSelection","_event","selectedText","jsmap","jsonSourceMap","pointers","_pointer$value","valueEnd","linter","linterCallback","delay","pointerName","keyEnd","findTextLocation","toRichParseError","toDiagnostic","newContent","forceUpdate","newText","_refresh","_updateTheme","updateTheme","codeMirrorText","reconfigure","repeat","memoizedValidateText","handleShowMe","richParseError","handleSelectParseError","repairActionShowMe","faEye","eq","updateLinter","updateIndentation","updateTabSize","updateReadOnly","repairActions","isNewDocument","onFormat","onCompact","onToggleSearch","canFormat","canCompact","canSort","canTransform","searchItem","editorDisabled","lineNumber","columnNumber","charCount","_editorState","_editorState2","_editorState3","_get28","_get29","_get30","nestedArrayPaths","hasNestedArrays","isEmptyDocument","documentType","_get31","nestedArrayPath","countItems","_get32","text_6","_get33","_ref45","_get34","flattenColumns","_x27","_handleFocusSearch2","containsValidArray","itemHeightsCache","onSortByHeader","newSortedColumn","newValidationErrors","patchedSortedColumn","handleScroll","createDefaultSelectionWhenUndefined","createDefaultSelection","searchBoxHeight","roughDistance","scrollToHorizontal","_callback","headerHeight","scrollToVertical","_get$querySelector2","_get35","resolvedPath","_ref47","_onRenderContextMenu2","_ref46","onEditRow","onDuplicateRow","onInsertBeforeRow","onInsertAfterRow","onRemoveRow","createTableContextMenuItems","handleEditRow","handleDuplicateRow","handleInsertBeforeRow","handleInsertAfterRow","handleRemoveRow","_get36","_get37","handleContextMenuFromTableMenu","_handleParsePastedJson2","_handlePasteFromMenu2","_x28","_handleCut2","_handleCopy2","_ref31","rowPath","_ref32","_ref33","nextRowIndex","nextRowPath","_ref34","newRowIndex","_handleInsertCharacter2","_event$clipboardData2","_unused25","_ref48","handleResizeContents","currentContent","_unused24","newColumns","previousColumns","orderedColumns","newColumnsSet","maintainColumnOrder","showRefreshButton","extendedOperations","unshift","createNestedValueOperations","groupedValidationErrors","_get38","_get39","node_7","columnName","_sortedColumn","sortDirectionName","faCaretUp","onRefresh","faRotate","visibleIndex","validationErrorsByRow","_get40","searchResultByRow","th_3","handleResizeRow","_get41","node_14","$$array","isSelected","validationErrorsByColumn","_get42","searchResultsByCell","containsActiveSearchResult","containsSearchResult","onEdit","_parser$stringify","searchResultItemsByCell","_getInRecursiveState","expression_3","expression_6","td","td_3","_get43","selectPreviousColumn","selectNextColumn","selectPreviousRow","selectNextRow","_x29","externalMode","insideModal","refTreeMode","refTableMode","refTextMode","prevItem","nextItem","modeMenuItems","separatorMenuItem","handleRenderMenu","handleRenderContextMenu","_refresh2","applyExternalMode","updatedItems","updatedItemsOriginal","cloneDeep","modal","_onRenderContextMenu3","itemsOriginal","sortModalStates","contentDefault","selectionDefault","readOnlyDefault","modeDefault","mainMenuBarDefault","navigationBarDefault","statusBarDefault","askToFormatDefault","escapeControlCharactersDefault","escapeUnicodeCharactersDefault","flattenColumnsDefault","parserDefault","validatorDefault","validationParserDefault","pathParserDefault","queryLanguagesDefault","queryLanguageIdDefault","onChangeQueryLanguageDefault","onChangeDefault","onSelectDefault","onRenderValueDefault","onClassNameDefault","onRenderMenuDefault","onRenderContextMenuDefault","onChangeModeDefault","onErrorDefault","alert","onFocusDefault","onBlurDefault","instanceId","refJSONEditorRoot","jsonEditorModalProps","sortModalProps","transformModalProps","previousParser","_x30","_set$","contentError","_x31","_update","_x32","_patch","_x33","_select","_x34","_x35","_expand","_x36","_collapse2","_acceptAutoRepair","_x37","_scrollTo2","_focus","_refresh3","updateProps","_x38","_updateProps","_props$name","_props$name2","_props$name3","_props$name4","_props$name5","_props$name6","_props$name7","_props$name8","_props$name9","_props$name10","_props$name11","_props$name12","_props$name13","_props$name14","_props$name15","_props$name16","_props$name17","_props$name18","_props$name19","_props$name20","_props$name21","_props$name22","_props$name23","_props$name24","_props$name25","_props$name26","_props$name27","_props$name28","_props$name29","_props$name30","names","unknownProperty","_destroy","toggleMode","_x39","_toggleMode","newMode","_ref50","_ref51","directions","selectedProperty","_$$_import_sortModalS","$$_import_sortModalStates","selectedDirection","_$$_import_sortModalS2","sortError","_get48","_get49","_get50","_get51","_get52","_get53","_get54","refEditor","rootState","determineMode","scrollToSelection","_last","currentState","parentJson","updatedParentContent","updatedParentState","_get45","updateState","handleChangeSelection","handleChangeMode","handleError","newError","handleJSONEditorModal","_ref49","nestedModalState","_get46","_get44","absolutePath","pathDescription","faCaretLeft","_get55","createJSONEditor","_ref52","editor","JsonEditor","JSONEditor","_ref54"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,58,63,64,65,88,89,90,91,92,93,94,95,156]}