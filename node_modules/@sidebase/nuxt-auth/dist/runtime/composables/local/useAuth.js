import { readonly } from "vue";
import { jsonPointerGet, objectFromJsonPointer, useTypedBackendConfig } from "../../helpers.js";
import { _fetch } from "../../utils/fetch.js";
import { determineCallbackUrl } from "../../utils/url.js";
import { getRequestURLWN } from "../common/getRequestURL.js";
import { formatToken } from "./utils/token.js";
import { useAuthState } from "./useAuthState.js";
import { callWithNuxt } from "#app/nuxt";
import { navigateTo, nextTick, useNuxtApp, useRoute, useRuntimeConfig } from "#imports";
const signIn = async (credentials, signInOptions, signInParams, signInHeaders) => {
  const nuxt = useNuxtApp();
  const runtimeConfig = useRuntimeConfig();
  const config = useTypedBackendConfig(runtimeConfig, "local");
  const { path, method } = config.endpoints.signIn;
  const response = await _fetch(nuxt, path, {
    method,
    body: credentials,
    params: signInParams ?? {},
    headers: signInHeaders ?? {}
  });
  const { rawToken, rawRefreshToken } = useAuthState();
  const extractedToken = jsonPointerGet(response, config.token.signInResponseTokenPointer);
  if (typeof extractedToken !== "string") {
    console.error(
      `Auth: string token expected, received instead: ${JSON.stringify(extractedToken)}. Tried to find token at ${config.token.signInResponseTokenPointer} in ${JSON.stringify(response)}`
    );
    return;
  }
  rawToken.value = extractedToken;
  if (config.refresh.isEnabled) {
    const refreshTokenPointer = config.refresh.token.signInResponseRefreshTokenPointer;
    const extractedRefreshToken = jsonPointerGet(response, refreshTokenPointer);
    if (typeof extractedRefreshToken !== "string") {
      console.error(
        `Auth: string token expected, received instead: ${JSON.stringify(extractedRefreshToken)}. Tried to find refresh token at ${refreshTokenPointer} in ${JSON.stringify(response)}`
      );
      return;
    }
    rawRefreshToken.value = extractedRefreshToken;
  }
  const { redirect = true, external, callGetSession = true } = signInOptions ?? {};
  if (callGetSession) {
    await nextTick(getSession);
  }
  let { callbackUrl } = signInOptions ?? {};
  if (typeof callbackUrl === "undefined") {
    const redirectQueryParam = useRoute()?.query?.redirect;
    if (redirectQueryParam) {
      callbackUrl = redirectQueryParam.toString();
    } else {
      callbackUrl = await determineCallbackUrl(runtimeConfig.public.auth, () => getRequestURLWN(nuxt));
    }
  }
  if (redirect) {
    return navigateTo(callbackUrl, { external });
  }
};
const signOut = async (signOutOptions) => {
  const nuxt = useNuxtApp();
  const runtimeConfig = useRuntimeConfig();
  const config = useTypedBackendConfig(runtimeConfig, "local");
  const { data, token, rawToken, refreshToken, rawRefreshToken } = await callWithNuxt(nuxt, useAuthState);
  const signOutConfig = config.endpoints.signOut;
  let headers;
  let body;
  if (signOutConfig) {
    headers = new Headers({ [config.token.headerName]: token.value });
    if (config.refresh.isEnabled && ["post", "put", "patch", "delete"].includes(signOutConfig.method.toLowerCase())) {
      const signoutRequestRefreshTokenPointer = config.refresh.token.refreshRequestTokenPointer;
      body = objectFromJsonPointer(signoutRequestRefreshTokenPointer, refreshToken.value);
    }
  }
  data.value = null;
  rawToken.value = null;
  rawRefreshToken.value = null;
  let res;
  if (signOutConfig) {
    const { path, method } = signOutConfig;
    res = await _fetch(nuxt, path, { method, headers, body });
  }
  const { callbackUrl, redirect = true, external } = signOutOptions ?? {};
  if (redirect) {
    await navigateTo(callbackUrl ?? await getRequestURLWN(nuxt), { external });
  }
  return res;
};
async function getSession(getSessionOptions) {
  const nuxt = useNuxtApp();
  const config = useTypedBackendConfig(useRuntimeConfig(), "local");
  const { path, method } = config.endpoints.getSession;
  const { data, loading, lastRefreshedAt, rawToken, token: tokenState, _internal } = useAuthState();
  let token = tokenState.value;
  token ??= formatToken(_internal.rawTokenCookie.value, config);
  if (!token && !getSessionOptions?.force) {
    loading.value = false;
    return;
  }
  const headers = new Headers(token ? { [config.token.headerName]: token } : void 0);
  loading.value = true;
  try {
    const result = await _fetch(nuxt, path, { method, headers });
    const { dataResponsePointer: sessionDataResponsePointer } = config.session;
    data.value = jsonPointerGet(result, sessionDataResponsePointer);
  } catch (err) {
    if (!data.value && err instanceof Error) {
      console.error(`Session: unable to extract session, ${err.message}`);
    }
    data.value = null;
    rawToken.value = null;
  }
  loading.value = false;
  lastRefreshedAt.value = /* @__PURE__ */ new Date();
  const { required = false, callbackUrl, onUnauthenticated, external } = getSessionOptions ?? {};
  if (required && data.value === null) {
    if (onUnauthenticated) {
      return onUnauthenticated();
    }
    await navigateTo(callbackUrl ?? await getRequestURLWN(nuxt), { external });
  }
  return data.value;
}
async function signUp(credentials, signInOptions, signUpOptions) {
  const nuxt = useNuxtApp();
  const { path, method } = useTypedBackendConfig(useRuntimeConfig(), "local").endpoints.signUp;
  await _fetch(nuxt, path, {
    method,
    body: credentials
  });
  if (signUpOptions?.preventLoginFlow) {
    return;
  }
  return signIn(credentials, signInOptions);
}
async function refresh(getSessionOptions) {
  const nuxt = useNuxtApp();
  const config = useTypedBackendConfig(useRuntimeConfig(), "local");
  if (!config.refresh.isEnabled) {
    return getSession(getSessionOptions);
  }
  const { path, method } = config.refresh.endpoint;
  const refreshRequestTokenPointer = config.refresh.token.refreshRequestTokenPointer;
  const { refreshToken, token, rawToken, rawRefreshToken, lastRefreshedAt } = useAuthState();
  const headers = new Headers({
    [config.token.headerName]: token.value
  });
  const response = await _fetch(nuxt, path, {
    method,
    headers,
    body: objectFromJsonPointer(refreshRequestTokenPointer, refreshToken.value)
  });
  const tokenPointer = config.refresh.token.refreshResponseTokenPointer || config.token.signInResponseTokenPointer;
  const extractedToken = jsonPointerGet(response, tokenPointer);
  if (typeof extractedToken !== "string") {
    console.error(
      `Auth: string token expected, received instead: ${JSON.stringify(extractedToken)}. Tried to find token at ${tokenPointer} in ${JSON.stringify(response)}`
    );
    return;
  }
  if (!config.refresh.refreshOnlyToken) {
    const refreshTokenPointer = config.refresh.token.signInResponseRefreshTokenPointer;
    const extractedRefreshToken = jsonPointerGet(response, refreshTokenPointer);
    if (typeof extractedRefreshToken !== "string") {
      console.error(
        `Auth: string token expected, received instead: ${JSON.stringify(extractedRefreshToken)}. Tried to find refresh token at ${refreshTokenPointer} in ${JSON.stringify(response)}`
      );
      return;
    }
    rawRefreshToken.value = extractedRefreshToken;
  }
  rawToken.value = extractedToken;
  lastRefreshedAt.value = /* @__PURE__ */ new Date();
  await nextTick();
  return getSession(getSessionOptions);
}
export function useAuth() {
  const {
    data,
    status,
    lastRefreshedAt,
    token,
    refreshToken
  } = useAuthState();
  return {
    status,
    data: readonly(data),
    lastRefreshedAt: readonly(lastRefreshedAt),
    token: readonly(token),
    refreshToken: readonly(refreshToken),
    getSession,
    signIn,
    signOut,
    signUp,
    refresh
  };
}
